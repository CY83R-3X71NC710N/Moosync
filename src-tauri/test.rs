#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use std::fs;
use extensions::get_extension_state;
use librespot::{
    get_canvaz, get_librespot_state, initialize_librespot, librespot_close,
    librespot_get_token, librespot_load, librespot_pause, librespot_play, librespot_seek,
    librespot_volume, register_event,
};
use lyrics::{get_lyrics, get_lyrics_state};
use mpris::{get_mpris_state, set_metadata, set_playback_state, set_position};
use preference_holder::{
    get_preference_state, get_secure, handle_pref_changes, initial, load_selective,
    load_selective_array, save_selective, set_secure,
};
use providers::handler::get_provider_handler_state;
use rodio::{
    get_rodio_state, rodio_get_volume, rodio_load, rodio_pause, rodio_play, rodio_seek,
    rodio_set_volume, rodio_stop,
};
use themes::{
    export_theme, get_theme_handler_state, import_theme, load_all_themes, load_theme,
    remove_theme, save_theme, transform_css,
};
use extensions::{
    download_extension, get_extension_icon, get_extension_manifest,
    get_installed_extensions, install_extension, remove_extension, send_extra_event,
};
use providers::handler::{
    fetch_playback_url, fetch_playlist_content, fetch_user_playlists, get_all_status,
    get_provider_key_by_id, get_provider_keys, get_suggestions, initialize_all_providers,
    match_url, playlist_from_url, provider_authorize, provider_login, provider_search,
    provider_signout, song_from_url,
};
use scanner::{get_scanner_state, start_scan};
use tauri::{Listener, Manager, State};
use tracing_appender::rolling::{RollingFileAppender, Rotation};
use tracing_subscriber::{filter::EnvFilter, fmt::self, layer::SubscriberExt};
use window::handler::{build_tray_menu, handle_window_close};
use {
    db::{
        get_cache_state,
        {
            add_to_playlist, create_playlist, export_playlist, get_db_state,
            get_entity_by_options, get_songs_by_options, increment_play_count,
            increment_play_time, insert_songs, remove_from_playlist, remove_playlist,
            remove_songs, search_all, update_album, update_artist, update_lyrics,
            update_playlist, update_songs,
        },
    },
    oauth::handler::{get_oauth_state, OAuthHandler},
    window::handler::{
        close_window, disable_fullscreen, enable_fullscreen, get_platform,
        get_window_state, has_frame, is_maximized, maximize_window, minimize_window,
        open_external, open_file_browser, open_window, restart_app, toggle_dev_tools,
        toggle_fullscreen, update_zoom,
    },
    youtube::get_youtube_scraper_state,
};
mod db {
    use std::fs;
    use database::{cache::CacheHolder, database::Database};
    use macros::generate_command;
    use serde_json::Value;
    use tauri::{App, AppHandle, Manager, State};
    use tracing::{info, trace};
    use types::errors::Result;
    use types::{
        entities::{
            GetEntityOptions, QueryableAlbum, QueryableArtist, QueryablePlaylist,
            SearchResult,
        },
        songs::{GetSongOptions, QueryableSong, Song},
    };
    use crate::window::handler::WindowHandler;
    #[tracing::instrument(level = "trace", skip(app, db, window_handler, id))]
    pub fn export_playlist(
        app: AppHandle,
        db: State<Database>,
        window_handler: State<WindowHandler>,
        id: String,
    ) -> Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "export_playlist",
                                "app_lib::db",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                ::core::option::Option::Some(18u32),
                                ::core::option::Option::Some("app_lib::db"),
                                ::tracing_core::field::FieldSet::new(
                                    &["id"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&id) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/db/mod.rs:26",
                                    "app_lib::db",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                    ::core::option::Option::Some(26u32),
                                    ::core::option::Option::Some("app_lib::db"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Exporting playlist") as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let exported = db.export_playlist(id)?;
                    let selected_file = window_handler.open_save_file(app)?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/db/mod.rs:29",
                                    "app_lib::db",
                                    ::tracing::Level::TRACE,
                                    ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                    ::core::option::Option::Some(29u32),
                                    ::core::option::Option::Some("app_lib::db"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Exported playlist") as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    Ok(fs::write(selected_file, exported)?)
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__export_playlist;
    #[tracing::instrument(level = "trace", skip(db, songs))]
    pub fn insert_songs(
        db: State<Database>,
        songs: Vec<Song>,
    ) -> types::errors::Result<Vec<Song>> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "insert_songs",
                                "app_lib::db",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                ::core::option::Option::Some(33u32),
                                ::core::option::Option::Some("app_lib::db"),
                                ::tracing_core::field::FieldSet::new(
                                    &["songs"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&songs) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<Vec<Song>> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/db/mod.rs:33",
                                    "app_lib::db",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                    ::core::option::Option::Some(33u32),
                                    ::core::option::Option::Some("app_lib::db"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "insert_songs") as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.insert_songs(songs);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:33",
                                        "app_lib::db",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(33u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:33",
                                        "app_lib::db",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(33u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__insert_songs;
    #[tracing::instrument(level = "trace", skip(db, songs))]
    pub fn remove_songs(
        db: State<Database>,
        songs: Vec<String>,
    ) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "remove_songs",
                                "app_lib::db",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                ::core::option::Option::Some(34u32),
                                ::core::option::Option::Some("app_lib::db"),
                                ::tracing_core::field::FieldSet::new(
                                    &["songs"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&songs) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/db/mod.rs:34",
                                    "app_lib::db",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                    ::core::option::Option::Some(34u32),
                                    ::core::option::Option::Some("app_lib::db"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "remove_songs") as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.remove_songs(songs);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:34",
                                        "app_lib::db",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(34u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:34",
                                        "app_lib::db",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(34u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__remove_songs;
    #[tracing::instrument(level = "trace", skip(db, a))]
    pub fn update_song(
        db: State<Database>,
        a: QueryableSong,
    ) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "update_song",
                                "app_lib::db",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                ::core::option::Option::Some(35u32),
                                ::core::option::Option::Some("app_lib::db"),
                                ::tracing_core::field::FieldSet::new(
                                    &["a"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&a) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/db/mod.rs:35",
                                    "app_lib::db",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                    ::core::option::Option::Some(35u32),
                                    ::core::option::Option::Some("app_lib::db"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "update_song") as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.update_song(a);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:35",
                                        "app_lib::db",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(35u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:35",
                                        "app_lib::db",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(35u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__update_song;
    #[tracing::instrument(level = "trace", skip(db, options))]
    pub fn get_songs_by_options(
        db: State<Database>,
        options: GetSongOptions,
    ) -> types::errors::Result<Vec<Song>> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "get_songs_by_options",
                                "app_lib::db",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                ::core::option::Option::Some(36u32),
                                ::core::option::Option::Some("app_lib::db"),
                                ::tracing_core::field::FieldSet::new(
                                    &["options"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&options) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<Vec<Song>> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/db/mod.rs:36",
                                    "app_lib::db",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                    ::core::option::Option::Some(36u32),
                                    ::core::option::Option::Some("app_lib::db"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "get_songs_by_options")
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.get_songs_by_options(options);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:36",
                                        "app_lib::db",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(36u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:36",
                                        "app_lib::db",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(36u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__get_songs_by_options;
    #[tracing::instrument(level = "trace", skip(db, options))]
    pub fn get_entity_by_options(
        db: State<Database>,
        options: GetEntityOptions,
    ) -> types::errors::Result<Value> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "get_entity_by_options",
                                "app_lib::db",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                ::core::option::Option::Some(37u32),
                                ::core::option::Option::Some("app_lib::db"),
                                ::tracing_core::field::FieldSet::new(
                                    &["options"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&options) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<Value> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/db/mod.rs:37",
                                    "app_lib::db",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                    ::core::option::Option::Some(37u32),
                                    ::core::option::Option::Some("app_lib::db"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "get_entity_by_options")
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.get_entity_by_options(options);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:37",
                                        "app_lib::db",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(37u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:37",
                                        "app_lib::db",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(37u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__get_entity_by_options;
    #[tracing::instrument(level = "trace", skip(db, term))]
    pub fn search_all(
        db: State<Database>,
        term: String,
    ) -> types::errors::Result<SearchResult> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "search_all",
                                "app_lib::db",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                ::core::option::Option::Some(38u32),
                                ::core::option::Option::Some("app_lib::db"),
                                ::tracing_core::field::FieldSet::new(
                                    &["term"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&term) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<
                        SearchResult,
                    > = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/db/mod.rs:38",
                                    "app_lib::db",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                    ::core::option::Option::Some(38u32),
                                    ::core::option::Option::Some("app_lib::db"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "search_all") as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.search_all(term);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:38",
                                        "app_lib::db",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(38u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:38",
                                        "app_lib::db",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(38u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__search_all;
    #[tracing::instrument(level = "trace", skip(db, playlist))]
    pub fn create_playlist(
        db: State<Database>,
        playlist: QueryablePlaylist,
    ) -> types::errors::Result<String> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "create_playlist",
                                "app_lib::db",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                ::core::option::Option::Some(39u32),
                                ::core::option::Option::Some("app_lib::db"),
                                ::tracing_core::field::FieldSet::new(
                                    &["playlist"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&playlist) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<String> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/db/mod.rs:39",
                                    "app_lib::db",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                    ::core::option::Option::Some(39u32),
                                    ::core::option::Option::Some("app_lib::db"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "create_playlist")
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.create_playlist(playlist);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:39",
                                        "app_lib::db",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(39u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:39",
                                        "app_lib::db",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(39u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__create_playlist;
    #[tracing::instrument(level = "trace", skip(db, id, songs))]
    pub fn add_to_playlist(
        db: State<Database>,
        id: String,
        songs: Vec<Song>,
    ) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "add_to_playlist",
                                "app_lib::db",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                ::core::option::Option::Some(40u32),
                                ::core::option::Option::Some("app_lib::db"),
                                ::tracing_core::field::FieldSet::new(
                                    &["id", "songs"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&id) as &dyn Value,
                                                ),
                                            ),
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&songs) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/db/mod.rs:40",
                                    "app_lib::db",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                    ::core::option::Option::Some(40u32),
                                    ::core::option::Option::Some("app_lib::db"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "add_to_playlist")
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.add_to_playlist(id, songs);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:40",
                                        "app_lib::db",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(40u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:40",
                                        "app_lib::db",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(40u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__add_to_playlist;
    #[tracing::instrument(level = "trace", skip(db, id, songs))]
    pub fn remove_from_playlist(
        db: State<Database>,
        id: String,
        songs: Vec<String>,
    ) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "remove_from_playlist",
                                "app_lib::db",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                ::core::option::Option::Some(41u32),
                                ::core::option::Option::Some("app_lib::db"),
                                ::tracing_core::field::FieldSet::new(
                                    &["id", "songs"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&id) as &dyn Value,
                                                ),
                                            ),
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&songs) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/db/mod.rs:41",
                                    "app_lib::db",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                    ::core::option::Option::Some(41u32),
                                    ::core::option::Option::Some("app_lib::db"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "remove_from_playlist")
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.remove_from_playlist(id, songs);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:41",
                                        "app_lib::db",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(41u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:41",
                                        "app_lib::db",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(41u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__remove_from_playlist;
    #[tracing::instrument(level = "trace", skip(db, id))]
    pub fn remove_playlist(
        db: State<Database>,
        id: String,
    ) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "remove_playlist",
                                "app_lib::db",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                ::core::option::Option::Some(42u32),
                                ::core::option::Option::Some("app_lib::db"),
                                ::tracing_core::field::FieldSet::new(
                                    &["id"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&id) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/db/mod.rs:42",
                                    "app_lib::db",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                    ::core::option::Option::Some(42u32),
                                    ::core::option::Option::Some("app_lib::db"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "remove_playlist")
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.remove_playlist(id);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:42",
                                        "app_lib::db",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(42u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:42",
                                        "app_lib::db",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(42u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__remove_playlist;
    #[tracing::instrument(level = "trace", skip(db, album))]
    pub fn update_album(
        db: State<Database>,
        album: QueryableAlbum,
    ) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "update_album",
                                "app_lib::db",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                ::core::option::Option::Some(43u32),
                                ::core::option::Option::Some("app_lib::db"),
                                ::tracing_core::field::FieldSet::new(
                                    &["album"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&album) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/db/mod.rs:43",
                                    "app_lib::db",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                    ::core::option::Option::Some(43u32),
                                    ::core::option::Option::Some("app_lib::db"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "update_album") as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.update_album(album);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:43",
                                        "app_lib::db",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(43u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:43",
                                        "app_lib::db",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(43u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__update_album;
    #[tracing::instrument(level = "trace", skip(db, artist))]
    pub fn update_artist(
        db: State<Database>,
        artist: QueryableArtist,
    ) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "update_artist",
                                "app_lib::db",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                ::core::option::Option::Some(44u32),
                                ::core::option::Option::Some("app_lib::db"),
                                ::tracing_core::field::FieldSet::new(
                                    &["artist"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&artist) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/db/mod.rs:44",
                                    "app_lib::db",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                    ::core::option::Option::Some(44u32),
                                    ::core::option::Option::Some("app_lib::db"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "update_artist") as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.update_artist(artist);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:44",
                                        "app_lib::db",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(44u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:44",
                                        "app_lib::db",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(44u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__update_artist;
    #[tracing::instrument(level = "trace", skip(db, playlist))]
    pub fn update_playlist(
        db: State<Database>,
        playlist: QueryablePlaylist,
    ) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "update_playlist",
                                "app_lib::db",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                ::core::option::Option::Some(45u32),
                                ::core::option::Option::Some("app_lib::db"),
                                ::tracing_core::field::FieldSet::new(
                                    &["playlist"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&playlist) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/db/mod.rs:45",
                                    "app_lib::db",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                    ::core::option::Option::Some(45u32),
                                    ::core::option::Option::Some("app_lib::db"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "update_playlist")
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.update_playlist(playlist);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:45",
                                        "app_lib::db",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(45u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:45",
                                        "app_lib::db",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(45u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__update_playlist;
    #[tracing::instrument(level = "trace", skip(db, songs))]
    pub fn update_songs(
        db: State<Database>,
        songs: Vec<Song>,
    ) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "update_songs",
                                "app_lib::db",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                ::core::option::Option::Some(46u32),
                                ::core::option::Option::Some("app_lib::db"),
                                ::tracing_core::field::FieldSet::new(
                                    &["songs"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&songs) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/db/mod.rs:46",
                                    "app_lib::db",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                    ::core::option::Option::Some(46u32),
                                    ::core::option::Option::Some("app_lib::db"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "update_songs") as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.update_songs(songs);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:46",
                                        "app_lib::db",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(46u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:46",
                                        "app_lib::db",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(46u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__update_songs;
    #[tracing::instrument(level = "trace", skip(db, id, lyrics))]
    pub fn update_lyrics(
        db: State<Database>,
        id: String,
        lyrics: String,
    ) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "update_lyrics",
                                "app_lib::db",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                ::core::option::Option::Some(47u32),
                                ::core::option::Option::Some("app_lib::db"),
                                ::tracing_core::field::FieldSet::new(
                                    &["id", "lyrics"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&id) as &dyn Value,
                                                ),
                                            ),
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&lyrics) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/db/mod.rs:47",
                                    "app_lib::db",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                    ::core::option::Option::Some(47u32),
                                    ::core::option::Option::Some("app_lib::db"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "update_lyrics") as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.update_lyrics(id, lyrics);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:47",
                                        "app_lib::db",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(47u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:47",
                                        "app_lib::db",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(47u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__update_lyrics;
    #[tracing::instrument(level = "trace", skip(db, id))]
    pub fn increment_play_count(
        db: State<Database>,
        id: String,
    ) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "increment_play_count",
                                "app_lib::db",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                ::core::option::Option::Some(48u32),
                                ::core::option::Option::Some("app_lib::db"),
                                ::tracing_core::field::FieldSet::new(
                                    &["id"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&id) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/db/mod.rs:48",
                                    "app_lib::db",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                    ::core::option::Option::Some(48u32),
                                    ::core::option::Option::Some("app_lib::db"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "increment_play_count")
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.increment_play_count(id);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:48",
                                        "app_lib::db",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(48u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:48",
                                        "app_lib::db",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(48u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__increment_play_count;
    #[tracing::instrument(level = "trace", skip(db, id, duration))]
    pub fn increment_play_time(
        db: State<Database>,
        id: String,
        duration: f64,
    ) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "increment_play_time",
                                "app_lib::db",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                ::core::option::Option::Some(49u32),
                                ::core::option::Option::Some("app_lib::db"),
                                ::tracing_core::field::FieldSet::new(
                                    &["id", "duration"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&id) as &dyn Value,
                                                ),
                                            ),
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&duration) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/db/mod.rs:49",
                                    "app_lib::db",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                    ::core::option::Option::Some(49u32),
                                    ::core::option::Option::Some("app_lib::db"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "increment_play_time")
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.increment_play_time(id, duration);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:49",
                                        "app_lib::db",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(49u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/db/mod.rs:49",
                                        "app_lib::db",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                        ::core::option::Option::Some(49u32),
                                        ::core::option::Option::Some("app_lib::db"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__increment_play_time;
    #[tracing::instrument(level = "trace", skip(app))]
    pub fn get_cache_state(app: &mut App) -> CacheHolder {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "get_cache_state",
                                "app_lib::db",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                ::core::option::Option::Some(51u32),
                                ::core::option::Option::Some("app_lib::db"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: CacheHolder = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    let path = app.path().app_cache_dir().unwrap().join("http_cache.db");
                    if let Some(parent) = path.parent() {
                        if !parent.exists() {
                            fs::create_dir_all(parent).unwrap();
                        }
                    }
                    CacheHolder::new(path)
                }
            }
        }
    }
    #[tracing::instrument(level = "trace", skip(app))]
    pub fn get_db_state(app: &mut App) -> Database {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "get_db_state",
                                "app_lib::db",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/db/mod.rs"),
                                ::core::option::Option::Some(63u32),
                                ::core::option::Option::Some("app_lib::db"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: Database = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    let path = app.path().app_data_dir().unwrap().join("songs.db");
                    if let Some(parent) = path.parent() {
                        if !parent.exists() {
                            fs::create_dir_all(parent).unwrap();
                        }
                    }
                    Database::new(path)
                }
            }
        }
    }
}
mod extensions {
    use std::collections::HashMap;
    use database::cache::CacheHolder;
    use extensions::ExtensionHandler;
    use futures::SinkExt;
    use futures::StreamExt;
    use macros::generate_command_async;
    use macros::generate_command_async_cached;
    use request_handler::ReplyHandler;
    use serde_json::Value;
    use tauri::async_runtime;
    use tauri::AppHandle;
    use tauri::Manager;
    use tauri::State;
    use types::errors::Result;
    use types::extensions::ExtensionDetail;
    use types::extensions::ExtensionExtraEventArgs;
    use types::extensions::FetchedExtensionManifest;
    use types::extensions::PackageNameArgs;
    use crate::providers::handler::ProviderHandler;
    mod request_handler {
        use database::database::Database;
        use futures::channel::oneshot;
        use preferences::preferences::PreferenceConfig;
        use serde::{Deserialize, Serialize};
        use serde_json::Value;
        use tauri::{AppHandle, Emitter, Listener, Manager, State};
        use types::{
            errors::{MoosyncError, Result},
            extensions::{AddToPlaylistRequest, ExtensionUIRequest, PreferenceData},
            songs::{GetSongOptions, SearchableSong, Song},
        };
        use crate::{providers::handler::ProviderHandler, window::handler::WindowHandler};
        pub struct ReplyHandler {
            app_handle: AppHandle,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ReplyHandler {
            #[tracing::instrument(level = "trace", skip(self))]
            #[inline]
            fn clone(&self) -> ReplyHandler {
                ReplyHandler {
                    app_handle: ::core::clone::Clone::clone(&self.app_handle),
                }
            }
        }
        impl ReplyHandler {
            #[tracing::instrument(level = "trace", skip(app_handle))]
            pub fn new(app_handle: AppHandle) -> Self {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "new",
                                        "app_lib::extensions::request_handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/request_handler.rs",
                                        ),
                                        ::core::option::Option::Some(21u32),
                                        ::core::option::Option::Some(
                                            "app_lib::extensions::request_handler",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Self = loop {};
                            return __tracing_attr_fake_return;
                        }
                        { ReplyHandler { app_handle } }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, type_))]
            fn is_main_command(&self, type_: &str) -> bool {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "is_main_command",
                                        "app_lib::extensions::request_handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/request_handler.rs",
                                        ),
                                        ::core::option::Option::Some(26u32),
                                        ::core::option::Option::Some(
                                            "app_lib::extensions::request_handler",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: bool = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            [
                                "getSongs",
                                "getEntity",
                                "addSong",
                                "updateSong",
                                "addPlaylist",
                                "addSongToPlaylist",
                                "removeSong",
                                "getPreferences",
                                "getSecurePreferences",
                                "setPreferences",
                                "setSecurePreferences",
                                "registerOauth",
                                "openExternal",
                                "registerAccount",
                                "setArtistEditableInfo",
                                "setAlbumEditableInfo",
                            ]
                                .contains(&type_)
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, type_))]
            fn is_update(&self, type_: &str) -> bool {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "is_update",
                                        "app_lib::extensions::request_handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/request_handler.rs",
                                        ),
                                        ::core::option::Option::Some(49u32),
                                        ::core::option::Option::Some(
                                            "app_lib::extensions::request_handler",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: bool = loop {};
                            return __tracing_attr_fake_return;
                        }
                        { type_ == "extensionUpdated" }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, type_))]
            fn is_ui_request(&self, type_: &str) -> bool {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "is_ui_request",
                                        "app_lib::extensions::request_handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/request_handler.rs",
                                        ),
                                        ::core::option::Option::Some(54u32),
                                        ::core::option::Option::Some(
                                            "app_lib::extensions::request_handler",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: bool = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            [
                                "getCurrentSong",
                                "getVolume",
                                "getTime",
                                "getQueue",
                                "getPlayerState",
                                "openLoginModal",
                                "closeLoginModal",
                                "showToast",
                            ]
                                .contains(&type_)
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, data))]
            pub fn get_songs(&self, data: Value) -> Result<Value> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "get_songs",
                                        "app_lib::extensions::request_handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/request_handler.rs",
                                        ),
                                        ::core::option::Option::Some(69u32),
                                        ::core::option::Option::Some(
                                            "app_lib::extensions::request_handler",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<Value> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            let database: State<'_, Database> = self.app_handle.state();
                            let mut request: GetSongOptions = serde_json::from_value(
                                data,
                            )?;
                            if request.album.is_none() && request.artist.is_none()
                                && request.album.is_none() && request.song.is_none()
                            {
                                request.song = Some(SearchableSong::default());
                            }
                            let ret = database.get_songs_by_options(request)?;
                            Ok(serde_json::to_value(ret)?)
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, data))]
            pub fn get_entity(&self, data: Value) -> Result<Value> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "get_entity",
                                        "app_lib::extensions::request_handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/request_handler.rs",
                                        ),
                                        ::core::option::Option::Some(86u32),
                                        ::core::option::Option::Some(
                                            "app_lib::extensions::request_handler",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<Value> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            let database: State<'_, Database> = self.app_handle.state();
                            let ret = database
                                .get_entity_by_options(serde_json::from_value(data)?)?;
                            Ok(serde_json::to_value(ret)?)
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, data))]
            pub fn add_songs(&self, data: Value) -> Result<Value> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "add_songs",
                                        "app_lib::extensions::request_handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/request_handler.rs",
                                        ),
                                        ::core::option::Option::Some(93u32),
                                        ::core::option::Option::Some(
                                            "app_lib::extensions::request_handler",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<Value> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            let database: State<'_, Database> = self.app_handle.state();
                            let ret = database
                                .insert_songs(serde_json::from_value(data.clone())?)?;
                            Ok(serde_json::to_value(ret)?)
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, data))]
            pub fn update_song(&self, data: Value) -> Result<Value> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "update_song",
                                        "app_lib::extensions::request_handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/request_handler.rs",
                                        ),
                                        ::core::option::Option::Some(100u32),
                                        ::core::option::Option::Some(
                                            "app_lib::extensions::request_handler",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<Value> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            let database: State<'_, Database> = self.app_handle.state();
                            database
                                .update_songs(
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            serde_json::from_value(data.clone())?,
                                        ]),
                                    ),
                                )?;
                            Ok(data)
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, data))]
            pub fn add_playlist(&self, data: Value) -> Result<Value> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "add_playlist",
                                        "app_lib::extensions::request_handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/request_handler.rs",
                                        ),
                                        ::core::option::Option::Some(107u32),
                                        ::core::option::Option::Some(
                                            "app_lib::extensions::request_handler",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<Value> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            let database: State<'_, Database> = self.app_handle.state();
                            let ret = database
                                .create_playlist(serde_json::from_value(data)?)?;
                            Ok(serde_json::to_value(ret)?)
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, data))]
            pub fn add_to_playlist(&self, data: Value) -> Result<Value> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "add_to_playlist",
                                        "app_lib::extensions::request_handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/request_handler.rs",
                                        ),
                                        ::core::option::Option::Some(114u32),
                                        ::core::option::Option::Some(
                                            "app_lib::extensions::request_handler",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<Value> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            let database: State<'_, Database> = self.app_handle.state();
                            let request: AddToPlaylistRequest = serde_json::from_value(
                                data,
                            )?;
                            database
                                .add_to_playlist(request.playlist_id, request.songs)?;
                            Ok(Value::Null)
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, data))]
            pub fn remove_song(&self, data: Value) -> Result<Value> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "remove_song",
                                        "app_lib::extensions::request_handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/request_handler.rs",
                                        ),
                                        ::core::option::Option::Some(122u32),
                                        ::core::option::Option::Some(
                                            "app_lib::extensions::request_handler",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<Value> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            let database: State<'_, Database> = self.app_handle.state();
                            let request: Song = serde_json::from_value(data)?;
                            if let Some(song_id) = request.song._id {
                                database
                                    .remove_songs(
                                        <[_]>::into_vec(
                                            #[rustc_box]
                                            ::alloc::boxed::Box::new([song_id]),
                                        ),
                                    )?;
                            }
                            Ok(Value::Null)
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, _data))]
            pub fn set_artist_editable_info(&self, _data: Value) -> Result<Value> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "set_artist_editable_info",
                                        "app_lib::extensions::request_handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/request_handler.rs",
                                        ),
                                        ::core::option::Option::Some(132u32),
                                        ::core::option::Option::Some(
                                            "app_lib::extensions::request_handler",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<Value> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        { Ok(Value::Null) }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, _data))]
            pub fn set_album_editable_info(&self, _data: Value) -> Result<Value> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "set_album_editable_info",
                                        "app_lib::extensions::request_handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/request_handler.rs",
                                        ),
                                        ::core::option::Option::Some(138u32),
                                        ::core::option::Option::Some(
                                            "app_lib::extensions::request_handler",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<Value> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        { Ok(Value::Null) }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, package_name, data))]
            pub fn get_preferences(
                &self,
                package_name: String,
                data: Value,
            ) -> Result<Value> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "get_preferences",
                                        "app_lib::extensions::request_handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/request_handler.rs",
                                        ),
                                        ::core::option::Option::Some(144u32),
                                        ::core::option::Option::Some(
                                            "app_lib::extensions::request_handler",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<Value> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            let preferences: State<'_, PreferenceConfig> = self
                                .app_handle
                                .state();
                            let request: PreferenceData = serde_json::from_value(data)?;
                            let ret: Result<Value> = preferences
                                .load_selective(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("extension.{0}.{1}", package_name, request.key),
                                        );
                                        res
                                    }),
                                );
                            Ok(
                                match ret {
                                    Ok(v) => v,
                                    Err(_) => serde_json::to_value(&request.default_value)?,
                                },
                            )
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, package_name, data))]
            pub fn set_preferences(
                &self,
                package_name: String,
                data: Value,
            ) -> Result<Value> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "set_preferences",
                                        "app_lib::extensions::request_handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/request_handler.rs",
                                        ),
                                        ::core::option::Option::Some(156u32),
                                        ::core::option::Option::Some(
                                            "app_lib::extensions::request_handler",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<Value> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            let preferences: State<'_, PreferenceConfig> = self
                                .app_handle
                                .state();
                            let request: PreferenceData = serde_json::from_value(data)?;
                            preferences
                                .save_selective(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("extension.{0}.{1}", package_name, request.key),
                                        );
                                        res
                                    }),
                                    request.value,
                                )?;
                            Ok(Value::Null)
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, package_name, data))]
            pub fn get_secure(
                &self,
                package_name: String,
                data: Value,
            ) -> Result<Value> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "get_secure",
                                        "app_lib::extensions::request_handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/request_handler.rs",
                                        ),
                                        ::core::option::Option::Some(167u32),
                                        ::core::option::Option::Some(
                                            "app_lib::extensions::request_handler",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<Value> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            let preferences: State<'_, PreferenceConfig> = self
                                .app_handle
                                .state();
                            let request: PreferenceData = serde_json::from_value(data)?;
                            preferences
                                .get_secure(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("extension.{0}.{1}", package_name, request.key),
                                        );
                                        res
                                    }),
                                )
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, package_name, data))]
            pub fn set_secure(
                &self,
                package_name: String,
                data: Value,
            ) -> Result<Value> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "set_secure",
                                        "app_lib::extensions::request_handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/request_handler.rs",
                                        ),
                                        ::core::option::Option::Some(174u32),
                                        ::core::option::Option::Some(
                                            "app_lib::extensions::request_handler",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<Value> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            let preferences: State<'_, PreferenceConfig> = self
                                .app_handle
                                .state();
                            let request: PreferenceData = serde_json::from_value(data)?;
                            preferences
                                .set_secure(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("extension.{0}.{1}", package_name, request.key),
                                        );
                                        res
                                    }),
                                    request.value,
                                )?;
                            Ok(Value::Null)
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, _data))]
            pub fn register_oauth(&self, _data: Value) -> Result<Value> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "register_oauth",
                                        "app_lib::extensions::request_handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/request_handler.rs",
                                        ),
                                        ::core::option::Option::Some(186u32),
                                        ::core::option::Option::Some(
                                            "app_lib::extensions::request_handler",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<Value> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        { Ok(Value::Null) }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, data))]
            pub fn open_external(&self, data: Value) -> Result<Value> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "open_external",
                                        "app_lib::extensions::request_handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/request_handler.rs",
                                        ),
                                        ::core::option::Option::Some(192u32),
                                        ::core::option::Option::Some(
                                            "app_lib::extensions::request_handler",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<Value> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            if data.is_string() {
                                let window_handler: State<WindowHandler> = self
                                    .app_handle
                                    .state();
                                window_handler
                                    .open_external(data.as_str().unwrap().into())?;
                            }
                            Ok(Value::Null)
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, package_name))]
            fn register_account(&self, package_name: String) -> Result<Value> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "register_account",
                                        "app_lib::extensions::request_handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/request_handler.rs",
                                        ),
                                        ::core::option::Option::Some(201u32),
                                        ::core::option::Option::Some(
                                            "app_lib::extensions::request_handler",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<Value> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            let app_handle = self.app_handle.clone();
                            tauri::async_runtime::spawn(async move {
                                let provider_handler: State<ProviderHandler> = app_handle
                                    .state();
                                provider_handler.initialize_provider(package_name).await;
                            });
                            Ok(Value::Null)
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, request))]
            async fn send_ui_request(
                &self,
                request: ExtensionUIRequest,
            ) -> Result<Value> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "send_ui_request",
                                "app_lib::extensions::request_handler",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/extensions/request_handler.rs",
                                ),
                                ::core::option::Option::Some(211u32),
                                ::core::option::Option::Some(
                                    "app_lib::extensions::request_handler",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<Value> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        if self.app_handle.webview_windows().is_empty() {
                            return Ok(Value::Null);
                        }
                        let (tx, rx) = oneshot::channel();
                        self.app_handle
                            .once(
                                ::alloc::__export::must_use({
                                    let res = ::alloc::fmt::format(
                                        format_args!("ui-reply-{0}", request.channel),
                                    );
                                    res
                                }),
                                move |f| {
                                    let payload = f.payload().to_string();
                                    let _ = tx.send(payload);
                                },
                            );
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/extensions/request_handler.rs:223",
                                        "app_lib::extensions::request_handler",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/request_handler.rs",
                                        ),
                                        ::core::option::Option::Some(223u32),
                                        ::core::option::Option::Some(
                                            "app_lib::extensions::request_handler",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Sending ui request {0:?}", request)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        self.app_handle.emit("ui-requests", request.clone())?;
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/extensions/request_handler.rs:225",
                                        "app_lib::extensions::request_handler",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/request_handler.rs",
                                        ),
                                        ::core::option::Option::Some(225u32),
                                        ::core::option::Option::Some(
                                            "app_lib::extensions::request_handler",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("sent ui request {0:?}", request)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        let res = rx.await;
                        if let Ok(data) = res {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/extensions/request_handler.rs:229",
                                            "app_lib::extensions::request_handler",
                                            ::tracing::Level::INFO,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/extensions/request_handler.rs",
                                            ),
                                            ::core::option::Option::Some(229u32),
                                            ::core::option::Option::Some(
                                                "app_lib::extensions::request_handler",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::INFO
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::INFO
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("got ui reply {0:?}", data) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            Ok(serde_json::from_str(&data)?)
                        } else {
                            Ok(Value::Null)
                        }
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
            #[tracing::instrument(level = "trace", skip(self))]
            pub async fn extension_updated(&self) -> Result<Value> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "extension_updated",
                                "app_lib::extensions::request_handler",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/extensions/request_handler.rs",
                                ),
                                ::core::option::Option::Some(238u32),
                                ::core::option::Option::Some(
                                    "app_lib::extensions::request_handler",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<Value> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/extensions/request_handler.rs:240",
                                        "app_lib::extensions::request_handler",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/request_handler.rs",
                                        ),
                                        ::core::option::Option::Some(240u32),
                                        ::core::option::Option::Some(
                                            "app_lib::extensions::request_handler",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got extension updated") as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        let provider_handle: State<ProviderHandler> = self
                            .app_handle
                            .state();
                        provider_handle.discover_provider_extensions().await?;
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/extensions/request_handler.rs:243",
                                        "app_lib::extensions::request_handler",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/request_handler.rs",
                                        ),
                                        ::core::option::Option::Some(243u32),
                                        ::core::option::Option::Some(
                                            "app_lib::extensions::request_handler",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Updated extension") as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        Ok(Value::Null)
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
            #[tracing::instrument(level = "trace", skip(self, value))]
            pub async fn handle_request(&self, value: &Value) -> Result<Vec<u8>> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "handle_request",
                                "app_lib::extensions::request_handler",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/extensions/request_handler.rs",
                                ),
                                ::core::option::Option::Some(247u32),
                                ::core::option::Option::Some(
                                    "app_lib::extensions::request_handler",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<Vec<u8>> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        let request: ExtensionUIRequest = serde_json::from_value(
                            value.clone(),
                        )?;
                        let mut ret = request.clone();
                        let res = if self.is_main_command(&request.type_) {
                            if request.data.is_none() {
                                return Err(
                                    MoosyncError::String("Missing data field".into()),
                                );
                            }
                            match request.type_.as_str() {
                                "getSongs" => self.get_songs(request.data.unwrap()),
                                "getEntity" => self.get_entity(request.data.unwrap()),
                                "addSong" => self.add_songs(request.data.unwrap()),
                                "updateSong" => self.update_song(request.data.unwrap()),
                                "addPlaylist" => self.add_playlist(request.data.unwrap()),
                                "addSongToPlaylist" => {
                                    self.add_to_playlist(request.data.unwrap())
                                }
                                "removeSong" => self.remove_song(request.data.unwrap()),
                                "getPreferences" => {
                                    self.get_preferences(
                                        request.extension_name,
                                        request.data.unwrap(),
                                    )
                                }
                                "getSecurePreferences" => {
                                    self.get_secure(
                                        request.extension_name,
                                        request.data.unwrap(),
                                    )
                                }
                                "setPreferences" => {
                                    self.set_preferences(
                                        request.extension_name,
                                        request.data.unwrap(),
                                    )
                                }
                                "setSecurePreferences" => {
                                    self.set_secure(
                                        request.extension_name,
                                        request.data.unwrap(),
                                    )
                                }
                                "registerOauth" => {
                                    self.register_oauth(request.data.unwrap())
                                }
                                "openExternal" => self.open_external(request.data.unwrap()),
                                "registerAccount" => {
                                    self.register_account(request.extension_name)
                                }
                                "setArtistEditableInfo" => {
                                    self.set_artist_editable_info(request.data.unwrap())
                                }
                                "setAlbumEditableInfo" => {
                                    self.set_album_editable_info(request.data.unwrap())
                                }
                                _ => {
                                    ::core::panicking::panic(
                                        "internal error: entered unreachable code",
                                    )
                                }
                            }
                        } else if self.is_update(&request.type_) {
                            self.extension_updated().await
                        } else if self.is_ui_request(&request.type_) {
                            self.send_ui_request(request).await
                        } else {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/extensions/request_handler.rs:289",
                                            "app_lib::extensions::request_handler",
                                            ::tracing::Level::INFO,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/extensions/request_handler.rs",
                                            ),
                                            ::core::option::Option::Some(289u32),
                                            ::core::option::Option::Some(
                                                "app_lib::extensions::request_handler",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::INFO
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::INFO
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Not a valid request {0:?}", request)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            Ok(Value::Null)
                        };
                        match res {
                            Ok(v) => ret.data = Some(v),
                            Err(e) => {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/extensions/request_handler.rs:296",
                                                "app_lib::extensions::request_handler",
                                                ::tracing::Level::ERROR,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/extensions/request_handler.rs",
                                                ),
                                                ::core::option::Option::Some(296u32),
                                                ::core::option::Option::Some(
                                                    "app_lib::extensions::request_handler",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::ERROR
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("Error handling request {0:?}: {1}", value, e)
                                                                    as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                        }
                        Ok(serde_json::to_vec(&ret)?)
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
        }
    }
    #[tracing::instrument(level = "trace", skip(app_handle))]
    async fn extension_runner_connected(app_handle: AppHandle) {
        {}
        let __tracing_attr_span = {
            use ::tracing::__macro_support::Callsite as _;
            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "extension_runner_connected",
                        "app_lib::extensions",
                        tracing::Level::TRACE,
                        ::core::option::Option::Some("src-tauri/src/extensions/mod.rs"),
                        ::core::option::Option::Some(25u32),
                        ::core::option::Option::Some("app_lib::extensions"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = __CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    __CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = __CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    __CALLSITE.metadata(),
                );
                {};
                span
            }
        };
        let __tracing_instrument_future = async move {
            #[allow(
                unknown_lints,
                unreachable_code,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::unreachable,
                clippy::let_with_type_underscore,
                clippy::empty_loop
            )]
            if false {
                let __tracing_attr_fake_return: () = loop {};
                return __tracing_attr_fake_return;
            }
            {
                let provider_handler: State<ProviderHandler> = app_handle.state();
                provider_handler.discover_provider_extensions().await.unwrap();
            }
        };
        if !__tracing_attr_span.is_disabled() {
            tracing::Instrument::instrument(
                    __tracing_instrument_future,
                    __tracing_attr_span,
                )
                .await
        } else {
            __tracing_instrument_future.await
        }
    }
    #[tracing::instrument(level = "trace", skip(app))]
    pub fn get_extension_state(app: AppHandle) -> Result<ExtensionHandler> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "get_extension_state",
                                "app_lib::extensions",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/extensions/mod.rs",
                                ),
                                ::core::option::Option::Some(34u32),
                                ::core::option::Option::Some("app_lib::extensions"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: Result<ExtensionHandler> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    let ext_path = app.path().app_data_dir().unwrap().join("extensions");
                    let tmp_dir = app.path().temp_dir().unwrap();
                    let ext_handler = ExtensionHandler::new(ext_path, tmp_dir);
                    let mut rx_listen = ext_handler.listen_socket()?;
                    async_runtime::spawn(async move {
                        let app_handle = app.clone();
                        loop {
                            let rx_ext_command = rx_listen.next().await;
                            if let Some(mut rx_ext_command) = rx_ext_command {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/extensions/mod.rs:46",
                                                "app_lib::extensions",
                                                ::tracing::Level::TRACE,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/extensions/mod.rs",
                                                ),
                                                ::core::option::Option::Some(46u32),
                                                ::core::option::Option::Some("app_lib::extensions"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::TRACE
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("Got extension connection") as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                let app_handle = app_handle.clone();
                                let app_handle_1 = app_handle.clone();
                                async_runtime::spawn(async move {
                                    let request_handler = ReplyHandler::new(app_handle);
                                    while let Some((message, mut tx_reply)) = rx_ext_command
                                        .next()
                                        .await
                                    {
                                        {
                                            use ::tracing::__macro_support::Callsite as _;
                                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                                static META: ::tracing::Metadata<'static> = {
                                                    ::tracing_core::metadata::Metadata::new(
                                                        "event src-tauri/src/extensions/mod.rs:52",
                                                        "app_lib::extensions",
                                                        ::tracing::Level::TRACE,
                                                        ::core::option::Option::Some(
                                                            "src-tauri/src/extensions/mod.rs",
                                                        ),
                                                        ::core::option::Option::Some(52u32),
                                                        ::core::option::Option::Some("app_lib::extensions"),
                                                        ::tracing_core::field::FieldSet::new(
                                                            &["message"],
                                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                        ),
                                                        ::tracing::metadata::Kind::EVENT,
                                                    )
                                                };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                            let enabled = ::tracing::Level::TRACE
                                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                                && ::tracing::Level::TRACE
                                                    <= ::tracing::level_filters::LevelFilter::current()
                                                && {
                                                    let interest = __CALLSITE.interest();
                                                    !interest.is_never()
                                                        && ::tracing::__macro_support::__is_enabled(
                                                            __CALLSITE.metadata(),
                                                            interest,
                                                        )
                                                };
                                            if enabled {
                                                (|value_set: ::tracing::field::ValueSet| {
                                                    let meta = __CALLSITE.metadata();
                                                    ::tracing::Event::dispatch(meta, &value_set);
                                                })({
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &::core::iter::Iterator::next(&mut iter)
                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                    ::core::option::Option::Some(
                                                                        &format_args!("Got extension command request") as &dyn Value,
                                                                    ),
                                                                ),
                                                            ],
                                                        )
                                                });
                                            } else {
                                            }
                                        };
                                        let request_handler = request_handler.clone();
                                        async_runtime::spawn(async move {
                                            {
                                                use ::tracing::__macro_support::Callsite as _;
                                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                                    static META: ::tracing::Metadata<'static> = {
                                                        ::tracing_core::metadata::Metadata::new(
                                                            "event src-tauri/src/extensions/mod.rs:55",
                                                            "app_lib::extensions",
                                                            ::tracing::Level::TRACE,
                                                            ::core::option::Option::Some(
                                                                "src-tauri/src/extensions/mod.rs",
                                                            ),
                                                            ::core::option::Option::Some(55u32),
                                                            ::core::option::Option::Some("app_lib::extensions"),
                                                            ::tracing_core::field::FieldSet::new(
                                                                &["message"],
                                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                            ),
                                                            ::tracing::metadata::Kind::EVENT,
                                                        )
                                                    };
                                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                                };
                                                let enabled = ::tracing::Level::TRACE
                                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                                    && ::tracing::Level::TRACE
                                                        <= ::tracing::level_filters::LevelFilter::current()
                                                    && {
                                                        let interest = __CALLSITE.interest();
                                                        !interest.is_never()
                                                            && ::tracing::__macro_support::__is_enabled(
                                                                __CALLSITE.metadata(),
                                                                interest,
                                                            )
                                                    };
                                                if enabled {
                                                    (|value_set: ::tracing::field::ValueSet| {
                                                        let meta = __CALLSITE.metadata();
                                                        ::tracing::Event::dispatch(meta, &value_set);
                                                    })({
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                        __CALLSITE
                                                            .metadata()
                                                            .fields()
                                                            .value_set(
                                                                &[
                                                                    (
                                                                        &::core::iter::Iterator::next(&mut iter)
                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                        ::core::option::Option::Some(
                                                                            &format_args!("Got extension command {0:?}", message)
                                                                                as &dyn Value,
                                                                        ),
                                                                    ),
                                                                ],
                                                            )
                                                    });
                                                } else {
                                                }
                                            };
                                            let data = request_handler.handle_request(&message).await;
                                            match data {
                                                Ok(data) => {
                                                    tx_reply.send(data).await.unwrap();
                                                }
                                                Err(e) => {
                                                    {
                                                        use ::tracing::__macro_support::Callsite as _;
                                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                                            static META: ::tracing::Metadata<'static> = {
                                                                ::tracing_core::metadata::Metadata::new(
                                                                    "event src-tauri/src/extensions/mod.rs:62",
                                                                    "app_lib::extensions",
                                                                    ::tracing::Level::ERROR,
                                                                    ::core::option::Option::Some(
                                                                        "src-tauri/src/extensions/mod.rs",
                                                                    ),
                                                                    ::core::option::Option::Some(62u32),
                                                                    ::core::option::Option::Some("app_lib::extensions"),
                                                                    ::tracing_core::field::FieldSet::new(
                                                                        &["message"],
                                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                                    ),
                                                                    ::tracing::metadata::Kind::EVENT,
                                                                )
                                                            };
                                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                                        };
                                                        let enabled = ::tracing::Level::ERROR
                                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                                            && ::tracing::Level::ERROR
                                                                <= ::tracing::level_filters::LevelFilter::current()
                                                            && {
                                                                let interest = __CALLSITE.interest();
                                                                !interest.is_never()
                                                                    && ::tracing::__macro_support::__is_enabled(
                                                                        __CALLSITE.metadata(),
                                                                        interest,
                                                                    )
                                                            };
                                                        if enabled {
                                                            (|value_set: ::tracing::field::ValueSet| {
                                                                let meta = __CALLSITE.metadata();
                                                                ::tracing::Event::dispatch(meta, &value_set);
                                                            })({
                                                                #[allow(unused_imports)]
                                                                use ::tracing::field::{debug, display, Value};
                                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                                __CALLSITE
                                                                    .metadata()
                                                                    .fields()
                                                                    .value_set(
                                                                        &[
                                                                            (
                                                                                &::core::iter::Iterator::next(&mut iter)
                                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                                ::core::option::Option::Some(
                                                                                    &format_args!(
                                                                                        "Failed to handle extension request: {0:?}",
                                                                                        e,
                                                                                    ) as &dyn Value,
                                                                                ),
                                                                            ),
                                                                        ],
                                                                    )
                                                            });
                                                        } else {
                                                        }
                                                    };
                                                    tx_reply.send(::alloc::vec::Vec::new()).await.unwrap();
                                                }
                                            }
                                        });
                                    }
                                });
                                extension_runner_connected(app_handle_1).await;
                            }
                        }
                    });
                    Ok(ext_handler)
                }
            }
        }
    }
    #[tracing::instrument(level = "trace", skip(app))]
    pub fn get_extension_handler(app: &AppHandle) -> State<'_, ExtensionHandler> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "get_extension_handler",
                                "app_lib::extensions",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/extensions/mod.rs",
                                ),
                                ::core::option::Option::Some(77u32),
                                ::core::option::Option::Some("app_lib::extensions"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: State<'_, ExtensionHandler> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    let ext_state = app.state();
                    ext_state
                }
            }
        }
    }
    #[allow(unreachable_code, clippy::diverging_sub_expression)]
    const _: () = if false {
        trait AsyncCommandMustReturnResult {}
        impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
        let _check: types::errors::Result<Vec<FetchedExtensionManifest>> = ::core::panicking::panic(
            "internal error: entered unreachable code",
        );
        let _: &dyn AsyncCommandMustReturnResult = &_check;
    };
    #[tracing::instrument(level = "trace", skip(db, cache))]
    pub async fn get_extension_manifest(
        db: State<'_, ExtensionHandler>,
        cache: State<'_, CacheHolder>,
    ) -> types::errors::Result<Vec<FetchedExtensionManifest>> {
        {}
        let __tracing_attr_span = {
            use ::tracing::__macro_support::Callsite as _;
            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "get_extension_manifest",
                        "app_lib::extensions",
                        tracing::Level::TRACE,
                        ::core::option::Option::Some("src-tauri/src/extensions/mod.rs"),
                        ::core::option::Option::Some(83u32),
                        ::core::option::Option::Some("app_lib::extensions"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = __CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    __CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = __CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    __CALLSITE.metadata(),
                );
                {};
                span
            }
        };
        let __tracing_instrument_future = async move {
            #[allow(
                unknown_lints,
                unreachable_code,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::unreachable,
                clippy::let_with_type_underscore,
                clippy::empty_loop
            )]
            if false {
                let __tracing_attr_fake_return: types::errors::Result<
                    Vec<FetchedExtensionManifest>,
                > = loop {};
                return __tracing_attr_fake_return;
            }
            {
                let mut cache_string = String::new();
                cache_string.push_str("get_extension_manifest");
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event src-tauri/src/extensions/mod.rs:83",
                                "app_lib::extensions",
                                ::tracing::Level::INFO,
                                ::core::option::Option::Some(
                                    "src-tauri/src/extensions/mod.rs",
                                ),
                                ::core::option::Option::Some(83u32),
                                ::core::option::Option::Some("app_lib::extensions"),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::INFO
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &format_args!(
                                                    "calling cached async {0}: {1}",
                                                    "get_extension_manifest",
                                                    cache_string,
                                                ) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let res = db.get_extension_manifest().await;
                match &res {
                    Ok(res) => {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/extensions/mod.rs:83",
                                        "app_lib::extensions",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/mod.rs",
                                        ),
                                        ::core::option::Option::Some(83u32),
                                        ::core::option::Option::Some("app_lib::extensions"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", res) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        let cache_res = cache.set(cache_string.as_str(), res, 7200);
                        if let Ok(cache_res) = cache_res {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/extensions/mod.rs:83",
                                            "app_lib::extensions",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/extensions/mod.rs",
                                            ),
                                            ::core::option::Option::Some(83u32),
                                            ::core::option::Option::Some("app_lib::extensions"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Updated result in cache") as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        } else {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/extensions/mod.rs:83",
                                            "app_lib::extensions",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/extensions/mod.rs",
                                            ),
                                            ::core::option::Option::Some(83u32),
                                            ::core::option::Option::Some("app_lib::extensions"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!(
                                                                "Error updating cache {0:?}",
                                                                cache_res.unwrap_err(),
                                                            ) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                    }
                    Err(e) => {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/extensions/mod.rs:83",
                                        "app_lib::extensions",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/mod.rs",
                                        ),
                                        ::core::option::Option::Some(83u32),
                                        ::core::option::Option::Some("app_lib::extensions"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", e) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                }
                res
            }
        };
        if !__tracing_attr_span.is_disabled() {
            tracing::Instrument::instrument(
                    __tracing_instrument_future,
                    __tracing_attr_span,
                )
                .await
        } else {
            __tracing_instrument_future.await
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__get_extension_manifest;
    #[allow(unreachable_code, clippy::diverging_sub_expression)]
    const _: () = if false {
        trait AsyncCommandMustReturnResult {}
        impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
        let _check: types::errors::Result<()> = ::core::panicking::panic(
            "internal error: entered unreachable code",
        );
        let _: &dyn AsyncCommandMustReturnResult = &_check;
    };
    #[tracing::instrument(level = "trace", skip(db, ext_path))]
    pub async fn install_extension(
        db: State<'_, ExtensionHandler>,
        ext_path: String,
    ) -> types::errors::Result<()> {
        {}
        let __tracing_attr_span = {
            use ::tracing::__macro_support::Callsite as _;
            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "install_extension",
                        "app_lib::extensions",
                        tracing::Level::TRACE,
                        ::core::option::Option::Some("src-tauri/src/extensions/mod.rs"),
                        ::core::option::Option::Some(88u32),
                        ::core::option::Option::Some("app_lib::extensions"),
                        ::tracing_core::field::FieldSet::new(
                            &["ext_path"],
                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = __CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    __CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = __CALLSITE.metadata();
                ::tracing::Span::new(
                    meta,
                    &{
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = meta.fields().iter();
                        meta.fields()
                            .value_set(
                                &[
                                    (
                                        &::core::iter::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::core::option::Option::Some(
                                            &tracing::field::debug(&ext_path) as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    },
                )
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    __CALLSITE.metadata(),
                );
                {};
                span
            }
        };
        let __tracing_instrument_future = async move {
            #[allow(
                unknown_lints,
                unreachable_code,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::unreachable,
                clippy::let_with_type_underscore,
                clippy::empty_loop
            )]
            if false {
                let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                return __tracing_attr_fake_return;
            }
            {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event src-tauri/src/extensions/mod.rs:88",
                                "app_lib::extensions",
                                ::tracing::Level::INFO,
                                ::core::option::Option::Some(
                                    "src-tauri/src/extensions/mod.rs",
                                ),
                                ::core::option::Option::Some(88u32),
                                ::core::option::Option::Some("app_lib::extensions"),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::INFO
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &format_args!("calling async {0}", "install_extension")
                                                    as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let ret = db.install_extension(ext_path).await;
                if let Ok(ret) = &ret {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/extensions/mod.rs:88",
                                    "app_lib::extensions",
                                    ::tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/extensions/mod.rs",
                                    ),
                                    ::core::option::Option::Some(88u32),
                                    ::core::option::Option::Some("app_lib::extensions"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/extensions/mod.rs:88",
                                    "app_lib::extensions",
                                    ::tracing::Level::ERROR,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/extensions/mod.rs",
                                    ),
                                    ::core::option::Option::Some(88u32),
                                    ::core::option::Option::Some("app_lib::extensions"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::ERROR
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::ERROR
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Error getting result {0:?}", ret)
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                }
                ret
            }
        };
        if !__tracing_attr_span.is_disabled() {
            tracing::Instrument::instrument(
                    __tracing_instrument_future,
                    __tracing_attr_span,
                )
                .await
        } else {
            __tracing_instrument_future.await
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__install_extension;
    #[allow(unreachable_code, clippy::diverging_sub_expression)]
    const _: () = if false {
        trait AsyncCommandMustReturnResult {}
        impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
        let _check: types::errors::Result<()> = ::core::panicking::panic(
            "internal error: entered unreachable code",
        );
        let _: &dyn AsyncCommandMustReturnResult = &_check;
    };
    #[tracing::instrument(level = "trace", skip(db, ext_path))]
    pub async fn remove_extension(
        db: State<'_, ExtensionHandler>,
        ext_path: String,
    ) -> types::errors::Result<()> {
        {}
        let __tracing_attr_span = {
            use ::tracing::__macro_support::Callsite as _;
            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "remove_extension",
                        "app_lib::extensions",
                        tracing::Level::TRACE,
                        ::core::option::Option::Some("src-tauri/src/extensions/mod.rs"),
                        ::core::option::Option::Some(89u32),
                        ::core::option::Option::Some("app_lib::extensions"),
                        ::tracing_core::field::FieldSet::new(
                            &["ext_path"],
                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = __CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    __CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = __CALLSITE.metadata();
                ::tracing::Span::new(
                    meta,
                    &{
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = meta.fields().iter();
                        meta.fields()
                            .value_set(
                                &[
                                    (
                                        &::core::iter::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::core::option::Option::Some(
                                            &tracing::field::debug(&ext_path) as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    },
                )
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    __CALLSITE.metadata(),
                );
                {};
                span
            }
        };
        let __tracing_instrument_future = async move {
            #[allow(
                unknown_lints,
                unreachable_code,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::unreachable,
                clippy::let_with_type_underscore,
                clippy::empty_loop
            )]
            if false {
                let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                return __tracing_attr_fake_return;
            }
            {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event src-tauri/src/extensions/mod.rs:89",
                                "app_lib::extensions",
                                ::tracing::Level::INFO,
                                ::core::option::Option::Some(
                                    "src-tauri/src/extensions/mod.rs",
                                ),
                                ::core::option::Option::Some(89u32),
                                ::core::option::Option::Some("app_lib::extensions"),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::INFO
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &format_args!("calling async {0}", "remove_extension")
                                                    as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let ret = db.remove_extension(ext_path).await;
                if let Ok(ret) = &ret {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/extensions/mod.rs:89",
                                    "app_lib::extensions",
                                    ::tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/extensions/mod.rs",
                                    ),
                                    ::core::option::Option::Some(89u32),
                                    ::core::option::Option::Some("app_lib::extensions"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/extensions/mod.rs:89",
                                    "app_lib::extensions",
                                    ::tracing::Level::ERROR,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/extensions/mod.rs",
                                    ),
                                    ::core::option::Option::Some(89u32),
                                    ::core::option::Option::Some("app_lib::extensions"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::ERROR
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::ERROR
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Error getting result {0:?}", ret)
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                }
                ret
            }
        };
        if !__tracing_attr_span.is_disabled() {
            tracing::Instrument::instrument(
                    __tracing_instrument_future,
                    __tracing_attr_span,
                )
                .await
        } else {
            __tracing_instrument_future.await
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__remove_extension;
    #[allow(unreachable_code, clippy::diverging_sub_expression)]
    const _: () = if false {
        trait AsyncCommandMustReturnResult {}
        impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
        let _check: types::errors::Result<()> = ::core::panicking::panic(
            "internal error: entered unreachable code",
        );
        let _: &dyn AsyncCommandMustReturnResult = &_check;
    };
    #[tracing::instrument(level = "trace", skip(db, fetched_ext))]
    pub async fn download_extension(
        db: State<'_, ExtensionHandler>,
        fetched_ext: FetchedExtensionManifest,
    ) -> types::errors::Result<()> {
        {}
        let __tracing_attr_span = {
            use ::tracing::__macro_support::Callsite as _;
            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "download_extension",
                        "app_lib::extensions",
                        tracing::Level::TRACE,
                        ::core::option::Option::Some("src-tauri/src/extensions/mod.rs"),
                        ::core::option::Option::Some(90u32),
                        ::core::option::Option::Some("app_lib::extensions"),
                        ::tracing_core::field::FieldSet::new(
                            &["fetched_ext"],
                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = __CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    __CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = __CALLSITE.metadata();
                ::tracing::Span::new(
                    meta,
                    &{
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = meta.fields().iter();
                        meta.fields()
                            .value_set(
                                &[
                                    (
                                        &::core::iter::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::core::option::Option::Some(
                                            &tracing::field::debug(&fetched_ext) as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    },
                )
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    __CALLSITE.metadata(),
                );
                {};
                span
            }
        };
        let __tracing_instrument_future = async move {
            #[allow(
                unknown_lints,
                unreachable_code,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::unreachable,
                clippy::let_with_type_underscore,
                clippy::empty_loop
            )]
            if false {
                let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                return __tracing_attr_fake_return;
            }
            {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event src-tauri/src/extensions/mod.rs:90",
                                "app_lib::extensions",
                                ::tracing::Level::INFO,
                                ::core::option::Option::Some(
                                    "src-tauri/src/extensions/mod.rs",
                                ),
                                ::core::option::Option::Some(90u32),
                                ::core::option::Option::Some("app_lib::extensions"),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::INFO
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &format_args!("calling async {0}", "download_extension")
                                                    as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let ret = db.download_extension(fetched_ext).await;
                if let Ok(ret) = &ret {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/extensions/mod.rs:90",
                                    "app_lib::extensions",
                                    ::tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/extensions/mod.rs",
                                    ),
                                    ::core::option::Option::Some(90u32),
                                    ::core::option::Option::Some("app_lib::extensions"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/extensions/mod.rs:90",
                                    "app_lib::extensions",
                                    ::tracing::Level::ERROR,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/extensions/mod.rs",
                                    ),
                                    ::core::option::Option::Some(90u32),
                                    ::core::option::Option::Some("app_lib::extensions"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::ERROR
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::ERROR
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Error getting result {0:?}", ret)
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                }
                ret
            }
        };
        if !__tracing_attr_span.is_disabled() {
            tracing::Instrument::instrument(
                    __tracing_instrument_future,
                    __tracing_attr_span,
                )
                .await
        } else {
            __tracing_instrument_future.await
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__download_extension;
    #[allow(unreachable_code, clippy::diverging_sub_expression)]
    const _: () = if false {
        trait AsyncCommandMustReturnResult {}
        impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
        let _check: types::errors::Result<HashMap<String, Vec<ExtensionDetail>>> = ::core::panicking::panic(
            "internal error: entered unreachable code",
        );
        let _: &dyn AsyncCommandMustReturnResult = &_check;
    };
    #[tracing::instrument(level = "trace", skip(db))]
    pub async fn get_installed_extensions(
        db: State<'_, ExtensionHandler>,
    ) -> types::errors::Result<HashMap<String, Vec<ExtensionDetail>>> {
        {}
        let __tracing_attr_span = {
            use ::tracing::__macro_support::Callsite as _;
            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "get_installed_extensions",
                        "app_lib::extensions",
                        tracing::Level::TRACE,
                        ::core::option::Option::Some("src-tauri/src/extensions/mod.rs"),
                        ::core::option::Option::Some(91u32),
                        ::core::option::Option::Some("app_lib::extensions"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = __CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    __CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = __CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    __CALLSITE.metadata(),
                );
                {};
                span
            }
        };
        let __tracing_instrument_future = async move {
            #[allow(
                unknown_lints,
                unreachable_code,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::unreachable,
                clippy::let_with_type_underscore,
                clippy::empty_loop
            )]
            if false {
                let __tracing_attr_fake_return: types::errors::Result<
                    HashMap<String, Vec<ExtensionDetail>>,
                > = loop {};
                return __tracing_attr_fake_return;
            }
            {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event src-tauri/src/extensions/mod.rs:91",
                                "app_lib::extensions",
                                ::tracing::Level::INFO,
                                ::core::option::Option::Some(
                                    "src-tauri/src/extensions/mod.rs",
                                ),
                                ::core::option::Option::Some(91u32),
                                ::core::option::Option::Some("app_lib::extensions"),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::INFO
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &format_args!(
                                                    "calling async {0}",
                                                    "get_installed_extensions",
                                                ) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let ret = db.get_installed_extensions().await;
                if let Ok(ret) = &ret {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/extensions/mod.rs:91",
                                    "app_lib::extensions",
                                    ::tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/extensions/mod.rs",
                                    ),
                                    ::core::option::Option::Some(91u32),
                                    ::core::option::Option::Some("app_lib::extensions"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/extensions/mod.rs:91",
                                    "app_lib::extensions",
                                    ::tracing::Level::ERROR,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/extensions/mod.rs",
                                    ),
                                    ::core::option::Option::Some(91u32),
                                    ::core::option::Option::Some("app_lib::extensions"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::ERROR
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::ERROR
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Error getting result {0:?}", ret)
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                }
                ret
            }
        };
        if !__tracing_attr_span.is_disabled() {
            tracing::Instrument::instrument(
                    __tracing_instrument_future,
                    __tracing_attr_span,
                )
                .await
        } else {
            __tracing_instrument_future.await
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__get_installed_extensions;
    #[allow(unreachable_code, clippy::diverging_sub_expression)]
    const _: () = if false {
        trait AsyncCommandMustReturnResult {}
        impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
        let _check: types::errors::Result<Value> = ::core::panicking::panic(
            "internal error: entered unreachable code",
        );
        let _: &dyn AsyncCommandMustReturnResult = &_check;
    };
    #[tracing::instrument(level = "trace", skip(db, args))]
    pub async fn send_extra_event(
        db: State<'_, ExtensionHandler>,
        args: ExtensionExtraEventArgs,
    ) -> types::errors::Result<Value> {
        {}
        let __tracing_attr_span = {
            use ::tracing::__macro_support::Callsite as _;
            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "send_extra_event",
                        "app_lib::extensions",
                        tracing::Level::TRACE,
                        ::core::option::Option::Some("src-tauri/src/extensions/mod.rs"),
                        ::core::option::Option::Some(92u32),
                        ::core::option::Option::Some("app_lib::extensions"),
                        ::tracing_core::field::FieldSet::new(
                            &["args"],
                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = __CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    __CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = __CALLSITE.metadata();
                ::tracing::Span::new(
                    meta,
                    &{
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = meta.fields().iter();
                        meta.fields()
                            .value_set(
                                &[
                                    (
                                        &::core::iter::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::core::option::Option::Some(
                                            &tracing::field::debug(&args) as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    },
                )
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    __CALLSITE.metadata(),
                );
                {};
                span
            }
        };
        let __tracing_instrument_future = async move {
            #[allow(
                unknown_lints,
                unreachable_code,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::unreachable,
                clippy::let_with_type_underscore,
                clippy::empty_loop
            )]
            if false {
                let __tracing_attr_fake_return: types::errors::Result<Value> = loop {};
                return __tracing_attr_fake_return;
            }
            {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event src-tauri/src/extensions/mod.rs:92",
                                "app_lib::extensions",
                                ::tracing::Level::INFO,
                                ::core::option::Option::Some(
                                    "src-tauri/src/extensions/mod.rs",
                                ),
                                ::core::option::Option::Some(92u32),
                                ::core::option::Option::Some("app_lib::extensions"),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::INFO
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &format_args!("calling async {0}", "send_extra_event")
                                                    as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let ret = db.send_extra_event(args).await;
                if let Ok(ret) = &ret {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/extensions/mod.rs:92",
                                    "app_lib::extensions",
                                    ::tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/extensions/mod.rs",
                                    ),
                                    ::core::option::Option::Some(92u32),
                                    ::core::option::Option::Some("app_lib::extensions"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/extensions/mod.rs:92",
                                    "app_lib::extensions",
                                    ::tracing::Level::ERROR,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/extensions/mod.rs",
                                    ),
                                    ::core::option::Option::Some(92u32),
                                    ::core::option::Option::Some("app_lib::extensions"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::ERROR
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::ERROR
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Error getting result {0:?}", ret)
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                }
                ret
            }
        };
        if !__tracing_attr_span.is_disabled() {
            tracing::Instrument::instrument(
                    __tracing_instrument_future,
                    __tracing_attr_span,
                )
                .await
        } else {
            __tracing_instrument_future.await
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__send_extra_event;
    #[allow(unreachable_code, clippy::diverging_sub_expression)]
    const _: () = if false {
        trait AsyncCommandMustReturnResult {}
        impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
        let _check: types::errors::Result<String> = ::core::panicking::panic(
            "internal error: entered unreachable code",
        );
        let _: &dyn AsyncCommandMustReturnResult = &_check;
    };
    #[tracing::instrument(level = "trace", skip(db, cache, args))]
    pub async fn get_extension_icon(
        db: State<'_, ExtensionHandler>,
        cache: State<'_, CacheHolder>,
        args: PackageNameArgs,
    ) -> types::errors::Result<String> {
        {}
        let __tracing_attr_span = {
            use ::tracing::__macro_support::Callsite as _;
            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "get_extension_icon",
                        "app_lib::extensions",
                        tracing::Level::TRACE,
                        ::core::option::Option::Some("src-tauri/src/extensions/mod.rs"),
                        ::core::option::Option::Some(98u32),
                        ::core::option::Option::Some("app_lib::extensions"),
                        ::tracing_core::field::FieldSet::new(
                            &["args"],
                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = __CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    __CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = __CALLSITE.metadata();
                ::tracing::Span::new(
                    meta,
                    &{
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = meta.fields().iter();
                        meta.fields()
                            .value_set(
                                &[
                                    (
                                        &::core::iter::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::core::option::Option::Some(
                                            &tracing::field::debug(&args) as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    },
                )
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    __CALLSITE.metadata(),
                );
                {};
                span
            }
        };
        let __tracing_instrument_future = async move {
            #[allow(
                unknown_lints,
                unreachable_code,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::unreachable,
                clippy::let_with_type_underscore,
                clippy::empty_loop
            )]
            if false {
                let __tracing_attr_fake_return: types::errors::Result<String> = loop {};
                return __tracing_attr_fake_return;
            }
            {
                let mut cache_string = String::new();
                cache_string.push_str("get_extension_icon");
                {
                    cache_string
                        .push_str(
                            ::alloc::__export::must_use({
                                    let res = ::alloc::fmt::format(
                                        format_args!("_{0:?}", args),
                                    );
                                    res
                                })
                                .as_str(),
                        );
                }
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event src-tauri/src/extensions/mod.rs:98",
                                "app_lib::extensions",
                                ::tracing::Level::INFO,
                                ::core::option::Option::Some(
                                    "src-tauri/src/extensions/mod.rs",
                                ),
                                ::core::option::Option::Some(98u32),
                                ::core::option::Option::Some("app_lib::extensions"),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::INFO
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &format_args!(
                                                    "calling cached async {0}: {1}",
                                                    "get_extension_icon",
                                                    cache_string,
                                                ) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let res = db.get_extension_icon(args).await;
                match &res {
                    Ok(res) => {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/extensions/mod.rs:98",
                                        "app_lib::extensions",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/mod.rs",
                                        ),
                                        ::core::option::Option::Some(98u32),
                                        ::core::option::Option::Some("app_lib::extensions"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", res) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        let cache_res = cache.set(cache_string.as_str(), res, 7200);
                        if let Ok(cache_res) = cache_res {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/extensions/mod.rs:98",
                                            "app_lib::extensions",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/extensions/mod.rs",
                                            ),
                                            ::core::option::Option::Some(98u32),
                                            ::core::option::Option::Some("app_lib::extensions"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Updated result in cache") as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        } else {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/extensions/mod.rs:98",
                                            "app_lib::extensions",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/extensions/mod.rs",
                                            ),
                                            ::core::option::Option::Some(98u32),
                                            ::core::option::Option::Some("app_lib::extensions"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!(
                                                                "Error updating cache {0:?}",
                                                                cache_res.unwrap_err(),
                                                            ) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                    }
                    Err(e) => {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/extensions/mod.rs:98",
                                        "app_lib::extensions",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/extensions/mod.rs",
                                        ),
                                        ::core::option::Option::Some(98u32),
                                        ::core::option::Option::Some("app_lib::extensions"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", e) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                }
                res
            }
        };
        if !__tracing_attr_span.is_disabled() {
            tracing::Instrument::instrument(
                    __tracing_instrument_future,
                    __tracing_attr_span,
                )
                .await
        } else {
            __tracing_instrument_future.await
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__get_extension_icon;
}
mod librespot {
    use database::cache::CacheHolder;
    use librespot::{
        spirc::ParsedToken, utils::event_to_map, Bitrate, Cache, ConnectConfig,
        Credentials, DeviceType, LibrespotHolder, PlayerConfig, REGISTERED_EVENTS,
    };
    use macros::{generate_command, generate_command_cached};
    use preferences::preferences::PreferenceConfig;
    use tauri::{AppHandle, Emitter, Manager, State, Window};
    use types::{canvaz::CanvazResponse, errors::Result};
    #[tracing::instrument(level = "trace", skip())]
    pub fn get_librespot_state() -> LibrespotHolder {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "get_librespot_state",
                                "app_lib::librespot",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/librespot/mod.rs",
                                ),
                                ::core::option::Option::Some(12u32),
                                ::core::option::Option::Some("app_lib::librespot"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: LibrespotHolder = loop {};
                    return __tracing_attr_fake_return;
                }
                { LibrespotHolder::new() }
            }
        }
    }
    #[tracing::instrument(level = "trace", skip(app, window, librespot))]
    pub fn initialize_librespot(
        app: AppHandle,
        window: Window,
        librespot: State<LibrespotHolder>,
    ) -> Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "initialize_librespot",
                                "app_lib::librespot",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/librespot/mod.rs",
                                ),
                                ::core::option::Option::Some(17u32),
                                ::core::option::Option::Some("app_lib::librespot"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    let prefs: State<PreferenceConfig> = app.state();
                    let username: String = prefs
                        .load_selective("spotify.username".into())?;
                    let password: String = prefs
                        .load_selective("spotify.password".into())?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/librespot/mod.rs:28",
                                    "app_lib::librespot",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/librespot/mod.rs",
                                    ),
                                    ::core::option::Option::Some(28u32),
                                    ::core::option::Option::Some("app_lib::librespot"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!(
                                                        "Initializing librespot {0}@{1}",
                                                        username.trim(),
                                                        password.trim(),
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let credentials = Credentials::with_password(username, password);
                    let player_config = PlayerConfig {
                        bitrate: Bitrate::Bitrate320,
                        ..Default::default()
                    };
                    let connect_config = ConnectConfig {
                        name: "Moosync".into(),
                        device_type: DeviceType::Computer,
                        initial_volume: Some(0),
                        has_volume_ctrl: true,
                        is_group: false,
                    };
                    let credentials_path = app.path().app_config_dir()?;
                    let audio_path = app.path().app_cache_dir()?;
                    let cache_config = Cache::new(
                        Some(credentials_path.clone()),
                        Some(credentials_path),
                        Some(audio_path),
                        None,
                    )?;
                    librespot
                        .initialize(
                            credentials,
                            player_config,
                            connect_config,
                            cache_config,
                            "".to_string(),
                            "".to_string(),
                        )?;
                    let events_channel = librespot.get_events_channel()?;
                    tauri::async_runtime::spawn(async move {
                        let events_channel = events_channel.lock().unwrap();
                        loop {
                            let event = events_channel.recv();
                            match event {
                                Ok(event) => {
                                    let parsed_event = event_to_map(event.clone());
                                    let registered_events = REGISTERED_EVENTS.lock().unwrap();
                                    if registered_events
                                        .contains(
                                            &::alloc::__export::must_use({
                                                let res = ::alloc::fmt::format(
                                                    format_args!(
                                                        "librespot_event_{0}",
                                                        parsed_event.get("event").unwrap(),
                                                    ),
                                                );
                                                res
                                            }),
                                        )
                                    {
                                        window
                                            .emit(
                                                ::alloc::__export::must_use({
                                                        let res = ::alloc::fmt::format(
                                                            format_args!(
                                                                "librespot_event_{0}",
                                                                parsed_event.get("event").unwrap(),
                                                            ),
                                                        );
                                                        res
                                                    })
                                                    .as_str(),
                                                parsed_event,
                                            )
                                            .unwrap();
                                    }
                                }
                                Err(e) => {
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "event src-tauri/src/librespot/mod.rs:92",
                                                    "app_lib::librespot",
                                                    ::tracing::Level::ERROR,
                                                    ::core::option::Option::Some(
                                                        "src-tauri/src/librespot/mod.rs",
                                                    ),
                                                    ::core::option::Option::Some(92u32),
                                                    ::core::option::Option::Some("app_lib::librespot"),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["message"],
                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::EVENT,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let enabled = ::tracing::Level::ERROR
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::tracing::Level::ERROR
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                let interest = __CALLSITE.interest();
                                                !interest.is_never()
                                                    && ::tracing::__macro_support::__is_enabled(
                                                        __CALLSITE.metadata(),
                                                        interest,
                                                    )
                                            };
                                        if enabled {
                                            (|value_set: ::tracing::field::ValueSet| {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                            })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::core::iter::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::core::option::Option::Some(
                                                                    &format_args!("Ending event loop {0:?}", e) as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            });
                                        } else {
                                        }
                                    };
                                    break;
                                }
                            }
                        }
                    });
                    Ok(())
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__initialize_librespot;
    #[tracing::instrument(level = "trace", skip(db))]
    pub fn librespot_play(db: State<LibrespotHolder>) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "librespot_play",
                                "app_lib::librespot",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/librespot/mod.rs",
                                ),
                                ::core::option::Option::Some(102u32),
                                ::core::option::Option::Some("app_lib::librespot"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/librespot/mod.rs:102",
                                    "app_lib::librespot",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/librespot/mod.rs",
                                    ),
                                    ::core::option::Option::Some(102u32),
                                    ::core::option::Option::Some("app_lib::librespot"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "librespot_play") as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.librespot_play();
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/librespot/mod.rs:102",
                                        "app_lib::librespot",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/librespot/mod.rs",
                                        ),
                                        ::core::option::Option::Some(102u32),
                                        ::core::option::Option::Some("app_lib::librespot"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/librespot/mod.rs:102",
                                        "app_lib::librespot",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/librespot/mod.rs",
                                        ),
                                        ::core::option::Option::Some(102u32),
                                        ::core::option::Option::Some("app_lib::librespot"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__librespot_play;
    #[tracing::instrument(level = "trace", skip(db))]
    pub fn librespot_pause(db: State<LibrespotHolder>) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "librespot_pause",
                                "app_lib::librespot",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/librespot/mod.rs",
                                ),
                                ::core::option::Option::Some(103u32),
                                ::core::option::Option::Some("app_lib::librespot"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/librespot/mod.rs:103",
                                    "app_lib::librespot",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/librespot/mod.rs",
                                    ),
                                    ::core::option::Option::Some(103u32),
                                    ::core::option::Option::Some("app_lib::librespot"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "librespot_pause")
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.librespot_pause();
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/librespot/mod.rs:103",
                                        "app_lib::librespot",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/librespot/mod.rs",
                                        ),
                                        ::core::option::Option::Some(103u32),
                                        ::core::option::Option::Some("app_lib::librespot"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/librespot/mod.rs:103",
                                        "app_lib::librespot",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/librespot/mod.rs",
                                        ),
                                        ::core::option::Option::Some(103u32),
                                        ::core::option::Option::Some("app_lib::librespot"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__librespot_pause;
    #[tracing::instrument(level = "trace", skip(db))]
    pub fn librespot_close(db: State<LibrespotHolder>) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "librespot_close",
                                "app_lib::librespot",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/librespot/mod.rs",
                                ),
                                ::core::option::Option::Some(104u32),
                                ::core::option::Option::Some("app_lib::librespot"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/librespot/mod.rs:104",
                                    "app_lib::librespot",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/librespot/mod.rs",
                                    ),
                                    ::core::option::Option::Some(104u32),
                                    ::core::option::Option::Some("app_lib::librespot"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "librespot_close")
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.librespot_close();
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/librespot/mod.rs:104",
                                        "app_lib::librespot",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/librespot/mod.rs",
                                        ),
                                        ::core::option::Option::Some(104u32),
                                        ::core::option::Option::Some("app_lib::librespot"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/librespot/mod.rs:104",
                                        "app_lib::librespot",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/librespot/mod.rs",
                                        ),
                                        ::core::option::Option::Some(104u32),
                                        ::core::option::Option::Some("app_lib::librespot"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__librespot_close;
    #[tracing::instrument(level = "trace", skip(db, uri, autoplay))]
    pub fn librespot_load(
        db: State<LibrespotHolder>,
        uri: String,
        autoplay: bool,
    ) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "librespot_load",
                                "app_lib::librespot",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/librespot/mod.rs",
                                ),
                                ::core::option::Option::Some(105u32),
                                ::core::option::Option::Some("app_lib::librespot"),
                                ::tracing_core::field::FieldSet::new(
                                    &["uri", "autoplay"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&uri) as &dyn Value,
                                                ),
                                            ),
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&autoplay) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/librespot/mod.rs:105",
                                    "app_lib::librespot",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/librespot/mod.rs",
                                    ),
                                    ::core::option::Option::Some(105u32),
                                    ::core::option::Option::Some("app_lib::librespot"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "librespot_load") as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.librespot_load(uri, autoplay);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/librespot/mod.rs:105",
                                        "app_lib::librespot",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/librespot/mod.rs",
                                        ),
                                        ::core::option::Option::Some(105u32),
                                        ::core::option::Option::Some("app_lib::librespot"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/librespot/mod.rs:105",
                                        "app_lib::librespot",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/librespot/mod.rs",
                                        ),
                                        ::core::option::Option::Some(105u32),
                                        ::core::option::Option::Some("app_lib::librespot"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__librespot_load;
    #[tracing::instrument(level = "trace", skip(db, pos))]
    pub fn librespot_seek(
        db: State<LibrespotHolder>,
        pos: u32,
    ) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "librespot_seek",
                                "app_lib::librespot",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/librespot/mod.rs",
                                ),
                                ::core::option::Option::Some(106u32),
                                ::core::option::Option::Some("app_lib::librespot"),
                                ::tracing_core::field::FieldSet::new(
                                    &["pos"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&pos) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/librespot/mod.rs:106",
                                    "app_lib::librespot",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/librespot/mod.rs",
                                    ),
                                    ::core::option::Option::Some(106u32),
                                    ::core::option::Option::Some("app_lib::librespot"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "librespot_seek") as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.librespot_seek(pos);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/librespot/mod.rs:106",
                                        "app_lib::librespot",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/librespot/mod.rs",
                                        ),
                                        ::core::option::Option::Some(106u32),
                                        ::core::option::Option::Some("app_lib::librespot"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/librespot/mod.rs:106",
                                        "app_lib::librespot",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/librespot/mod.rs",
                                        ),
                                        ::core::option::Option::Some(106u32),
                                        ::core::option::Option::Some("app_lib::librespot"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__librespot_seek;
    #[tracing::instrument(level = "trace", skip(db, volume))]
    pub fn librespot_volume(
        db: State<LibrespotHolder>,
        volume: u16,
    ) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "librespot_volume",
                                "app_lib::librespot",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/librespot/mod.rs",
                                ),
                                ::core::option::Option::Some(107u32),
                                ::core::option::Option::Some("app_lib::librespot"),
                                ::tracing_core::field::FieldSet::new(
                                    &["volume"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&volume) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/librespot/mod.rs:107",
                                    "app_lib::librespot",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/librespot/mod.rs",
                                    ),
                                    ::core::option::Option::Some(107u32),
                                    ::core::option::Option::Some("app_lib::librespot"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "librespot_volume")
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.librespot_volume(volume);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/librespot/mod.rs:107",
                                        "app_lib::librespot",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/librespot/mod.rs",
                                        ),
                                        ::core::option::Option::Some(107u32),
                                        ::core::option::Option::Some("app_lib::librespot"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/librespot/mod.rs:107",
                                        "app_lib::librespot",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/librespot/mod.rs",
                                        ),
                                        ::core::option::Option::Some(107u32),
                                        ::core::option::Option::Some("app_lib::librespot"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__librespot_volume;
    #[tracing::instrument(level = "trace", skip(db, scopes))]
    pub fn librespot_get_token(
        db: State<LibrespotHolder>,
        scopes: String,
    ) -> types::errors::Result<ParsedToken> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "librespot_get_token",
                                "app_lib::librespot",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/librespot/mod.rs",
                                ),
                                ::core::option::Option::Some(108u32),
                                ::core::option::Option::Some("app_lib::librespot"),
                                ::tracing_core::field::FieldSet::new(
                                    &["scopes"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&scopes) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<ParsedToken> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/librespot/mod.rs:108",
                                    "app_lib::librespot",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/librespot/mod.rs",
                                    ),
                                    ::core::option::Option::Some(108u32),
                                    ::core::option::Option::Some("app_lib::librespot"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "librespot_get_token")
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.librespot_get_token(scopes);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/librespot/mod.rs:108",
                                        "app_lib::librespot",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/librespot/mod.rs",
                                        ),
                                        ::core::option::Option::Some(108u32),
                                        ::core::option::Option::Some("app_lib::librespot"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/librespot/mod.rs:108",
                                        "app_lib::librespot",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/librespot/mod.rs",
                                        ),
                                        ::core::option::Option::Some(108u32),
                                        ::core::option::Option::Some("app_lib::librespot"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__librespot_get_token;
    #[tracing::instrument(level = "trace", skip(db, event))]
    pub fn register_event(
        db: State<LibrespotHolder>,
        event: String,
    ) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "register_event",
                                "app_lib::librespot",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/librespot/mod.rs",
                                ),
                                ::core::option::Option::Some(109u32),
                                ::core::option::Option::Some("app_lib::librespot"),
                                ::tracing_core::field::FieldSet::new(
                                    &["event"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&event) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/librespot/mod.rs:109",
                                    "app_lib::librespot",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/librespot/mod.rs",
                                    ),
                                    ::core::option::Option::Some(109u32),
                                    ::core::option::Option::Some("app_lib::librespot"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "register_event") as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.register_event(event);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/librespot/mod.rs:109",
                                        "app_lib::librespot",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/librespot/mod.rs",
                                        ),
                                        ::core::option::Option::Some(109u32),
                                        ::core::option::Option::Some("app_lib::librespot"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/librespot/mod.rs:109",
                                        "app_lib::librespot",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/librespot/mod.rs",
                                        ),
                                        ::core::option::Option::Some(109u32),
                                        ::core::option::Option::Some("app_lib::librespot"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__register_event;
    #[allow(unreachable_code, clippy::diverging_sub_expression)]
    const _: () = if false {
        trait AsyncCommandMustReturnResult {}
        impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
        let _check: types::errors::Result<CanvazResponse> = ::core::panicking::panic(
            "internal error: entered unreachable code",
        );
        let _: &dyn AsyncCommandMustReturnResult = &_check;
    };
    #[tracing::instrument(level = "trace", skip(db, cache, uri))]
    pub async fn get_canvaz(
        db: State<'_, LibrespotHolder>,
        cache: State<'_, CacheHolder>,
        uri: String,
    ) -> types::errors::Result<CanvazResponse> {
        {}
        let __tracing_attr_span = {
            use ::tracing::__macro_support::Callsite as _;
            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "get_canvaz",
                        "app_lib::librespot",
                        tracing::Level::TRACE,
                        ::core::option::Option::Some("src-tauri/src/librespot/mod.rs"),
                        ::core::option::Option::Some(110u32),
                        ::core::option::Option::Some("app_lib::librespot"),
                        ::tracing_core::field::FieldSet::new(
                            &["uri"],
                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = __CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    __CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = __CALLSITE.metadata();
                ::tracing::Span::new(
                    meta,
                    &{
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = meta.fields().iter();
                        meta.fields()
                            .value_set(
                                &[
                                    (
                                        &::core::iter::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::core::option::Option::Some(
                                            &tracing::field::debug(&uri) as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    },
                )
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    __CALLSITE.metadata(),
                );
                {};
                span
            }
        };
        let __tracing_instrument_future = async move {
            #[allow(
                unknown_lints,
                unreachable_code,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::unreachable,
                clippy::let_with_type_underscore,
                clippy::empty_loop
            )]
            if false {
                let __tracing_attr_fake_return: types::errors::Result<CanvazResponse> = loop {};
                return __tracing_attr_fake_return;
            }
            {
                let mut cache_string = String::new();
                cache_string.push_str("get_canvaz");
                {
                    cache_string
                        .push_str(
                            ::alloc::__export::must_use({
                                    let res = ::alloc::fmt::format(format_args!("_{0:?}", uri));
                                    res
                                })
                                .as_str(),
                        );
                }
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event src-tauri/src/librespot/mod.rs:110",
                                "app_lib::librespot",
                                ::tracing::Level::INFO,
                                ::core::option::Option::Some(
                                    "src-tauri/src/librespot/mod.rs",
                                ),
                                ::core::option::Option::Some(110u32),
                                ::core::option::Option::Some("app_lib::librespot"),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::INFO
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &format_args!(
                                                    "calling cached {0}: {1}",
                                                    "get_canvaz",
                                                    cache_string,
                                                ) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let res = db.get_canvaz(uri);
                match &res {
                    Ok(res) => {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/librespot/mod.rs:110",
                                        "app_lib::librespot",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/librespot/mod.rs",
                                        ),
                                        ::core::option::Option::Some(110u32),
                                        ::core::option::Option::Some("app_lib::librespot"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", res) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        let cache_res = cache.set(cache_string.as_str(), res, 7200);
                        if let Ok(cache_res) = cache_res {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/librespot/mod.rs:110",
                                            "app_lib::librespot",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/librespot/mod.rs",
                                            ),
                                            ::core::option::Option::Some(110u32),
                                            ::core::option::Option::Some("app_lib::librespot"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Updated result in cache") as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        } else {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/librespot/mod.rs:110",
                                            "app_lib::librespot",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/librespot/mod.rs",
                                            ),
                                            ::core::option::Option::Some(110u32),
                                            ::core::option::Option::Some("app_lib::librespot"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!(
                                                                "Error updating cache {0:?}",
                                                                cache_res.unwrap_err(),
                                                            ) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                    }
                    Err(e) => {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/librespot/mod.rs:110",
                                        "app_lib::librespot",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/librespot/mod.rs",
                                        ),
                                        ::core::option::Option::Some(110u32),
                                        ::core::option::Option::Some("app_lib::librespot"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", e) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                }
                res
            }
        };
        if !__tracing_attr_span.is_disabled() {
            tracing::Instrument::instrument(
                    __tracing_instrument_future,
                    __tracing_attr_span,
                )
                .await
        } else {
            __tracing_instrument_future.await
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__get_canvaz;
}
mod lyrics {
    use database::cache::CacheHolder;
    use librespot::LibrespotHolder;
    use lyrics::LyricsFetcher;
    use tauri::State;
    use types::errors::Result;
    #[tracing::instrument(level = "trace", skip())]
    pub fn get_lyrics_state() -> LyricsFetcher {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "get_lyrics_state",
                                "app_lib::lyrics",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/lyrics/mod.rs"),
                                ::core::option::Option::Some(7u32),
                                ::core::option::Option::Some("app_lib::lyrics"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: LyricsFetcher = loop {};
                    return __tracing_attr_fake_return;
                }
                { LyricsFetcher::new() }
            }
        }
    }
    #[allow(unreachable_code, clippy::diverging_sub_expression)]
    const _: () = if false {
        trait AsyncCommandMustReturnResult {}
        impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
        let _check: Result<String> = ::core::panicking::panic(
            "internal error: entered unreachable code",
        );
        let _: &dyn AsyncCommandMustReturnResult = &_check;
    };
    #[tracing::instrument(level = "trace", skip(lyrics, librespot, cache, id, url, artists, title))]
    pub async fn get_lyrics(
        lyrics: State<'_, LyricsFetcher>,
        librespot: State<'_, LibrespotHolder>,
        cache: State<'_, CacheHolder>,
        id: String,
        url: String,
        artists: Vec<String>,
        title: String,
    ) -> Result<String> {
        {}
        let __tracing_attr_span = {
            use ::tracing::__macro_support::Callsite as _;
            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "get_lyrics",
                        "app_lib::lyrics",
                        tracing::Level::TRACE,
                        ::core::option::Option::Some("src-tauri/src/lyrics/mod.rs"),
                        ::core::option::Option::Some(12u32),
                        ::core::option::Option::Some("app_lib::lyrics"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = __CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    __CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = __CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    __CALLSITE.metadata(),
                );
                {};
                span
            }
        };
        let __tracing_instrument_future = async move {
            #[allow(
                unknown_lints,
                unreachable_code,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::unreachable,
                clippy::let_with_type_underscore,
                clippy::empty_loop
            )]
            if false {
                let __tracing_attr_fake_return: Result<String> = loop {};
                return __tracing_attr_fake_return;
            }
            {
                let cache_string = ::alloc::__export::must_use({
                    let res = ::alloc::fmt::format(
                        format_args!(
                            "get_lyrics_{0}_{1}_{2:?}_{3}",
                            id,
                            url,
                            artists,
                            title,
                        ),
                    );
                    res
                });
                let cached = cache.get(&cache_string);
                if cached.is_ok() {
                    return cached;
                }
                let res = lyrics
                    .get_lyrics(librespot.inner(), id, url, artists, title)
                    .await?;
                let _ = cache.set(cache_string.as_str(), &res, 7200);
                Ok(res)
            }
        };
        if !__tracing_attr_span.is_disabled() {
            tracing::Instrument::instrument(
                    __tracing_instrument_future,
                    __tracing_attr_span,
                )
                .await
        } else {
            __tracing_instrument_future.await
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__get_lyrics;
}
mod mpris {
    use std::thread;
    use macros::generate_command;
    use mpris::MprisHolder;
    use serde_json::{json, Value};
    use tauri::{AppHandle, Emitter, State};
    use types::{
        errors::Result, mpris::MprisPlayerDetails, ui::player_details::PlayerState,
    };
    #[tracing::instrument(level = "trace", skip(app))]
    pub fn get_mpris_state(app: AppHandle) -> Result<MprisHolder> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "get_mpris_state",
                                "app_lib::mpris",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/mpris/mod.rs"),
                                ::core::option::Option::Some(9u32),
                                ::core::option::Option::Some("app_lib::mpris"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: Result<MprisHolder> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    let mpris_holder = MprisHolder::new()?;
                    let receiver = mpris_holder.event_rx.clone();
                    thread::spawn(move || {
                        let receiver = receiver.lock().unwrap();
                        loop {
                            let event = receiver.recv().unwrap();
                            let data = match event {
                                mpris::MediaControlEvent::Play => (0, Value::Null),
                                mpris::MediaControlEvent::Pause => (1, Value::Null),
                                mpris::MediaControlEvent::Toggle => (13, Value::Null),
                                mpris::MediaControlEvent::Next => (6, Value::Null),
                                mpris::MediaControlEvent::Previous => (7, Value::Null),
                                mpris::MediaControlEvent::Stop => (2, Value::Null),
                                mpris::MediaControlEvent::Seek(_) => {
                                    (12, ::serde_json::to_value(&0).unwrap())
                                }
                                mpris::MediaControlEvent::SeekBy(_dir, pos) => {
                                    (12, ::serde_json::to_value(&pos.as_secs()).unwrap())
                                }
                                mpris::MediaControlEvent::SetPosition(pos) => {
                                    (12, ::serde_json::to_value(&pos.0.as_secs()).unwrap())
                                }
                                mpris::MediaControlEvent::SetVolume(vol) => {
                                    (15, ::serde_json::to_value(&vol).unwrap())
                                }
                                mpris::MediaControlEvent::OpenUri(uri) => {
                                    (16, Value::String(uri))
                                }
                                mpris::MediaControlEvent::Raise => (17, Value::Null),
                                mpris::MediaControlEvent::Quit => (18, Value::Null),
                            };
                            let _ = app.emit("media_button_press", data);
                        }
                    });
                    Ok(mpris_holder)
                }
            }
        }
    }
    #[tracing::instrument(level = "trace", skip(db, metadata))]
    pub fn set_metadata(
        db: State<MprisHolder>,
        metadata: MprisPlayerDetails,
    ) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "set_metadata",
                                "app_lib::mpris",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/mpris/mod.rs"),
                                ::core::option::Option::Some(49u32),
                                ::core::option::Option::Some("app_lib::mpris"),
                                ::tracing_core::field::FieldSet::new(
                                    &["metadata"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&metadata) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/mpris/mod.rs:49",
                                    "app_lib::mpris",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/mpris/mod.rs"),
                                    ::core::option::Option::Some(49u32),
                                    ::core::option::Option::Some("app_lib::mpris"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "set_metadata") as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.set_metadata(metadata);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/mpris/mod.rs:49",
                                        "app_lib::mpris",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/mpris/mod.rs"),
                                        ::core::option::Option::Some(49u32),
                                        ::core::option::Option::Some("app_lib::mpris"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/mpris/mod.rs:49",
                                        "app_lib::mpris",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/mpris/mod.rs"),
                                        ::core::option::Option::Some(49u32),
                                        ::core::option::Option::Some("app_lib::mpris"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__set_metadata;
    #[tracing::instrument(level = "trace", skip(db, state))]
    pub fn set_playback_state(
        db: State<MprisHolder>,
        state: PlayerState,
    ) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "set_playback_state",
                                "app_lib::mpris",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/mpris/mod.rs"),
                                ::core::option::Option::Some(50u32),
                                ::core::option::Option::Some("app_lib::mpris"),
                                ::tracing_core::field::FieldSet::new(
                                    &["state"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&state) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/mpris/mod.rs:50",
                                    "app_lib::mpris",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/mpris/mod.rs"),
                                    ::core::option::Option::Some(50u32),
                                    ::core::option::Option::Some("app_lib::mpris"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "set_playback_state")
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.set_playback_state(state);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/mpris/mod.rs:50",
                                        "app_lib::mpris",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/mpris/mod.rs"),
                                        ::core::option::Option::Some(50u32),
                                        ::core::option::Option::Some("app_lib::mpris"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/mpris/mod.rs:50",
                                        "app_lib::mpris",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/mpris/mod.rs"),
                                        ::core::option::Option::Some(50u32),
                                        ::core::option::Option::Some("app_lib::mpris"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__set_playback_state;
    #[tracing::instrument(level = "trace", skip(db, duration))]
    pub fn set_position(
        db: State<MprisHolder>,
        duration: f64,
    ) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "set_position",
                                "app_lib::mpris",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/mpris/mod.rs"),
                                ::core::option::Option::Some(51u32),
                                ::core::option::Option::Some("app_lib::mpris"),
                                ::tracing_core::field::FieldSet::new(
                                    &["duration"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&duration) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/mpris/mod.rs:51",
                                    "app_lib::mpris",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/mpris/mod.rs"),
                                    ::core::option::Option::Some(51u32),
                                    ::core::option::Option::Some("app_lib::mpris"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "set_position") as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.set_position(duration);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/mpris/mod.rs:51",
                                        "app_lib::mpris",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/mpris/mod.rs"),
                                        ::core::option::Option::Some(51u32),
                                        ::core::option::Option::Some("app_lib::mpris"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/mpris/mod.rs:51",
                                        "app_lib::mpris",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/mpris/mod.rs"),
                                        ::core::option::Option::Some(51u32),
                                        ::core::option::Option::Some("app_lib::mpris"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__set_position;
}
mod oauth {
    pub mod handler {
        use std::{collections::HashMap, sync::Mutex};
        use tauri::{AppHandle, Manager, State};
        use url::Url;
        use types::errors::Result;
        use crate::providers::handler::ProviderHandler;
        pub struct OAuthHandler {
            pub oauth_map: Mutex<HashMap<String, String>>,
        }
        impl OAuthHandler {
            #[tracing::instrument(level = "trace", skip())]
            pub fn new() -> OAuthHandler {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "new",
                                        "app_lib::oauth::handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/oauth/handler.rs",
                                        ),
                                        ::core::option::Option::Some(15u32),
                                        ::core::option::Option::Some("app_lib::oauth::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: OAuthHandler = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            OAuthHandler {
                                oauth_map: Mutex::new(HashMap::new()),
                            }
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, path, key))]
            pub fn register_oauth_path(&self, path: String, key: String) {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "register_oauth_path",
                                        "app_lib::oauth::handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/oauth/handler.rs",
                                        ),
                                        ::core::option::Option::Some(22u32),
                                        ::core::option::Option::Some("app_lib::oauth::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: () = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            let mut oauth_map = self.oauth_map.lock().unwrap();
                            oauth_map.insert(path, key.clone());
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, path))]
            pub fn unregister_oauth_path(&self, path: String) {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "unregister_oauth_path",
                                        "app_lib::oauth::handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/oauth/handler.rs",
                                        ),
                                        ::core::option::Option::Some(28u32),
                                        ::core::option::Option::Some("app_lib::oauth::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: () = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            let mut oauth_map = self.oauth_map.lock().unwrap();
                            oauth_map.remove(&path);
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, app, url))]
            pub fn handle_oauth(&self, app: AppHandle, url: String) -> Result<()> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "handle_oauth",
                                        "app_lib::oauth::handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/oauth/handler.rs",
                                        ),
                                        ::core::option::Option::Some(34u32),
                                        ::core::option::Option::Some("app_lib::oauth::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<()> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            let oauth_map = self.oauth_map.lock().unwrap();
                            let url_parsed = Url::parse(url.as_str()).unwrap();
                            let path = url_parsed.host_str().unwrap();
                            if let Some(key) = oauth_map.get(path) {
                                let app = app.clone();
                                let key = key.clone();
                                tauri::async_runtime::spawn(async move {
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "event src-tauri/src/oauth/handler.rs:43",
                                                    "app_lib::oauth::handler",
                                                    ::tracing::Level::INFO,
                                                    ::core::option::Option::Some(
                                                        "src-tauri/src/oauth/handler.rs",
                                                    ),
                                                    ::core::option::Option::Some(43u32),
                                                    ::core::option::Option::Some("app_lib::oauth::handler"),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["message"],
                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::EVENT,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let enabled = ::tracing::Level::INFO
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::tracing::Level::INFO
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                let interest = __CALLSITE.interest();
                                                !interest.is_never()
                                                    && ::tracing::__macro_support::__is_enabled(
                                                        __CALLSITE.metadata(),
                                                        interest,
                                                    )
                                            };
                                        if enabled {
                                            (|value_set: ::tracing::field::ValueSet| {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                            })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::core::iter::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::core::option::Option::Some(
                                                                    &format_args!("Authorizing {0}", key) as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            });
                                        } else {
                                        }
                                    };
                                    let provider_handler: State<ProviderHandler> = app.state();
                                    let err = provider_handler
                                        .provider_authorize(key.clone(), url)
                                        .await;
                                    if let Err(err) = err {
                                        {
                                            use ::tracing::__macro_support::Callsite as _;
                                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                                static META: ::tracing::Metadata<'static> = {
                                                    ::tracing_core::metadata::Metadata::new(
                                                        "event src-tauri/src/oauth/handler.rs:47",
                                                        "app_lib::oauth::handler",
                                                        ::tracing::Level::ERROR,
                                                        ::core::option::Option::Some(
                                                            "src-tauri/src/oauth/handler.rs",
                                                        ),
                                                        ::core::option::Option::Some(47u32),
                                                        ::core::option::Option::Some("app_lib::oauth::handler"),
                                                        ::tracing_core::field::FieldSet::new(
                                                            &["message"],
                                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                        ),
                                                        ::tracing::metadata::Kind::EVENT,
                                                    )
                                                };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                            let enabled = ::tracing::Level::ERROR
                                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                                && ::tracing::Level::ERROR
                                                    <= ::tracing::level_filters::LevelFilter::current()
                                                && {
                                                    let interest = __CALLSITE.interest();
                                                    !interest.is_never()
                                                        && ::tracing::__macro_support::__is_enabled(
                                                            __CALLSITE.metadata(),
                                                            interest,
                                                        )
                                                };
                                            if enabled {
                                                (|value_set: ::tracing::field::ValueSet| {
                                                    let meta = __CALLSITE.metadata();
                                                    ::tracing::Event::dispatch(meta, &value_set);
                                                })({
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &::core::iter::Iterator::next(&mut iter)
                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                    ::core::option::Option::Some(
                                                                        &format_args!("Error authorizing {0}: {1:?}", key, err)
                                                                            as &dyn Value,
                                                                    ),
                                                                ),
                                                            ],
                                                        )
                                                });
                                            } else {
                                            }
                                        };
                                    }
                                });
                            }
                            Ok(())
                        }
                    }
                }
            }
        }
        #[tracing::instrument(level = "trace", skip())]
        pub fn get_oauth_state() -> Result<OAuthHandler> {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current() || { false }
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "get_oauth_state",
                                    "app_lib::oauth::handler",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/oauth/handler.rs",
                                    ),
                                    ::core::option::Option::Some(56u32),
                                    ::core::option::Option::Some("app_lib::oauth::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<OAuthHandler> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    { Ok(OAuthHandler::new()) }
                }
            }
        }
    }
}
mod preference_holder {
    use std::thread;
    use database::database::Database;
    use file_scanner::scanner::ScannerHolder;
    use macros::generate_command;
    use preferences::preferences::PreferenceConfig;
    use serde_json::Value;
    use tauri::{async_runtime, App, AppHandle, Emitter, Manager, State};
    use types::errors::Result;
    use crate::{providers::handler::ProviderHandler, scanner::start_scan};
    const UI_KEYS: &[&str] = &[
        "prefs.system_settings",
        "prefs.queue_settings",
        "prefs.audio_settings",
        "prefs.gapless_skip",
        "prefs.volume_persist_mode",
        "prefs.spotify.enable",
        "prefs.spotify.username",
        "prefs.spotify.password",
        "prefs.themes.active_theme",
    ];
    #[tracing::instrument(level = "trace", skip(app))]
    pub fn handle_pref_changes(app: AppHandle) {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "handle_pref_changes",
                                "app_lib::preference_holder",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/preference_holder/mod.rs",
                                ),
                                ::core::option::Option::Some(35u32),
                                ::core::option::Option::Some("app_lib::preference_holder"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: () = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    async_runtime::spawn(async move {
                        let pref_config: State<PreferenceConfig> = app
                            .state::<PreferenceConfig>()
                            .clone();
                        let receiver = pref_config.get_receiver();
                        for (key, value) in receiver {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/preference_holder/mod.rs:41",
                                            "app_lib::preference_holder",
                                            ::tracing::Level::INFO,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/preference_holder/mod.rs",
                                            ),
                                            ::core::option::Option::Some(41u32),
                                            ::core::option::Option::Some("app_lib::preference_holder"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::INFO
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::INFO
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Received key: {0} value: {1}", key, value)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            if UI_KEYS.contains(&key.as_str()) {
                                let app = app.clone();
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/preference_holder/mod.rs:44",
                                                "app_lib::preference_holder",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/preference_holder/mod.rs",
                                                ),
                                                ::core::option::Option::Some(44u32),
                                                ::core::option::Option::Some("app_lib::preference_holder"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("Emitting preference-changed event")
                                                                    as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                if let Err(e) = app
                                    .emit("preference-changed", (key.clone(), value.clone()))
                                {
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "event src-tauri/src/preference_holder/mod.rs:46",
                                                    "app_lib::preference_holder",
                                                    ::tracing::Level::ERROR,
                                                    ::core::option::Option::Some(
                                                        "src-tauri/src/preference_holder/mod.rs",
                                                    ),
                                                    ::core::option::Option::Some(46u32),
                                                    ::core::option::Option::Some("app_lib::preference_holder"),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["message"],
                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::EVENT,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let enabled = ::tracing::Level::ERROR
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::tracing::Level::ERROR
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                let interest = __CALLSITE.interest();
                                                !interest.is_never()
                                                    && ::tracing::__macro_support::__is_enabled(
                                                        __CALLSITE.metadata(),
                                                        interest,
                                                    )
                                            };
                                        if enabled {
                                            (|value_set: ::tracing::field::ValueSet| {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                            })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::core::iter::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::core::option::Option::Some(
                                                                    &format_args!(
                                                                        "Error emitting preference-changed event{0}",
                                                                        e,
                                                                    ) as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            });
                                        } else {
                                        }
                                    };
                                } else {
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "event src-tauri/src/preference_holder/mod.rs:48",
                                                    "app_lib::preference_holder",
                                                    ::tracing::Level::INFO,
                                                    ::core::option::Option::Some(
                                                        "src-tauri/src/preference_holder/mod.rs",
                                                    ),
                                                    ::core::option::Option::Some(48u32),
                                                    ::core::option::Option::Some("app_lib::preference_holder"),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["message"],
                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::EVENT,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let enabled = ::tracing::Level::INFO
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::tracing::Level::INFO
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                let interest = __CALLSITE.interest();
                                                !interest.is_never()
                                                    && ::tracing::__macro_support::__is_enabled(
                                                        __CALLSITE.metadata(),
                                                        interest,
                                                    )
                                            };
                                        if enabled {
                                            (|value_set: ::tracing::field::ValueSet| {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                            })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::core::iter::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::core::option::Option::Some(
                                                                    &format_args!("Emitted preference-changed event")
                                                                        as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            });
                                        } else {
                                        }
                                    };
                                }
                            }
                            if key == "prefs.music_paths"
                                || key == "prefs.exclude_music_paths"
                            {
                                let app = app.clone();
                                thread::spawn(move || {
                                    let app = app.clone();
                                    let (pref_config, scanner, database) = {
                                        let tuple = (
                                            app.state::<PreferenceConfig>().clone(),
                                            app.state::<ScannerHolder>().clone(),
                                            app.state::<Database>().clone(),
                                        );
                                        tuple
                                    };
                                    if let Err(e) = start_scan(
                                        scanner,
                                        database,
                                        pref_config,
                                        None,
                                        true,
                                    ) {
                                        {
                                            use ::tracing::__macro_support::Callsite as _;
                                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                                static META: ::tracing::Metadata<'static> = {
                                                    ::tracing_core::metadata::Metadata::new(
                                                        "event src-tauri/src/preference_holder/mod.rs:59",
                                                        "app_lib::preference_holder",
                                                        ::tracing::Level::ERROR,
                                                        ::core::option::Option::Some(
                                                            "src-tauri/src/preference_holder/mod.rs",
                                                        ),
                                                        ::core::option::Option::Some(59u32),
                                                        ::core::option::Option::Some("app_lib::preference_holder"),
                                                        ::tracing_core::field::FieldSet::new(
                                                            &["message"],
                                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                        ),
                                                        ::tracing::metadata::Kind::EVENT,
                                                    )
                                                };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                            let enabled = ::tracing::Level::ERROR
                                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                                && ::tracing::Level::ERROR
                                                    <= ::tracing::level_filters::LevelFilter::current()
                                                && {
                                                    let interest = __CALLSITE.interest();
                                                    !interest.is_never()
                                                        && ::tracing::__macro_support::__is_enabled(
                                                            __CALLSITE.metadata(),
                                                            interest,
                                                        )
                                                };
                                            if enabled {
                                                (|value_set: ::tracing::field::ValueSet| {
                                                    let meta = __CALLSITE.metadata();
                                                    ::tracing::Event::dispatch(meta, &value_set);
                                                })({
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &::core::iter::Iterator::next(&mut iter)
                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                    ::core::option::Option::Some(
                                                                        &format_args!("{0}", e) as &dyn Value,
                                                                    ),
                                                                ),
                                                            ],
                                                        )
                                                });
                                            } else {
                                            }
                                        };
                                    }
                                });
                            }
                            if key.starts_with("prefs.youtube") {
                                let app = app.clone();
                                async_runtime::spawn(async move {
                                    let app = app.clone();
                                    let provider_state: State<ProviderHandler> = app.state();
                                    provider_state.initialize_provider("youtube".into()).await;
                                });
                            }
                            if key.starts_with("prefs.spotify") {
                                let app = app.clone();
                                async_runtime::spawn(async move {
                                    let app = app.clone();
                                    let provider_state: State<ProviderHandler> = app.state();
                                    provider_state.initialize_provider("spotify".into()).await;
                                });
                            }
                        }
                    });
                }
            }
        }
    }
    #[tracing::instrument(level = "trace", skip(app))]
    pub fn get_preference_state(app: &mut App) -> Result<PreferenceConfig> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "get_preference_state",
                                "app_lib::preference_holder",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/preference_holder/mod.rs",
                                ),
                                ::core::option::Option::Some(85u32),
                                ::core::option::Option::Some("app_lib::preference_holder"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: Result<PreferenceConfig> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    let data_dir = app.path().app_config_dir()?;
                    PreferenceConfig::new(data_dir)
                }
            }
        }
    }
    #[tracing::instrument(level = "trace", skip(app))]
    pub fn initial(app: &mut App) {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "initial",
                                "app_lib::preference_holder",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/preference_holder/mod.rs",
                                ),
                                ::core::option::Option::Some(91u32),
                                ::core::option::Option::Some("app_lib::preference_holder"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: () = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    let pref_config: State<PreferenceConfig> = app.state();
                    if !pref_config.has_key("thumbnail_path") {
                        let path = app
                            .path()
                            .app_local_data_dir()
                            .unwrap()
                            .join("thumbnails");
                        let _ = pref_config
                            .save_selective("thumbnail_path".to_string(), Some(path));
                    }
                    if !pref_config.has_key("artwork_path") {
                        let path = app
                            .path()
                            .app_local_data_dir()
                            .unwrap()
                            .join("artwork");
                        let _ = pref_config
                            .save_selective("artwork_path".to_string(), Some(path));
                    }
                }
            }
        }
    }
    #[tracing::instrument(level = "trace", skip(db, key))]
    pub fn load_selective(
        db: State<PreferenceConfig>,
        key: String,
    ) -> types::errors::Result<Value> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "load_selective",
                                "app_lib::preference_holder",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/preference_holder/mod.rs",
                                ),
                                ::core::option::Option::Some(105u32),
                                ::core::option::Option::Some("app_lib::preference_holder"),
                                ::tracing_core::field::FieldSet::new(
                                    &["key"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&key) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<Value> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/preference_holder/mod.rs:105",
                                    "app_lib::preference_holder",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/preference_holder/mod.rs",
                                    ),
                                    ::core::option::Option::Some(105u32),
                                    ::core::option::Option::Some("app_lib::preference_holder"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "load_selective") as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.load_selective(key);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/preference_holder/mod.rs:105",
                                        "app_lib::preference_holder",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/preference_holder/mod.rs",
                                        ),
                                        ::core::option::Option::Some(105u32),
                                        ::core::option::Option::Some("app_lib::preference_holder"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/preference_holder/mod.rs:105",
                                        "app_lib::preference_holder",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/preference_holder/mod.rs",
                                        ),
                                        ::core::option::Option::Some(105u32),
                                        ::core::option::Option::Some("app_lib::preference_holder"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__load_selective;
    #[tracing::instrument(level = "trace", skip(db, key, value))]
    pub fn save_selective(
        db: State<PreferenceConfig>,
        key: String,
        value: Option<Value>,
    ) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "save_selective",
                                "app_lib::preference_holder",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/preference_holder/mod.rs",
                                ),
                                ::core::option::Option::Some(106u32),
                                ::core::option::Option::Some("app_lib::preference_holder"),
                                ::tracing_core::field::FieldSet::new(
                                    &["key", "value"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&key) as &dyn Value,
                                                ),
                                            ),
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&value) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/preference_holder/mod.rs:106",
                                    "app_lib::preference_holder",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/preference_holder/mod.rs",
                                    ),
                                    ::core::option::Option::Some(106u32),
                                    ::core::option::Option::Some("app_lib::preference_holder"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "save_selective") as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.save_selective(key, value);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/preference_holder/mod.rs:106",
                                        "app_lib::preference_holder",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/preference_holder/mod.rs",
                                        ),
                                        ::core::option::Option::Some(106u32),
                                        ::core::option::Option::Some("app_lib::preference_holder"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/preference_holder/mod.rs:106",
                                        "app_lib::preference_holder",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/preference_holder/mod.rs",
                                        ),
                                        ::core::option::Option::Some(106u32),
                                        ::core::option::Option::Some("app_lib::preference_holder"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__save_selective;
    #[tracing::instrument(level = "trace", skip(db, key))]
    pub fn get_secure(
        db: State<PreferenceConfig>,
        key: String,
    ) -> types::errors::Result<Value> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "get_secure",
                                "app_lib::preference_holder",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/preference_holder/mod.rs",
                                ),
                                ::core::option::Option::Some(107u32),
                                ::core::option::Option::Some("app_lib::preference_holder"),
                                ::tracing_core::field::FieldSet::new(
                                    &["key"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&key) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<Value> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/preference_holder/mod.rs:107",
                                    "app_lib::preference_holder",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/preference_holder/mod.rs",
                                    ),
                                    ::core::option::Option::Some(107u32),
                                    ::core::option::Option::Some("app_lib::preference_holder"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "get_secure") as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.get_secure(key);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/preference_holder/mod.rs:107",
                                        "app_lib::preference_holder",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/preference_holder/mod.rs",
                                        ),
                                        ::core::option::Option::Some(107u32),
                                        ::core::option::Option::Some("app_lib::preference_holder"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/preference_holder/mod.rs:107",
                                        "app_lib::preference_holder",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/preference_holder/mod.rs",
                                        ),
                                        ::core::option::Option::Some(107u32),
                                        ::core::option::Option::Some("app_lib::preference_holder"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__get_secure;
    #[tracing::instrument(level = "trace", skip(db, key, value))]
    pub fn set_secure(
        db: State<PreferenceConfig>,
        key: String,
        value: Option<Value>,
    ) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "set_secure",
                                "app_lib::preference_holder",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/preference_holder/mod.rs",
                                ),
                                ::core::option::Option::Some(108u32),
                                ::core::option::Option::Some("app_lib::preference_holder"),
                                ::tracing_core::field::FieldSet::new(
                                    &["key", "value"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&key) as &dyn Value,
                                                ),
                                            ),
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&value) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/preference_holder/mod.rs:108",
                                    "app_lib::preference_holder",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/preference_holder/mod.rs",
                                    ),
                                    ::core::option::Option::Some(108u32),
                                    ::core::option::Option::Some("app_lib::preference_holder"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "set_secure") as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.set_secure(key, value);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/preference_holder/mod.rs:108",
                                        "app_lib::preference_holder",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/preference_holder/mod.rs",
                                        ),
                                        ::core::option::Option::Some(108u32),
                                        ::core::option::Option::Some("app_lib::preference_holder"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/preference_holder/mod.rs:108",
                                        "app_lib::preference_holder",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/preference_holder/mod.rs",
                                        ),
                                        ::core::option::Option::Some(108u32),
                                        ::core::option::Option::Some("app_lib::preference_holder"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__set_secure;
    #[tracing::instrument(level = "trace", skip(db, key))]
    pub fn load_selective_array(
        db: State<PreferenceConfig>,
        key: String,
    ) -> types::errors::Result<Value> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "load_selective_array",
                                "app_lib::preference_holder",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/preference_holder/mod.rs",
                                ),
                                ::core::option::Option::Some(109u32),
                                ::core::option::Option::Some("app_lib::preference_holder"),
                                ::tracing_core::field::FieldSet::new(
                                    &["key"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&key) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<Value> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/preference_holder/mod.rs:109",
                                    "app_lib::preference_holder",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/preference_holder/mod.rs",
                                    ),
                                    ::core::option::Option::Some(109u32),
                                    ::core::option::Option::Some("app_lib::preference_holder"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "load_selective_array")
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.load_selective_array(key);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/preference_holder/mod.rs:109",
                                        "app_lib::preference_holder",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/preference_holder/mod.rs",
                                        ),
                                        ::core::option::Option::Some(109u32),
                                        ::core::option::Option::Some("app_lib::preference_holder"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/preference_holder/mod.rs:109",
                                        "app_lib::preference_holder",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/preference_holder/mod.rs",
                                        ),
                                        ::core::option::Option::Some(109u32),
                                        ::core::option::Option::Some("app_lib::preference_holder"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__load_selective_array;
}
mod providers {
    pub mod common {
        use std::collections::HashMap;
        use std::time::{SystemTime, UNIX_EPOCH};
        use oauth2::reqwest::async_http_client;
        use oauth2::{
            basic::BasicClient, AuthUrl, ClientId, ClientSecret, RedirectUrl, TokenUrl,
        };
        use oauth2::{
            AuthorizationCode, CsrfToken, PkceCodeChallenge, RefreshToken, Scope,
            TokenResponse,
        };
        use preferences::preferences::PreferenceConfig;
        use serde::{Deserialize, Serialize};
        use tauri::{AppHandle, Manager, State};
        use types::errors::{MoosyncError, Result};
        use types::oauth::{OAuth2Client, OAuth2Verifier, OAuthTokenResponse};
        use url::Url;
        use crate::window::handler::WindowHandler;
        pub struct TokenHolder {
            pub access_token: String,
            pub refresh_token: String,
            pub expires_in: u64,
            pub expires_at: i64,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TokenHolder {
            #[tracing::instrument(level = "trace", skip(self, f))]
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "TokenHolder",
                    "access_token",
                    &self.access_token,
                    "refresh_token",
                    &self.refresh_token,
                    "expires_in",
                    &self.expires_in,
                    "expires_at",
                    &&self.expires_at,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TokenHolder {
            #[tracing::instrument(level = "trace", skip(self))]
            #[inline]
            fn clone(&self) -> TokenHolder {
                TokenHolder {
                    access_token: ::core::clone::Clone::clone(&self.access_token),
                    refresh_token: ::core::clone::Clone::clone(&self.refresh_token),
                    expires_in: ::core::clone::Clone::clone(&self.expires_in),
                    expires_at: ::core::clone::Clone::clone(&self.expires_at),
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for TokenHolder {
                #[tracing::instrument(level = "trace", skip(self, __serializer))]
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "TokenHolder",
                        false as usize + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "access_token",
                        &self.access_token,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "refresh_token",
                        &self.refresh_token,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "expires_in",
                        &self.expires_in,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "expires_at",
                        &self.expires_at,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for TokenHolder {
                #[tracing::instrument(level = "trace", skip(__deserializer))]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        #[tracing::instrument(level = "trace", skip(self, __formatter))]
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        #[tracing::instrument(level = "trace", skip(self, __value))]
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        #[tracing::instrument(level = "trace", skip(self, __value))]
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "access_token" => _serde::__private::Ok(__Field::__field0),
                                "refresh_token" => _serde::__private::Ok(__Field::__field1),
                                "expires_in" => _serde::__private::Ok(__Field::__field2),
                                "expires_at" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        #[tracing::instrument(level = "trace", skip(self, __value))]
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"access_token" => _serde::__private::Ok(__Field::__field0),
                                b"refresh_token" => _serde::__private::Ok(__Field::__field1),
                                b"expires_in" => _serde::__private::Ok(__Field::__field2),
                                b"expires_at" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[tracing::instrument(level = "trace", skip(__deserializer))]
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<TokenHolder>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = TokenHolder;
                        #[tracing::instrument(level = "trace", skip(self, __formatter))]
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct TokenHolder",
                            )
                        }
                        #[tracing::instrument(level = "trace", skip(self, __seq))]
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct TokenHolder with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct TokenHolder with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                u64,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct TokenHolder with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                i64,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct TokenHolder with 4 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(TokenHolder {
                                access_token: __field0,
                                refresh_token: __field1,
                                expires_in: __field2,
                                expires_at: __field3,
                            })
                        }
                        #[tracing::instrument(level = "trace", skip(self, __map))]
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<u64> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<i64> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "access_token",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "refresh_token",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "expires_in",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "expires_at",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("access_token")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("refresh_token")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("expires_in")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("expires_at")?
                                }
                            };
                            _serde::__private::Ok(TokenHolder {
                                access_token: __field0,
                                refresh_token: __field1,
                                expires_in: __field2,
                                expires_at: __field3,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "access_token",
                        "refresh_token",
                        "expires_in",
                        "expires_at",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "TokenHolder",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<TokenHolder>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct OAuthClientArgs {
            pub auth_url: String,
            pub token_url: String,
            pub redirect_url: String,
            pub client_id: String,
            pub client_secret: String,
        }
        #[tracing::instrument(level = "trace", skip(config))]
        pub fn get_oauth_client(config: OAuthClientArgs) -> OAuth2Client {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current() || { false }
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "get_oauth_client",
                                    "app_lib::providers::common",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/common.rs",
                                    ),
                                    ::core::option::Option::Some(32u32),
                                    ::core::option::Option::Some("app_lib::providers::common"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: OAuth2Client = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        BasicClient::new(
                                ClientId::new(config.client_id),
                                Some(ClientSecret::new(config.client_secret)),
                                AuthUrl::new(config.auth_url).unwrap(),
                                Some(TokenUrl::new(config.token_url).unwrap()),
                            )
                            .set_redirect_uri(
                                RedirectUrl::new(config.redirect_url).unwrap(),
                            )
                    }
                }
            }
        }
        #[tracing::instrument(level = "trace", skip(key, app, res, default_refresh))]
        pub fn set_tokens(
            key: &str,
            app: &AppHandle,
            res: OAuthTokenResponse,
            default_refresh: Option<String>,
        ) -> Result<TokenHolder> {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current() || { false }
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "set_tokens",
                                    "app_lib::providers::common",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/common.rs",
                                    ),
                                    ::core::option::Option::Some(43u32),
                                    ::core::option::Option::Some("app_lib::providers::common"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<TokenHolder> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/providers/common.rs:50",
                                        "app_lib::providers::common",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/common.rs",
                                        ),
                                        ::core::option::Option::Some(50u32),
                                        ::core::option::Option::Some("app_lib::providers::common"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("token response: {0:?}", res) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        let refresh_token = res
                            .refresh_token()
                            .map(|r| r.secret().clone())
                            .unwrap_or(default_refresh.unwrap_or_default());
                        let expires_in = res.expires_in().unwrap_or_default();
                        let token_holder = TokenHolder {
                            access_token: res.access_token().secret().clone(),
                            refresh_token: refresh_token.clone(),
                            expires_in: expires_in.as_secs(),
                            expires_at: (SystemTime::now()
                                .duration_since(UNIX_EPOCH)
                                .unwrap() + expires_in)
                                .as_millis() as i64,
                        };
                        let preferences: State<PreferenceConfig> = app.state();
                        preferences.set_secure(key.into(), Some(refresh_token))?;
                        Ok(token_holder)
                    }
                }
            }
        }
        #[tracing::instrument(level = "trace", skip(key, client, app))]
        pub async fn refresh_login(
            key: &str,
            client: OAuth2Client,
            app: &AppHandle,
        ) -> Result<TokenHolder> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "refresh_login",
                            "app_lib::providers::common",
                            tracing::Level::TRACE,
                            ::core::option::Option::Some(
                                "src-tauri/src/providers/common.rs",
                            ),
                            ::core::option::Option::Some(70u32),
                            ::core::option::Option::Some("app_lib::providers::common"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = __CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        __CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        __CALLSITE.metadata(),
                    );
                    {};
                    span
                }
            };
            let __tracing_instrument_future = async move {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: Result<TokenHolder> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    let preferences: State<PreferenceConfig> = app.state();
                    let refresh_token: Result<String> = preferences
                        .inner()
                        .get_secure(key.into());
                    if refresh_token.is_err() {
                        let preferences: State<PreferenceConfig> = app.state();
                        let res = preferences
                            .inner()
                            .set_secure::<String>(key.into(), None);
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/providers/common.rs:81",
                                        "app_lib::providers::common",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/common.rs",
                                        ),
                                        ::core::option::Option::Some(81u32),
                                        ::core::option::Option::Some("app_lib::providers::common"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Set secure token: {0:?}", res) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        return Err(
                            ::alloc::__export::must_use({
                                    let res = ::alloc::fmt::format(
                                        format_args!(
                                            "Refresh token not found or corrupted: {0:?}",
                                            refresh_token.unwrap_err(),
                                        ),
                                    );
                                    res
                                })
                                .into(),
                        );
                    }
                    let refresh_token = refresh_token.unwrap();
                    if !refresh_token.is_empty() {
                        let res = client
                            .exchange_refresh_token(
                                &RefreshToken::new(refresh_token.to_string()),
                            )
                            .request_async(async_http_client)
                            .await
                            .map_err(|err| match err {
                                oauth2::RequestTokenError::ServerResponse(e) => {
                                    MoosyncError::String(e.to_string())
                                }
                                oauth2::RequestTokenError::Request(_) => {
                                    ::core::panicking::panic("not yet implemented")
                                }
                                oauth2::RequestTokenError::Parse(_, _) => {
                                    ::core::panicking::panic("not yet implemented")
                                }
                                oauth2::RequestTokenError::Other(_) => {
                                    ::core::panicking::panic("not yet implemented")
                                }
                            })?;
                        return set_tokens(
                            key,
                            app,
                            res,
                            Some(refresh_token.to_string()),
                        );
                    }
                    Err("Refresh token not found".into())
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        pub struct LoginArgs {
            pub client_id: Option<String>,
            pub client_secret: Option<String>,
            pub scopes: Vec<&'static str>,
            pub extra_params: Option<HashMap<&'static str, &'static str>>,
        }
        #[tracing::instrument(level = "trace", skip(config, client, app))]
        pub fn login(
            config: LoginArgs,
            client: OAuth2Client,
            app: &AppHandle,
        ) -> Result<OAuth2Verifier> {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current() || { false }
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "login",
                                    "app_lib::providers::common",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/common.rs",
                                    ),
                                    ::core::option::Option::Some(115u32),
                                    ::core::option::Option::Some("app_lib::providers::common"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<OAuth2Verifier> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        if config.client_id.is_none() || config.client_secret.is_none() {
                            return Err("Client ID not set".into());
                        }
                        let (pkce_challenge, pkce_verifier) = PkceCodeChallenge::new_random_sha256();
                        let mut builder = client
                            .authorize_url(CsrfToken::new_random)
                            .add_scopes(
                                config.scopes.iter().map(|s| Scope::new(s.to_string())),
                            )
                            .set_pkce_challenge(pkce_challenge);
                        if let Some(extra_params) = config.extra_params {
                            for (key, value) in extra_params {
                                builder = builder.add_extra_param(key, value);
                            }
                        }
                        let (auth_url, csrf_token) = builder.url();
                        let verifier = Some((client, pkce_verifier, csrf_token.clone()));
                        let window: State<WindowHandler> = app.state();
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/providers/common.rs:139",
                                        "app_lib::providers::common",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/common.rs",
                                        ),
                                        ::core::option::Option::Some(139u32),
                                        ::core::option::Option::Some("app_lib::providers::common"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Opening url {0:?}", auth_url) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        if let Err(e) = window
                            .inner()
                            .open_external(auth_url.to_string())
                        {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/providers/common.rs:141",
                                            "app_lib::providers::common",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/providers/common.rs",
                                            ),
                                            ::core::option::Option::Some(141u32),
                                            ::core::option::Option::Some("app_lib::providers::common"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Error opening URL: {0:?}", e) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                        Ok(verifier)
                    }
                }
            }
        }
        #[tracing::instrument(level = "trace", skip(key, code, verifier, app))]
        pub async fn authorize(
            key: &str,
            code: String,
            verifier: &mut OAuth2Verifier,
            app: &AppHandle,
        ) -> Result<TokenHolder> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "authorize",
                            "app_lib::providers::common",
                            tracing::Level::TRACE,
                            ::core::option::Option::Some(
                                "src-tauri/src/providers/common.rs",
                            ),
                            ::core::option::Option::Some(146u32),
                            ::core::option::Option::Some("app_lib::providers::common"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = __CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        __CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        __CALLSITE.metadata(),
                    );
                    {};
                    span
                }
            };
            let __tracing_instrument_future = async move {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: Result<TokenHolder> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    if verifier.is_none() {
                        return Err("OAuth not initiated".into());
                    }
                    let parsed_code = if code.starts_with("?") {
                        Url::parse(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("https://moosync.app/login{0}", code),
                                        );
                                        res
                                    })
                                    .as_str(),
                            )
                            .unwrap()
                    } else {
                        Url::parse(code.as_str()).unwrap()
                    };
                    let code = parsed_code
                        .query_pairs()
                        .find(|p| p.0 == "code")
                        .unwrap()
                        .1
                        .to_string();
                    let (client, verifier, _csrf) = verifier.take().unwrap();
                    let res = client
                        .exchange_code(AuthorizationCode::new(code))
                        .set_pkce_verifier(verifier)
                        .request_async(async_http_client)
                        .await
                        .map_err(|err| match err {
                            oauth2::RequestTokenError::ServerResponse(e) => {
                                MoosyncError::String(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "{0:?}: {1:?} {2:?}",
                                                e.error(),
                                                e.error_description(),
                                                serde_json::to_string(&e),
                                            ),
                                        );
                                        res
                                    }),
                                )
                            }
                            oauth2::RequestTokenError::Request(_) => {
                                ::core::panicking::panic("not yet implemented")
                            }
                            oauth2::RequestTokenError::Parse(_, _) => {
                                ::core::panicking::panic("not yet implemented")
                            }
                            oauth2::RequestTokenError::Other(_) => {
                                ::core::panicking::panic("not yet implemented")
                            }
                        })?;
                    set_tokens(key, app, res, None)
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
    }
    pub mod extension {
        use std::fmt::Debug;
        use async_trait::async_trait;
        use futures::{channel::mpsc::UnboundedSender, SinkExt};
        use serde_json::Value;
        use tauri::AppHandle;
        use types::{
            entities::{QueryablePlaylist, SearchResult},
            errors::Result,
            extensions::{
                AccountLoginArgs, CustomRequestReturnType, ExtensionDetail,
                ExtensionExtraEvent, ExtensionExtraEventArgs, ExtensionProviderScope,
                PackageNameArgs, PlaybackDetailsReturnType, PlaylistAndSongsReturnType,
                PlaylistReturnType, RecommendationsReturnType, SearchReturnType,
                SongReturnType, SongsWithPageTokenReturnType,
            },
            providers::generic::{GenericProvider, Pagination, ProviderStatus},
            songs::Song,
        };
        use crate::extensions::get_extension_handler;
        pub struct ExtensionProvider {
            extension: ExtensionDetail,
            provides: Vec<ExtensionProviderScope>,
            app_handle: AppHandle,
            status_tx: UnboundedSender<ProviderStatus>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ExtensionProvider {
            #[tracing::instrument(level = "trace", skip(self))]
            #[inline]
            fn clone(&self) -> ExtensionProvider {
                ExtensionProvider {
                    extension: ::core::clone::Clone::clone(&self.extension),
                    provides: ::core::clone::Clone::clone(&self.provides),
                    app_handle: ::core::clone::Clone::clone(&self.app_handle),
                    status_tx: ::core::clone::Clone::clone(&self.status_tx),
                }
            }
        }
        impl ExtensionProvider {
            #[tracing::instrument(level = "trace", skip(extension, provides, app_handle, status_tx))]
            pub fn new(
                extension: ExtensionDetail,
                provides: Vec<ExtensionProviderScope>,
                app_handle: AppHandle,
                status_tx: UnboundedSender<ProviderStatus>,
            ) -> Self {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "new",
                                        "app_lib::providers::extension",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/extension.rs",
                                        ),
                                        ::core::option::Option::Some(47u32),
                                        ::core::option::Option::Some(
                                            "app_lib::providers::extension",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Self = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            Self {
                                extension,
                                provides,
                                app_handle,
                                status_tx,
                            }
                        }
                    }
                }
            }
        }
        impl Debug for ExtensionProvider {
            #[tracing::instrument(level = "trace", skip(self, f))]
            fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "fmt",
                                        "app_lib::providers::extension",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/extension.rs",
                                        ),
                                        ::core::option::Option::Some(64u32),
                                        ::core::option::Option::Some(
                                            "app_lib::providers::extension",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: std::fmt::Result = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            f.debug_struct("ExtensionProvider")
                                .field("extension", &self.extension)
                                .field("provides", &self.provides)
                                .finish()
                        }
                    }
                }
            }
        }
        impl GenericProvider for ExtensionProvider {
            #[tracing::instrument(level = "trace", skip(self))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn initialize<'life0, 'async_trait>(
                &'life0 mut self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<()>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "initialize",
                                    "app_lib::providers::extension",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/extension.rs",
                                    ),
                                    ::core::option::Option::Some(75u32),
                                    ::core::option::Option::Some(
                                        "app_lib::providers::extension",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<()>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let mut __self = self;
                        let __ret: Result<()> = {
                            let extension_handler = get_extension_handler(
                                &__self.app_handle,
                            );
                            let accounts = extension_handler
                                .get_accounts(PackageNameArgs {
                                    package_name: __self.extension.package_name.clone(),
                                })
                                .await?;
                            for account in accounts {
                                let _ = __self
                                    .status_tx
                                    .send(ProviderStatus {
                                        key: __self.key(),
                                        name: account.name,
                                        user_name: account.username,
                                        logged_in: account.logged_in,
                                        bg_color: account.bg_color,
                                        account_id: account.id,
                                    })
                                    .await;
                            }
                            Ok(())
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self))]
            fn key(&self) -> String {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "key",
                                        "app_lib::providers::extension",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/extension.rs",
                                        ),
                                        ::core::option::Option::Some(99u32),
                                        ::core::option::Option::Some(
                                            "app_lib::providers::extension",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: String = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!("extension:{0}", self.extension.package_name),
                                );
                                res
                            })
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, id))]
            fn match_id(&self, id: String) -> bool {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "match_id",
                                        "app_lib::providers::extension",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/extension.rs",
                                        ),
                                        ::core::option::Option::Some(103u32),
                                        ::core::option::Option::Some(
                                            "app_lib::providers::extension",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &["id"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = meta.fields().iter();
                                        meta.fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &tracing::field::debug(&id) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: bool = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            id.starts_with(
                                &::alloc::__export::must_use({
                                    let res = ::alloc::fmt::format(
                                        format_args!("{0}:", self.extension.package_name),
                                    );
                                    res
                                }),
                            )
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, account_id))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn login<'life0, 'async_trait>(
                &'life0 mut self,
                account_id: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<()>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "login",
                                    "app_lib::providers::extension",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/extension.rs",
                                    ),
                                    ::core::option::Option::Some(108u32),
                                    ::core::option::Option::Some(
                                        "app_lib::providers::extension",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["account_id"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&account_id) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<()>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let mut __self = self;
                        let account_id = account_id;
                        let __ret: Result<()> = {
                            let extension_handler = get_extension_handler(
                                &__self.app_handle,
                            );
                            extension_handler
                                .account_login(AccountLoginArgs {
                                    package_name: __self.extension.package_name.clone(),
                                    account_id,
                                    login_status: true,
                                })
                                .await?;
                            Ok(())
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, account_id))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn signout<'life0, 'async_trait>(
                &'life0 mut self,
                account_id: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<()>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "signout",
                                    "app_lib::providers::extension",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/extension.rs",
                                    ),
                                    ::core::option::Option::Some(122u32),
                                    ::core::option::Option::Some(
                                        "app_lib::providers::extension",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["account_id"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&account_id) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<()>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let mut __self = self;
                        let account_id = account_id;
                        let __ret: Result<()> = {
                            let extension_handler = get_extension_handler(
                                &__self.app_handle,
                            );
                            extension_handler
                                .account_login(AccountLoginArgs {
                                    package_name: __self.extension.package_name.clone(),
                                    account_id,
                                    login_status: false,
                                })
                                .await?;
                            Ok(())
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, code))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn authorize<'life0, 'async_trait>(
                &'life0 mut self,
                code: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<()>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "authorize",
                                    "app_lib::providers::extension",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/extension.rs",
                                    ),
                                    ::core::option::Option::Some(135u32),
                                    ::core::option::Option::Some(
                                        "app_lib::providers::extension",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["code"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&code) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<()>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let mut __self = self;
                        let code = code;
                        let __ret: Result<()> = {
                            let _ = {
                                let extension_handler = get_extension_handler(
                                    &__self.app_handle,
                                );
                                let res = extension_handler
                                    .send_extra_event(ExtensionExtraEventArgs {
                                        data: ExtensionExtraEvent::OauthCallback([code]),
                                        package_name: __self.extension.package_name.clone(),
                                    })
                                    .await?;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/extension.rs:137",
                                                "app_lib::providers::extension",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/extension.rs",
                                                ),
                                                ::core::option::Option::Some(137u32),
                                                ::core::option::Option::Some(
                                                    "app_lib::providers::extension",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("parsing res {0:?} as {1}", res, "Value")
                                                                    as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                let res = serde_json::from_value::<Value>(res)?;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/extension.rs:137",
                                                "app_lib::providers::extension",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/extension.rs",
                                                ),
                                                ::core::option::Option::Some(137u32),
                                                ::core::option::Option::Some(
                                                    "app_lib::providers::extension",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("parsed res") as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                res
                            };
                            Ok(())
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, pagination))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fetch_user_playlists<'life0, 'async_trait>(
                &'life0 self,
                pagination: Pagination,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(Vec<QueryablePlaylist>, Pagination)>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "fetch_user_playlists",
                                    "app_lib::providers::extension",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/extension.rs",
                                    ),
                                    ::core::option::Option::Some(141u32),
                                    ::core::option::Option::Some(
                                        "app_lib::providers::extension",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["pagination"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&pagination) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<(Vec<QueryablePlaylist>, Pagination)>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let __self = self;
                        let pagination = pagination;
                        let __ret: Result<(Vec<QueryablePlaylist>, Pagination)> = {
                            if !__self
                                .provides
                                .contains(&ExtensionProviderScope::Playlists)
                            {
                                return Err(
                                    "Extension does not have this capability".into(),
                                );
                            }
                            if pagination.offset > 0 {
                                return Ok((
                                    ::alloc::vec::Vec::new(),
                                    pagination.next_page(),
                                ));
                            }
                            let res = {
                                let extension_handler = get_extension_handler(
                                    &__self.app_handle,
                                );
                                let res = extension_handler
                                    .send_extra_event(ExtensionExtraEventArgs {
                                        data: ExtensionExtraEvent::RequestedPlaylists([false]),
                                        package_name: __self.extension.package_name.clone(),
                                    })
                                    .await?;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/extension.rs:153",
                                                "app_lib::providers::extension",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/extension.rs",
                                                ),
                                                ::core::option::Option::Some(153u32),
                                                ::core::option::Option::Some(
                                                    "app_lib::providers::extension",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "parsing res {0:?} as {1}",
                                                                    res,
                                                                    "PlaylistReturnType",
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                let res = serde_json::from_value::<
                                    PlaylistReturnType,
                                >(res)?;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/extension.rs:153",
                                                "app_lib::providers::extension",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/extension.rs",
                                                ),
                                                ::core::option::Option::Some(153u32),
                                                ::core::option::Option::Some(
                                                    "app_lib::providers::extension",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("parsed res") as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                res
                            };
                            Ok((res.playlists, pagination.next_page()))
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, playlist_id, pagination))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn get_playlist_content<'life0, 'async_trait>(
                &'life0 self,
                playlist_id: String,
                pagination: Pagination,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(Vec<Song>, Pagination)>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "get_playlist_content",
                                    "app_lib::providers::extension",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/extension.rs",
                                    ),
                                    ::core::option::Option::Some(160u32),
                                    ::core::option::Option::Some(
                                        "app_lib::providers::extension",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["playlist_id", "pagination"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&playlist_id) as &dyn Value,
                                                    ),
                                                ),
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&pagination) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<(Vec<Song>, Pagination)>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let __self = self;
                        let playlist_id = playlist_id;
                        let pagination = pagination;
                        let __ret: Result<(Vec<Song>, Pagination)> = {
                            if !__self
                                .provides
                                .contains(&ExtensionProviderScope::PlaylistSongs)
                            {
                                return Err(
                                    "Extension does not have this capability".into(),
                                );
                            }
                            if pagination.offset > 0 {
                                return Ok((
                                    ::alloc::vec::Vec::new(),
                                    pagination.next_page(),
                                ));
                            }
                            let res = {
                                let extension_handler = get_extension_handler(
                                    &__self.app_handle,
                                );
                                let res = extension_handler
                                    .send_extra_event(ExtensionExtraEventArgs {
                                        data: ExtensionExtraEvent::RequestedPlaylistSongs(
                                            playlist_id,
                                            false,
                                            pagination.token.clone(),
                                        ),
                                        package_name: __self.extension.package_name.clone(),
                                    })
                                    .await?;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/extension.rs:177",
                                                "app_lib::providers::extension",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/extension.rs",
                                                ),
                                                ::core::option::Option::Some(177u32),
                                                ::core::option::Option::Some(
                                                    "app_lib::providers::extension",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "parsing res {0:?} as {1}",
                                                                    res,
                                                                    "SongsWithPageTokenReturnType",
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                let res = serde_json::from_value::<
                                    SongsWithPageTokenReturnType,
                                >(res)?;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/extension.rs:177",
                                                "app_lib::providers::extension",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/extension.rs",
                                                ),
                                                ::core::option::Option::Some(177u32),
                                                ::core::option::Option::Some(
                                                    "app_lib::providers::extension",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("parsed res") as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                res
                            };
                            Ok((
                                res.songs,
                                pagination
                                    .next_page_wtoken(
                                        res
                                            .next_page_token
                                            .map(|v| serde_json::from_value(v).unwrap()),
                                    ),
                            ))
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, song, _player))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn get_playback_url<'life0, 'async_trait>(
                &'life0 self,
                song: Song,
                _player: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<String>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "get_playback_url",
                                    "app_lib::providers::extension",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/extension.rs",
                                    ),
                                    ::core::option::Option::Some(195u32),
                                    ::core::option::Option::Some(
                                        "app_lib::providers::extension",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["song", "_player"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&song) as &dyn Value,
                                                    ),
                                                ),
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&_player) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<String>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let __self = self;
                        let song = song;
                        let _player = _player;
                        let __ret: Result<String> = {
                            if !__self
                                .provides
                                .contains(&ExtensionProviderScope::PlaybackDetails)
                            {
                                return Err(
                                    "Extension does not have this capability".into(),
                                );
                            }
                            if let Some(playback_url) = song.song.playback_url.clone() {
                                if playback_url.starts_with("extension://") {
                                    let res = {
                                        let extension_handler = get_extension_handler(
                                            &__self.app_handle,
                                        );
                                        let res = extension_handler
                                            .send_extra_event(ExtensionExtraEventArgs {
                                                data: ExtensionExtraEvent::CustomRequest([
                                                    playback_url.clone(),
                                                ]),
                                                package_name: __self.extension.package_name.clone(),
                                            })
                                            .await?;
                                        {
                                            use ::tracing::__macro_support::Callsite as _;
                                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                                static META: ::tracing::Metadata<'static> = {
                                                    ::tracing_core::metadata::Metadata::new(
                                                        "event src-tauri/src/providers/extension.rs:206",
                                                        "app_lib::providers::extension",
                                                        ::tracing::Level::INFO,
                                                        ::core::option::Option::Some(
                                                            "src-tauri/src/providers/extension.rs",
                                                        ),
                                                        ::core::option::Option::Some(206u32),
                                                        ::core::option::Option::Some(
                                                            "app_lib::providers::extension",
                                                        ),
                                                        ::tracing_core::field::FieldSet::new(
                                                            &["message"],
                                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                        ),
                                                        ::tracing::metadata::Kind::EVENT,
                                                    )
                                                };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                            let enabled = ::tracing::Level::INFO
                                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                                && ::tracing::Level::INFO
                                                    <= ::tracing::level_filters::LevelFilter::current()
                                                && {
                                                    let interest = __CALLSITE.interest();
                                                    !interest.is_never()
                                                        && ::tracing::__macro_support::__is_enabled(
                                                            __CALLSITE.metadata(),
                                                            interest,
                                                        )
                                                };
                                            if enabled {
                                                (|value_set: ::tracing::field::ValueSet| {
                                                    let meta = __CALLSITE.metadata();
                                                    ::tracing::Event::dispatch(meta, &value_set);
                                                })({
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &::core::iter::Iterator::next(&mut iter)
                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                    ::core::option::Option::Some(
                                                                        &format_args!(
                                                                            "parsing res {0:?} as {1}",
                                                                            res,
                                                                            "CustomRequestReturnType",
                                                                        ) as &dyn Value,
                                                                    ),
                                                                ),
                                                            ],
                                                        )
                                                });
                                            } else {
                                            }
                                        };
                                        let res = serde_json::from_value::<
                                            CustomRequestReturnType,
                                        >(res)?;
                                        {
                                            use ::tracing::__macro_support::Callsite as _;
                                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                                static META: ::tracing::Metadata<'static> = {
                                                    ::tracing_core::metadata::Metadata::new(
                                                        "event src-tauri/src/providers/extension.rs:206",
                                                        "app_lib::providers::extension",
                                                        ::tracing::Level::INFO,
                                                        ::core::option::Option::Some(
                                                            "src-tauri/src/providers/extension.rs",
                                                        ),
                                                        ::core::option::Option::Some(206u32),
                                                        ::core::option::Option::Some(
                                                            "app_lib::providers::extension",
                                                        ),
                                                        ::tracing_core::field::FieldSet::new(
                                                            &["message"],
                                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                        ),
                                                        ::tracing::metadata::Kind::EVENT,
                                                    )
                                                };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                            let enabled = ::tracing::Level::INFO
                                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                                && ::tracing::Level::INFO
                                                    <= ::tracing::level_filters::LevelFilter::current()
                                                && {
                                                    let interest = __CALLSITE.interest();
                                                    !interest.is_never()
                                                        && ::tracing::__macro_support::__is_enabled(
                                                            __CALLSITE.metadata(),
                                                            interest,
                                                        )
                                                };
                                            if enabled {
                                                (|value_set: ::tracing::field::ValueSet| {
                                                    let meta = __CALLSITE.metadata();
                                                    ::tracing::Event::dispatch(meta, &value_set);
                                                })({
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &::core::iter::Iterator::next(&mut iter)
                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                    ::core::option::Option::Some(
                                                                        &format_args!("parsed res") as &dyn Value,
                                                                    ),
                                                                ),
                                                            ],
                                                        )
                                                });
                                            } else {
                                            }
                                        };
                                        res
                                    };
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "event src-tauri/src/providers/extension.rs:211",
                                                    "app_lib::providers::extension",
                                                    ::tracing::Level::INFO,
                                                    ::core::option::Option::Some(
                                                        "src-tauri/src/providers/extension.rs",
                                                    ),
                                                    ::core::option::Option::Some(211u32),
                                                    ::core::option::Option::Some(
                                                        "app_lib::providers::extension",
                                                    ),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["message"],
                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::EVENT,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let enabled = ::tracing::Level::INFO
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::tracing::Level::INFO
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                let interest = __CALLSITE.interest();
                                                !interest.is_never()
                                                    && ::tracing::__macro_support::__is_enabled(
                                                        __CALLSITE.metadata(),
                                                        interest,
                                                    )
                                            };
                                        if enabled {
                                            (|value_set: ::tracing::field::ValueSet| {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                            })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::core::iter::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::core::option::Option::Some(
                                                                    &format_args!("Got custom request {0:?}", res) as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            });
                                        } else {
                                        }
                                    };
                                    return Ok(res.redirect_url.unwrap_or(playback_url));
                                }
                            }
                            let res = {
                                let extension_handler = get_extension_handler(
                                    &__self.app_handle,
                                );
                                let res = extension_handler
                                    .send_extra_event(ExtensionExtraEventArgs {
                                        data: ExtensionExtraEvent::PlaybackDetailsRequested([song]),
                                        package_name: __self.extension.package_name.clone(),
                                    })
                                    .await?;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/extension.rs:216",
                                                "app_lib::providers::extension",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/extension.rs",
                                                ),
                                                ::core::option::Option::Some(216u32),
                                                ::core::option::Option::Some(
                                                    "app_lib::providers::extension",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "parsing res {0:?} as {1}",
                                                                    res,
                                                                    "PlaybackDetailsReturnType",
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                let res = serde_json::from_value::<
                                    PlaybackDetailsReturnType,
                                >(res)?;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/extension.rs:216",
                                                "app_lib::providers::extension",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/extension.rs",
                                                ),
                                                ::core::option::Option::Some(216u32),
                                                ::core::option::Option::Some(
                                                    "app_lib::providers::extension",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("parsed res") as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                res
                            };
                            Ok(res.url)
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, term))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn search<'life0, 'async_trait>(
                &'life0 self,
                term: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<SearchResult>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "search",
                                    "app_lib::providers::extension",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/extension.rs",
                                    ),
                                    ::core::option::Option::Some(225u32),
                                    ::core::option::Option::Some(
                                        "app_lib::providers::extension",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["term"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&term) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<SearchResult>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let __self = self;
                        let term = term;
                        let __ret: Result<SearchResult> = {
                            if !__self.provides.contains(&ExtensionProviderScope::Search)
                            {
                                return Err(
                                    "Extension does not have this capability".into(),
                                );
                            }
                            let res = {
                                let extension_handler = get_extension_handler(
                                    &__self.app_handle,
                                );
                                let res = extension_handler
                                    .send_extra_event(ExtensionExtraEventArgs {
                                        data: ExtensionExtraEvent::RequestedSearchResult([term]),
                                        package_name: __self.extension.package_name.clone(),
                                    })
                                    .await?;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/extension.rs:231",
                                                "app_lib::providers::extension",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/extension.rs",
                                                ),
                                                ::core::option::Option::Some(231u32),
                                                ::core::option::Option::Some(
                                                    "app_lib::providers::extension",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "parsing res {0:?} as {1}",
                                                                    res,
                                                                    "SearchReturnType",
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                let res = serde_json::from_value::<SearchReturnType>(res)?;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/extension.rs:231",
                                                "app_lib::providers::extension",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/extension.rs",
                                                ),
                                                ::core::option::Option::Some(231u32),
                                                ::core::option::Option::Some(
                                                    "app_lib::providers::extension",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("parsed res") as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                res
                            };
                            Ok(SearchResult {
                                songs: res.songs,
                                artists: res.artists,
                                playlists: res.playlists,
                                albums: res.albums,
                                genres: ::alloc::vec::Vec::new(),
                            })
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, url))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn match_url<'life0, 'async_trait>(
                &'life0 self,
                url: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<bool>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "match_url",
                                    "app_lib::providers::extension",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/extension.rs",
                                    ),
                                    ::core::option::Option::Some(246u32),
                                    ::core::option::Option::Some(
                                        "app_lib::providers::extension",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["url"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&url) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<bool>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let __self = self;
                        let url = url;
                        let __ret: Result<bool> = {
                            let res = {
                                let extension_handler = get_extension_handler(
                                    &__self.app_handle,
                                );
                                let res = extension_handler
                                    .send_extra_event(ExtensionExtraEventArgs {
                                        data: ExtensionExtraEvent::RequestedPlaylistFromURL(
                                            url,
                                            false,
                                        ),
                                        package_name: __self.extension.package_name.clone(),
                                    })
                                    .await?;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/extension.rs:248",
                                                "app_lib::providers::extension",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/extension.rs",
                                                ),
                                                ::core::option::Option::Some(248u32),
                                                ::core::option::Option::Some(
                                                    "app_lib::providers::extension",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "parsing res {0:?} as {1}",
                                                                    res,
                                                                    "PlaylistAndSongsReturnType",
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                let res = serde_json::from_value::<
                                    PlaylistAndSongsReturnType,
                                >(res)?;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/extension.rs:248",
                                                "app_lib::providers::extension",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/extension.rs",
                                                ),
                                                ::core::option::Option::Some(248u32),
                                                ::core::option::Option::Some(
                                                    "app_lib::providers::extension",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("parsed res") as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                res
                            };
                            Ok(res.playlist.is_some())
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, url))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn playlist_from_url<'life0, 'async_trait>(
                &'life0 self,
                url: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<QueryablePlaylist>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "playlist_from_url",
                                    "app_lib::providers::extension",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/extension.rs",
                                    ),
                                    ::core::option::Option::Some(257u32),
                                    ::core::option::Option::Some(
                                        "app_lib::providers::extension",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["url"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&url) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<QueryablePlaylist>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let __self = self;
                        let url = url;
                        let __ret: Result<QueryablePlaylist> = {
                            if !__self
                                .provides
                                .contains(&ExtensionProviderScope::PlaylistFromUrl)
                            {
                                return Err(
                                    "Extension does not have this capability".into(),
                                );
                            }
                            let res = {
                                let extension_handler = get_extension_handler(
                                    &__self.app_handle,
                                );
                                let res = extension_handler
                                    .send_extra_event(ExtensionExtraEventArgs {
                                        data: ExtensionExtraEvent::RequestedPlaylistFromURL(
                                            url,
                                            false,
                                        ),
                                        package_name: __self.extension.package_name.clone(),
                                    })
                                    .await?;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/extension.rs:266",
                                                "app_lib::providers::extension",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/extension.rs",
                                                ),
                                                ::core::option::Option::Some(266u32),
                                                ::core::option::Option::Some(
                                                    "app_lib::providers::extension",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "parsing res {0:?} as {1}",
                                                                    res,
                                                                    "PlaylistAndSongsReturnType",
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                let res = serde_json::from_value::<
                                    PlaylistAndSongsReturnType,
                                >(res)?;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/extension.rs:266",
                                                "app_lib::providers::extension",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/extension.rs",
                                                ),
                                                ::core::option::Option::Some(266u32),
                                                ::core::option::Option::Some(
                                                    "app_lib::providers::extension",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("parsed res") as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                res
                            };
                            if let Some(playlist) = res.playlist {
                                return Ok(playlist);
                            }
                            Err("Playlist not found".into())
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, url))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn song_from_url<'life0, 'async_trait>(
                &'life0 self,
                url: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<Song>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "song_from_url",
                                    "app_lib::providers::extension",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/extension.rs",
                                    ),
                                    ::core::option::Option::Some(278u32),
                                    ::core::option::Option::Some(
                                        "app_lib::providers::extension",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["url"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&url) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<Song>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let __self = self;
                        let url = url;
                        let __ret: Result<Song> = {
                            if !__self
                                .provides
                                .contains(&ExtensionProviderScope::SongFromUrl)
                            {
                                return Err(
                                    "Extension does not have this capability".into(),
                                );
                            }
                            let res = {
                                let extension_handler = get_extension_handler(
                                    &__self.app_handle,
                                );
                                let res = extension_handler
                                    .send_extra_event(ExtensionExtraEventArgs {
                                        data: ExtensionExtraEvent::RequestedSongFromURL(url, false),
                                        package_name: __self.extension.package_name.clone(),
                                    })
                                    .await?;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/extension.rs:284",
                                                "app_lib::providers::extension",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/extension.rs",
                                                ),
                                                ::core::option::Option::Some(284u32),
                                                ::core::option::Option::Some(
                                                    "app_lib::providers::extension",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "parsing res {0:?} as {1}",
                                                                    res,
                                                                    "SongReturnType",
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                let res = serde_json::from_value::<SongReturnType>(res)?;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/extension.rs:284",
                                                "app_lib::providers::extension",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/extension.rs",
                                                ),
                                                ::core::option::Option::Some(284u32),
                                                ::core::option::Option::Some(
                                                    "app_lib::providers::extension",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("parsed res") as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                res
                            };
                            if let Some(song) = res.song {
                                return Ok(song);
                            }
                            Err("Song not found".into())
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn get_suggestions<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<Vec<Song>>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "get_suggestions",
                                    "app_lib::providers::extension",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/extension.rs",
                                    ),
                                    ::core::option::Option::Some(297u32),
                                    ::core::option::Option::Some(
                                        "app_lib::providers::extension",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<Vec<Song>>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let __self = self;
                        let __ret: Result<Vec<Song>> = {
                            if !__self
                                .provides
                                .contains(&ExtensionProviderScope::Recommendations)
                            {
                                return Err(
                                    "Extension does not have this capability".into(),
                                );
                            }
                            let res = {
                                let extension_handler = get_extension_handler(
                                    &__self.app_handle,
                                );
                                let res = extension_handler
                                    .send_extra_event(ExtensionExtraEventArgs {
                                        data: ExtensionExtraEvent::RequestedRecommendations,
                                        package_name: __self.extension.package_name.clone(),
                                    })
                                    .await?;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/extension.rs:306",
                                                "app_lib::providers::extension",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/extension.rs",
                                                ),
                                                ::core::option::Option::Some(306u32),
                                                ::core::option::Option::Some(
                                                    "app_lib::providers::extension",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "parsing res {0:?} as {1}",
                                                                    res,
                                                                    "RecommendationsReturnType",
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                let res = serde_json::from_value::<
                                    RecommendationsReturnType,
                                >(res)?;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/extension.rs:306",
                                                "app_lib::providers::extension",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/extension.rs",
                                                ),
                                                ::core::option::Option::Some(306u32),
                                                ::core::option::Option::Some(
                                                    "app_lib::providers::extension",
                                                ),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("parsed res") as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                res
                            };
                            Ok(res.songs)
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
        }
    }
    pub mod handler {
        use futures::{
            channel::mpsc::{unbounded, UnboundedReceiver, UnboundedSender},
            future::join_all, lock::Mutex, StreamExt,
        };
        use serde_json::Value;
        use std::{collections::HashMap, sync::Arc};
        use database::cache::CacheHolder;
        use macros::{generate_command_async, generate_command_async_cached};
        use tauri::{
            async_runtime::{self, block_on},
            AppHandle, Emitter, State,
        };
        use types::{
            entities::{QueryablePlaylist, SearchResult},
            errors::{MoosyncError, Result},
            providers::generic::{GenericProvider, Pagination, ProviderStatus},
            songs::Song,
        };
        use crate::{
            extensions::get_extension_handler, providers::extension::ExtensionProvider,
        };
        use super::{spotify::SpotifyProvider, youtube::YoutubeProvider};
        pub struct ProviderHandler {
            provider_store: Mutex<HashMap<String, Arc<Mutex<dyn GenericProvider>>>>,
            app_handle: AppHandle,
            status_tx: UnboundedSender<ProviderStatus>,
            provider_status: Arc<Mutex<HashMap<String, ProviderStatus>>>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ProviderHandler {
            #[tracing::instrument(level = "trace", skip(self, f))]
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "ProviderHandler",
                    "provider_store",
                    &self.provider_store,
                    "app_handle",
                    &self.app_handle,
                    "status_tx",
                    &self.status_tx,
                    "provider_status",
                    &&self.provider_status,
                )
            }
        }
        impl ProviderHandler {
            #[tracing::instrument(level = "trace", skip(app))]
            pub fn new(app: AppHandle) -> Self {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "new",
                                        "app_lib::providers::handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/handler.rs",
                                        ),
                                        ::core::option::Option::Some(97u32),
                                        ::core::option::Option::Some("app_lib::providers::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Self = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            let (status_tx, status_rx) = unbounded();
                            let store = Self {
                                app_handle: app.clone(),
                                provider_store: Default::default(),
                                status_tx,
                                provider_status: Default::default(),
                            };
                            store.listen_status_changes(status_rx);
                            let mut provider_store = block_on(
                                store.provider_store.lock(),
                            );
                            let spotify_provider = SpotifyProvider::new(
                                app.clone(),
                                store.status_tx.clone(),
                            );
                            provider_store
                                .insert(
                                    spotify_provider.key(),
                                    Arc::new(Mutex::new(spotify_provider)),
                                );
                            let youtube_provider: YoutubeProvider = YoutubeProvider::new(
                                app,
                                store.status_tx.clone(),
                            );
                            provider_store
                                .insert(
                                    youtube_provider.key(),
                                    Arc::new(Mutex::new(youtube_provider)),
                                );
                            drop(provider_store);
                            store
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, status_rx))]
            pub fn listen_status_changes(
                &self,
                status_rx: UnboundedReceiver<ProviderStatus>,
            ) {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "listen_status_changes",
                                        "app_lib::providers::handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/handler.rs",
                                        ),
                                        ::core::option::Option::Some(126u32),
                                        ::core::option::Option::Some("app_lib::providers::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: () = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            let status_rx = Arc::new(Mutex::new(status_rx));
                            let provider_status = self.provider_status.clone();
                            let app_handle = self.app_handle.clone();
                            tauri::async_runtime::spawn(async move {
                                let status_rx = status_rx.clone();
                                let mut status_rx = status_rx.lock().await;
                                let provider_status = provider_status.clone();
                                let app_handle = app_handle.clone();
                                while let Some(status) = status_rx.next().await {
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "event src-tauri/src/providers/handler.rs:138",
                                                    "app_lib::providers::handler",
                                                    ::tracing::Level::INFO,
                                                    ::core::option::Option::Some(
                                                        "src-tauri/src/providers/handler.rs",
                                                    ),
                                                    ::core::option::Option::Some(138u32),
                                                    ::core::option::Option::Some("app_lib::providers::handler"),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["message"],
                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::EVENT,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let enabled = ::tracing::Level::INFO
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::tracing::Level::INFO
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                let interest = __CALLSITE.interest();
                                                !interest.is_never()
                                                    && ::tracing::__macro_support::__is_enabled(
                                                        __CALLSITE.metadata(),
                                                        interest,
                                                    )
                                            };
                                        if enabled {
                                            (|value_set: ::tracing::field::ValueSet| {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                            })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::core::iter::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::core::option::Option::Some(
                                                                    &format_args!("Got provider status update {0:?}", status)
                                                                        as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            });
                                        } else {
                                        }
                                    };
                                    let mut provider_status = provider_status.lock().await;
                                    provider_status.insert(status.key.clone(), status);
                                    let res = app_handle
                                        .emit("provider-status-update", provider_status.clone());
                                    if let Err(e) = res {
                                        {
                                            use ::tracing::__macro_support::Callsite as _;
                                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                                static META: ::tracing::Metadata<'static> = {
                                                    ::tracing_core::metadata::Metadata::new(
                                                        "event src-tauri/src/providers/handler.rs:143",
                                                        "app_lib::providers::handler",
                                                        ::tracing::Level::ERROR,
                                                        ::core::option::Option::Some(
                                                            "src-tauri/src/providers/handler.rs",
                                                        ),
                                                        ::core::option::Option::Some(143u32),
                                                        ::core::option::Option::Some("app_lib::providers::handler"),
                                                        ::tracing_core::field::FieldSet::new(
                                                            &["message"],
                                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                        ),
                                                        ::tracing::metadata::Kind::EVENT,
                                                    )
                                                };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                            let enabled = ::tracing::Level::ERROR
                                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                                && ::tracing::Level::ERROR
                                                    <= ::tracing::level_filters::LevelFilter::current()
                                                && {
                                                    let interest = __CALLSITE.interest();
                                                    !interest.is_never()
                                                        && ::tracing::__macro_support::__is_enabled(
                                                            __CALLSITE.metadata(),
                                                            interest,
                                                        )
                                                };
                                            if enabled {
                                                (|value_set: ::tracing::field::ValueSet| {
                                                    let meta = __CALLSITE.metadata();
                                                    ::tracing::Event::dispatch(meta, &value_set);
                                                })({
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &::core::iter::Iterator::next(&mut iter)
                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                    ::core::option::Option::Some(
                                                                        &format_args!("Error emitting status update: {0:?}", e)
                                                                            as &dyn Value,
                                                                    ),
                                                                ),
                                                            ],
                                                        )
                                                });
                                            } else {
                                            }
                                        };
                                    }
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "event src-tauri/src/providers/handler.rs:145",
                                                    "app_lib::providers::handler",
                                                    ::tracing::Level::INFO,
                                                    ::core::option::Option::Some(
                                                        "src-tauri/src/providers/handler.rs",
                                                    ),
                                                    ::core::option::Option::Some(145u32),
                                                    ::core::option::Option::Some("app_lib::providers::handler"),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["message", "provider_status"],
                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::EVENT,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let enabled = ::tracing::Level::INFO
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::tracing::Level::INFO
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                let interest = __CALLSITE.interest();
                                                !interest.is_never()
                                                    && ::tracing::__macro_support::__is_enabled(
                                                        __CALLSITE.metadata(),
                                                        interest,
                                                    )
                                            };
                                        if enabled {
                                            (|value_set: ::tracing::field::ValueSet| {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                            })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::core::iter::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::core::option::Option::Some(
                                                                    &format_args!("Emitted status update") as &dyn Value,
                                                                ),
                                                            ),
                                                            (
                                                                &::core::iter::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::core::option::Option::Some(
                                                                    &debug(&provider_status) as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            });
                                        } else {
                                        }
                                    };
                                }
                            });
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self))]
            pub async fn discover_provider_extensions(&self) -> Result<()> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "discover_provider_extensions",
                                "app_lib::providers::handler",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/providers/handler.rs",
                                ),
                                ::core::option::Option::Some(150u32),
                                ::core::option::Option::Some("app_lib::providers::handler"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<()> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        let ext_handler = get_extension_handler(&self.app_handle);
                        let extensions_res = ext_handler
                            .get_installed_extensions()
                            .await?;
                        for ext_runner in extensions_res.values() {
                            for extension in ext_runner {
                                let provides = ext_handler
                                    .get_provider_scopes(extension.package_name.clone().into())
                                    .await;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:159",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(159u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "Got provider scopes from {0} {1:?}",
                                                                    extension.package_name,
                                                                    provides,
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                if let Ok(provides) = provides {
                                    if provides.is_empty() {
                                        continue;
                                    }
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "event src-tauri/src/providers/handler.rs:169",
                                                    "app_lib::providers::handler",
                                                    ::tracing::Level::INFO,
                                                    ::core::option::Option::Some(
                                                        "src-tauri/src/providers/handler.rs",
                                                    ),
                                                    ::core::option::Option::Some(169u32),
                                                    ::core::option::Option::Some("app_lib::providers::handler"),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["message"],
                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::EVENT,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let enabled = ::tracing::Level::INFO
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::tracing::Level::INFO
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                let interest = __CALLSITE.interest();
                                                !interest.is_never()
                                                    && ::tracing::__macro_support::__is_enabled(
                                                        __CALLSITE.metadata(),
                                                        interest,
                                                    )
                                            };
                                        if enabled {
                                            (|value_set: ::tracing::field::ValueSet| {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                            })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::core::iter::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::core::option::Option::Some(
                                                                    &format_args!(
                                                                        "Inserting extension provider {0:?} {1:?}",
                                                                        extension,
                                                                        provides,
                                                                    ) as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            });
                                        } else {
                                        }
                                    };
                                    let mut provider = ExtensionProvider::new(
                                        extension.clone(),
                                        provides,
                                        self.app_handle.clone(),
                                        self.status_tx.clone(),
                                    );
                                    let mut provider_store = self.provider_store.lock().await;
                                    provider_store.remove(provider.key().as_str());
                                    provider_store
                                        .insert(
                                            provider.key(),
                                            Arc::new(Mutex::new(provider.clone())),
                                        );
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "event src-tauri/src/providers/handler.rs:185",
                                                    "app_lib::providers::handler",
                                                    ::tracing::Level::INFO,
                                                    ::core::option::Option::Some(
                                                        "src-tauri/src/providers/handler.rs",
                                                    ),
                                                    ::core::option::Option::Some(185u32),
                                                    ::core::option::Option::Some("app_lib::providers::handler"),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["message"],
                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::EVENT,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let enabled = ::tracing::Level::INFO
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::tracing::Level::INFO
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                let interest = __CALLSITE.interest();
                                                !interest.is_never()
                                                    && ::tracing::__macro_support::__is_enabled(
                                                        __CALLSITE.metadata(),
                                                        interest,
                                                    )
                                            };
                                        if enabled {
                                            (|value_set: ::tracing::field::ValueSet| {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                            })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::core::iter::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::core::option::Option::Some(
                                                                    &format_args!("provider_store: {0:?}", provider_store)
                                                                        as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            });
                                        } else {
                                        }
                                    };
                                    async_runtime::spawn(async move {
                                        let res = provider.initialize().await;
                                        if let Err(err) = res {
                                            {
                                                use ::tracing::__macro_support::Callsite as _;
                                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                                    static META: ::tracing::Metadata<'static> = {
                                                        ::tracing_core::metadata::Metadata::new(
                                                            "event src-tauri/src/providers/handler.rs:189",
                                                            "app_lib::providers::handler",
                                                            ::tracing::Level::ERROR,
                                                            ::core::option::Option::Some(
                                                                "src-tauri/src/providers/handler.rs",
                                                            ),
                                                            ::core::option::Option::Some(189u32),
                                                            ::core::option::Option::Some("app_lib::providers::handler"),
                                                            ::tracing_core::field::FieldSet::new(
                                                                &["message"],
                                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                            ),
                                                            ::tracing::metadata::Kind::EVENT,
                                                        )
                                                    };
                                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                                };
                                                let enabled = ::tracing::Level::ERROR
                                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                                    && ::tracing::Level::ERROR
                                                        <= ::tracing::level_filters::LevelFilter::current()
                                                    && {
                                                        let interest = __CALLSITE.interest();
                                                        !interest.is_never()
                                                            && ::tracing::__macro_support::__is_enabled(
                                                                __CALLSITE.metadata(),
                                                                interest,
                                                            )
                                                    };
                                                if enabled {
                                                    (|value_set: ::tracing::field::ValueSet| {
                                                        let meta = __CALLSITE.metadata();
                                                        ::tracing::Event::dispatch(meta, &value_set);
                                                    })({
                                                        #[allow(unused_imports)]
                                                        use ::tracing::field::{debug, display, Value};
                                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                                        __CALLSITE
                                                            .metadata()
                                                            .fields()
                                                            .value_set(
                                                                &[
                                                                    (
                                                                        &::core::iter::Iterator::next(&mut iter)
                                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                                        ::core::option::Option::Some(
                                                                            &format_args!(
                                                                                "Error initializing extension provider {0}: {1:?}",
                                                                                provider.key(),
                                                                                err,
                                                                            ) as &dyn Value,
                                                                        ),
                                                                    ),
                                                                ],
                                                            )
                                                    });
                                                } else {
                                                }
                                            };
                                        }
                                    });
                                }
                            }
                            self.app_handle.emit("providers-updated", Value::Null)?;
                        }
                        Ok(())
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
            #[tracing::instrument(level = "trace", skip(self, key))]
            pub async fn initialize_provider(&self, key: String) {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "initialize_provider",
                                "app_lib::providers::handler",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/providers/handler.rs",
                                ),
                                ::core::option::Option::Some(203u32),
                                ::core::option::Option::Some("app_lib::providers::handler"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: () = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        let provider_store = self.provider_store.lock().await;
                        let provider = provider_store.get(&key);
                        if let Some(provider) = provider {
                            let mut provider = provider.lock().await;
                            if let Err(e) = provider.initialize().await {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:210",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::ERROR,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(210u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::ERROR
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "Error initializing provider {0}: {1:?}",
                                                                    provider.key(),
                                                                    e,
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                        }
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
            #[tracing::instrument(level = "trace", skip(self))]
            pub async fn initialize_all_providers(&self) -> Result<()> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "initialize_all_providers",
                                "app_lib::providers::handler",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/providers/handler.rs",
                                ),
                                ::core::option::Option::Some(215u32),
                                ::core::option::Option::Some("app_lib::providers::handler"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<()> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        let mut fut = ::alloc::vec::Vec::new();
                        let provider_store = self.provider_store.lock().await;
                        for (_, provider) in provider_store.iter() {
                            let provider = provider.clone();
                            fut.push(
                                Box::pin(async move {
                                    let mut provider = provider.lock().await;
                                    {
                                        use ::tracing::__macro_support::Callsite as _;
                                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                            static META: ::tracing::Metadata<'static> = {
                                                ::tracing_core::metadata::Metadata::new(
                                                    "event src-tauri/src/providers/handler.rs:223",
                                                    "app_lib::providers::handler",
                                                    ::tracing::Level::INFO,
                                                    ::core::option::Option::Some(
                                                        "src-tauri/src/providers/handler.rs",
                                                    ),
                                                    ::core::option::Option::Some(223u32),
                                                    ::core::option::Option::Some("app_lib::providers::handler"),
                                                    ::tracing_core::field::FieldSet::new(
                                                        &["message"],
                                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                    ),
                                                    ::tracing::metadata::Kind::EVENT,
                                                )
                                            };
                                            ::tracing::callsite::DefaultCallsite::new(&META)
                                        };
                                        let enabled = ::tracing::Level::INFO
                                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                            && ::tracing::Level::INFO
                                                <= ::tracing::level_filters::LevelFilter::current()
                                            && {
                                                let interest = __CALLSITE.interest();
                                                !interest.is_never()
                                                    && ::tracing::__macro_support::__is_enabled(
                                                        __CALLSITE.metadata(),
                                                        interest,
                                                    )
                                            };
                                        if enabled {
                                            (|value_set: ::tracing::field::ValueSet| {
                                                let meta = __CALLSITE.metadata();
                                                ::tracing::Event::dispatch(meta, &value_set);
                                            })({
                                                #[allow(unused_imports)]
                                                use ::tracing::field::{debug, display, Value};
                                                let mut iter = __CALLSITE.metadata().fields().iter();
                                                __CALLSITE
                                                    .metadata()
                                                    .fields()
                                                    .value_set(
                                                        &[
                                                            (
                                                                &::core::iter::Iterator::next(&mut iter)
                                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                                ::core::option::Option::Some(
                                                                    &format_args!("Initializing {0}", provider.key())
                                                                        as &dyn Value,
                                                                ),
                                                            ),
                                                        ],
                                                    )
                                            });
                                        } else {
                                        }
                                    };
                                    let err = provider.initialize().await;
                                    if let Err(err) = err {
                                        {
                                            use ::tracing::__macro_support::Callsite as _;
                                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                                static META: ::tracing::Metadata<'static> = {
                                                    ::tracing_core::metadata::Metadata::new(
                                                        "event src-tauri/src/providers/handler.rs:226",
                                                        "app_lib::providers::handler",
                                                        ::tracing::Level::ERROR,
                                                        ::core::option::Option::Some(
                                                            "src-tauri/src/providers/handler.rs",
                                                        ),
                                                        ::core::option::Option::Some(226u32),
                                                        ::core::option::Option::Some("app_lib::providers::handler"),
                                                        ::tracing_core::field::FieldSet::new(
                                                            &["message"],
                                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                        ),
                                                        ::tracing::metadata::Kind::EVENT,
                                                    )
                                                };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                            let enabled = ::tracing::Level::ERROR
                                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                                && ::tracing::Level::ERROR
                                                    <= ::tracing::level_filters::LevelFilter::current()
                                                && {
                                                    let interest = __CALLSITE.interest();
                                                    !interest.is_never()
                                                        && ::tracing::__macro_support::__is_enabled(
                                                            __CALLSITE.metadata(),
                                                            interest,
                                                        )
                                                };
                                            if enabled {
                                                (|value_set: ::tracing::field::ValueSet| {
                                                    let meta = __CALLSITE.metadata();
                                                    ::tracing::Event::dispatch(meta, &value_set);
                                                })({
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &::core::iter::Iterator::next(&mut iter)
                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                    ::core::option::Option::Some(
                                                                        &format_args!(
                                                                            "Error initializing {0}: {1:?}",
                                                                            provider.key(),
                                                                            err,
                                                                        ) as &dyn Value,
                                                                    ),
                                                                ),
                                                            ],
                                                        )
                                                });
                                            } else {
                                            }
                                        };
                                    } else {
                                        {
                                            use ::tracing::__macro_support::Callsite as _;
                                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                                static META: ::tracing::Metadata<'static> = {
                                                    ::tracing_core::metadata::Metadata::new(
                                                        "event src-tauri/src/providers/handler.rs:228",
                                                        "app_lib::providers::handler",
                                                        ::tracing::Level::INFO,
                                                        ::core::option::Option::Some(
                                                            "src-tauri/src/providers/handler.rs",
                                                        ),
                                                        ::core::option::Option::Some(228u32),
                                                        ::core::option::Option::Some("app_lib::providers::handler"),
                                                        ::tracing_core::field::FieldSet::new(
                                                            &["message"],
                                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                        ),
                                                        ::tracing::metadata::Kind::EVENT,
                                                    )
                                                };
                                                ::tracing::callsite::DefaultCallsite::new(&META)
                                            };
                                            let enabled = ::tracing::Level::INFO
                                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                                && ::tracing::Level::INFO
                                                    <= ::tracing::level_filters::LevelFilter::current()
                                                && {
                                                    let interest = __CALLSITE.interest();
                                                    !interest.is_never()
                                                        && ::tracing::__macro_support::__is_enabled(
                                                            __CALLSITE.metadata(),
                                                            interest,
                                                        )
                                                };
                                            if enabled {
                                                (|value_set: ::tracing::field::ValueSet| {
                                                    let meta = __CALLSITE.metadata();
                                                    ::tracing::Event::dispatch(meta, &value_set);
                                                })({
                                                    #[allow(unused_imports)]
                                                    use ::tracing::field::{debug, display, Value};
                                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                                    __CALLSITE
                                                        .metadata()
                                                        .fields()
                                                        .value_set(
                                                            &[
                                                                (
                                                                    &::core::iter::Iterator::next(&mut iter)
                                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                                    ::core::option::Option::Some(
                                                                        &format_args!("Initialized {0}", provider.key())
                                                                            as &dyn Value,
                                                                    ),
                                                                ),
                                                            ],
                                                        )
                                                });
                                            } else {
                                            }
                                        };
                                    }
                                }),
                            );
                        }
                        join_all(fut).await;
                        Ok(())
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
            #[tracing::instrument(level = "trace", skip(self, id))]
            pub async fn get_provider_key_by_id(&self, id: String) -> Result<String> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "get_provider_key_by_id",
                                "app_lib::providers::handler",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/providers/handler.rs",
                                ),
                                ::core::option::Option::Some(236u32),
                                ::core::option::Option::Some("app_lib::providers::handler"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<String> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        let provider_store = self.provider_store.lock().await;
                        for (key, provider) in provider_store.iter() {
                            let provider = provider.lock().await;
                            if provider.match_id(id.clone()) {
                                return Ok(key.clone());
                            }
                        }
                        Err(
                            ::alloc::__export::must_use({
                                    let res = ::alloc::fmt::format(
                                        format_args!("Provider for id {0} not found", id),
                                    );
                                    res
                                })
                                .into(),
                        )
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
            #[tracing::instrument(level = "trace", skip(self))]
            pub async fn get_provider_keys(&self) -> Result<Vec<String>> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "get_provider_keys",
                                "app_lib::providers::handler",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/providers/handler.rs",
                                ),
                                ::core::option::Option::Some(248u32),
                                ::core::option::Option::Some("app_lib::providers::handler"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<Vec<String>> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        let provider_store = self.provider_store.lock().await;
                        Ok(provider_store.keys().cloned().collect())
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
            #[tracing::instrument(level = "trace", skip(self))]
            pub async fn get_all_status(
                &self,
            ) -> Result<HashMap<String, ProviderStatus>> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "get_all_status",
                                "app_lib::providers::handler",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/providers/handler.rs",
                                ),
                                ::core::option::Option::Some(254u32),
                                ::core::option::Option::Some("app_lib::providers::handler"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<
                            HashMap<String, ProviderStatus>,
                        > = loop {};
                        return __tracing_attr_fake_return;
                    }
                    { Ok(self.provider_status.lock().await.clone()) }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
            #[tracing::instrument(level = "trace", skip(self, key, account_id))]
            pub async fn provider_login(
                &self,
                key: String,
                account_id: String,
            ) -> Result<()> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "provider_login",
                                "app_lib::providers::handler",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/providers/handler.rs",
                                ),
                                ::core::option::Option::Some(259u32),
                                ::core::option::Option::Some("app_lib::providers::handler"),
                                ::tracing_core::field::FieldSet::new(
                                    &["key", "account_id"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&key) as &dyn Value,
                                                ),
                                            ),
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&account_id) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<()> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        let mut provider_key = key;
                        let provider_store = self.provider_store.lock().await;
                        loop {
                            let provider = provider_store.get(&provider_key);
                            if let Some(provider) = provider {
                                let mut provider = provider.lock().await;
                                let res = provider.login(account_id.clone()).await;
                                match res {
                                    Ok(result) => return Ok(result),
                                    Err(MoosyncError::SwitchProviders(e)) => {
                                        provider_key = e;
                                        continue;
                                    }
                                    Err(err) => return Err(err),
                                }
                            }
                            return Err(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "Provider ({0}) not found for method {1}",
                                                provider_key,
                                                "login",
                                            ),
                                        );
                                        res
                                    })
                                    .into(),
                            );
                        }
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
            #[tracing::instrument(level = "trace", skip(self, key, account_id))]
            pub async fn provider_signout(
                &self,
                key: String,
                account_id: String,
            ) -> Result<()> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "provider_signout",
                                "app_lib::providers::handler",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/providers/handler.rs",
                                ),
                                ::core::option::Option::Some(259u32),
                                ::core::option::Option::Some("app_lib::providers::handler"),
                                ::tracing_core::field::FieldSet::new(
                                    &["key", "account_id"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&key) as &dyn Value,
                                                ),
                                            ),
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&account_id) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<()> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        let mut provider_key = key;
                        let provider_store = self.provider_store.lock().await;
                        loop {
                            let provider = provider_store.get(&provider_key);
                            if let Some(provider) = provider {
                                let mut provider = provider.lock().await;
                                let res = provider.signout(account_id.clone()).await;
                                match res {
                                    Ok(result) => return Ok(result),
                                    Err(MoosyncError::SwitchProviders(e)) => {
                                        provider_key = e;
                                        continue;
                                    }
                                    Err(err) => return Err(err),
                                }
                            }
                            return Err(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "Provider ({0}) not found for method {1}",
                                                provider_key,
                                                "signout",
                                            ),
                                        );
                                        res
                                    })
                                    .into(),
                            );
                        }
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
            #[tracing::instrument(level = "trace", skip(self, key, code))]
            pub async fn provider_authorize(
                &self,
                key: String,
                code: String,
            ) -> Result<()> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "provider_authorize",
                                "app_lib::providers::handler",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/providers/handler.rs",
                                ),
                                ::core::option::Option::Some(259u32),
                                ::core::option::Option::Some("app_lib::providers::handler"),
                                ::tracing_core::field::FieldSet::new(
                                    &["key", "code"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&key) as &dyn Value,
                                                ),
                                            ),
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&code) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<()> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        let mut provider_key = key;
                        let provider_store = self.provider_store.lock().await;
                        loop {
                            let provider = provider_store.get(&provider_key);
                            if let Some(provider) = provider {
                                let mut provider = provider.lock().await;
                                let res = provider.authorize(code.clone()).await;
                                match res {
                                    Ok(result) => return Ok(result),
                                    Err(MoosyncError::SwitchProviders(e)) => {
                                        provider_key = e;
                                        continue;
                                    }
                                    Err(err) => return Err(err),
                                }
                            }
                            return Err(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "Provider ({0}) not found for method {1}",
                                                provider_key,
                                                "authorize",
                                            ),
                                        );
                                        res
                                    })
                                    .into(),
                            );
                        }
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
            #[tracing::instrument(level = "trace", skip(self, key, pagination))]
            pub async fn fetch_user_playlists(
                &self,
                key: String,
                pagination: Pagination,
            ) -> Result<(Vec<QueryablePlaylist>, Pagination)> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "fetch_user_playlists",
                                "app_lib::providers::handler",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/providers/handler.rs",
                                ),
                                ::core::option::Option::Some(281u32),
                                ::core::option::Option::Some("app_lib::providers::handler"),
                                ::tracing_core::field::FieldSet::new(
                                    &["key", "pagination"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&key) as &dyn Value,
                                                ),
                                            ),
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&pagination) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<
                            (Vec<QueryablePlaylist>, Pagination),
                        > = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        let mut provider_key = key;
                        let provider_store = self.provider_store.lock().await;
                        loop {
                            let provider = provider_store.get(&provider_key);
                            if let Some(provider) = provider {
                                let provider = provider.lock().await;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:281",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(281u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "calling provider {0} - {1}",
                                                                    provider_key,
                                                                    "fetch_user_playlists",
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                let res = provider
                                    .fetch_user_playlists(pagination.clone())
                                    .await;
                                match res {
                                    Ok(result) => return Ok(result),
                                    Err(MoosyncError::SwitchProviders(e)) => {
                                        provider_key = e;
                                        continue;
                                    }
                                    Err(err) => return Err(err),
                                }
                            }
                            return Err(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "Provider ({0}) not found for method {1}",
                                                provider_key,
                                                "fetch_user_playlists",
                                            ),
                                        );
                                        res
                                    })
                                    .into(),
                            );
                        }
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
            #[tracing::instrument(level = "trace", skip(self, key, playlist_id, pagination))]
            pub async fn fetch_playlist_content(
                &self,
                key: String,
                playlist_id: String,
                pagination: Pagination,
            ) -> Result<(Vec<Song>, Pagination)> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "fetch_playlist_content",
                                "app_lib::providers::handler",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/providers/handler.rs",
                                ),
                                ::core::option::Option::Some(281u32),
                                ::core::option::Option::Some("app_lib::providers::handler"),
                                ::tracing_core::field::FieldSet::new(
                                    &["key", "playlist_id", "pagination"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&key) as &dyn Value,
                                                ),
                                            ),
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&playlist_id) as &dyn Value,
                                                ),
                                            ),
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&pagination) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<
                            (Vec<Song>, Pagination),
                        > = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        let mut provider_key = key;
                        let provider_store = self.provider_store.lock().await;
                        loop {
                            let provider = provider_store.get(&provider_key);
                            if let Some(provider) = provider {
                                let provider = provider.lock().await;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:281",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(281u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "calling provider {0} - {1}",
                                                                    provider_key,
                                                                    "get_playlist_content",
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                let res = provider
                                    .get_playlist_content(
                                        playlist_id.clone(),
                                        pagination.clone(),
                                    )
                                    .await;
                                match res {
                                    Ok(result) => return Ok(result),
                                    Err(MoosyncError::SwitchProviders(e)) => {
                                        provider_key = e;
                                        continue;
                                    }
                                    Err(err) => return Err(err),
                                }
                            }
                            return Err(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "Provider ({0}) not found for method {1}",
                                                provider_key,
                                                "get_playlist_content",
                                            ),
                                        );
                                        res
                                    })
                                    .into(),
                            );
                        }
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
            #[tracing::instrument(level = "trace", skip(self, key, song, player))]
            pub async fn fetch_playback_url(
                &self,
                key: String,
                song: Song,
                player: String,
            ) -> Result<String> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "fetch_playback_url",
                                "app_lib::providers::handler",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/providers/handler.rs",
                                ),
                                ::core::option::Option::Some(281u32),
                                ::core::option::Option::Some("app_lib::providers::handler"),
                                ::tracing_core::field::FieldSet::new(
                                    &["key", "song", "player"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&key) as &dyn Value,
                                                ),
                                            ),
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&song) as &dyn Value,
                                                ),
                                            ),
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&player) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<String> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        let mut provider_key = key;
                        let provider_store = self.provider_store.lock().await;
                        loop {
                            let provider = provider_store.get(&provider_key);
                            if let Some(provider) = provider {
                                let provider = provider.lock().await;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:281",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(281u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "calling provider {0} - {1}",
                                                                    provider_key,
                                                                    "get_playback_url",
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                let res = provider
                                    .get_playback_url(song.clone(), player.clone())
                                    .await;
                                match res {
                                    Ok(result) => return Ok(result),
                                    Err(MoosyncError::SwitchProviders(e)) => {
                                        provider_key = e;
                                        continue;
                                    }
                                    Err(err) => return Err(err),
                                }
                            }
                            return Err(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "Provider ({0}) not found for method {1}",
                                                provider_key,
                                                "get_playback_url",
                                            ),
                                        );
                                        res
                                    })
                                    .into(),
                            );
                        }
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
            #[tracing::instrument(level = "trace", skip(self, key, term))]
            pub async fn provider_search(
                &self,
                key: String,
                term: String,
            ) -> Result<SearchResult> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "provider_search",
                                "app_lib::providers::handler",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/providers/handler.rs",
                                ),
                                ::core::option::Option::Some(281u32),
                                ::core::option::Option::Some("app_lib::providers::handler"),
                                ::tracing_core::field::FieldSet::new(
                                    &["key", "term"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&key) as &dyn Value,
                                                ),
                                            ),
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&term) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<SearchResult> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        let mut provider_key = key;
                        let provider_store = self.provider_store.lock().await;
                        loop {
                            let provider = provider_store.get(&provider_key);
                            if let Some(provider) = provider {
                                let provider = provider.lock().await;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:281",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(281u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "calling provider {0} - {1}",
                                                                    provider_key,
                                                                    "search",
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                let res = provider.search(term.clone()).await;
                                match res {
                                    Ok(result) => return Ok(result),
                                    Err(MoosyncError::SwitchProviders(e)) => {
                                        provider_key = e;
                                        continue;
                                    }
                                    Err(err) => return Err(err),
                                }
                            }
                            return Err(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "Provider ({0}) not found for method {1}",
                                                provider_key,
                                                "search",
                                            ),
                                        );
                                        res
                                    })
                                    .into(),
                            );
                        }
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
            #[tracing::instrument(level = "trace", skip(self, key, url))]
            pub async fn playlist_from_url(
                &self,
                key: String,
                url: String,
            ) -> Result<QueryablePlaylist> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "playlist_from_url",
                                "app_lib::providers::handler",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/providers/handler.rs",
                                ),
                                ::core::option::Option::Some(281u32),
                                ::core::option::Option::Some("app_lib::providers::handler"),
                                ::tracing_core::field::FieldSet::new(
                                    &["key", "url"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&key) as &dyn Value,
                                                ),
                                            ),
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&url) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<QueryablePlaylist> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        let mut provider_key = key;
                        let provider_store = self.provider_store.lock().await;
                        loop {
                            let provider = provider_store.get(&provider_key);
                            if let Some(provider) = provider {
                                let provider = provider.lock().await;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:281",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(281u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "calling provider {0} - {1}",
                                                                    provider_key,
                                                                    "playlist_from_url",
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                let res = provider.playlist_from_url(url.clone()).await;
                                match res {
                                    Ok(result) => return Ok(result),
                                    Err(MoosyncError::SwitchProviders(e)) => {
                                        provider_key = e;
                                        continue;
                                    }
                                    Err(err) => return Err(err),
                                }
                            }
                            return Err(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "Provider ({0}) not found for method {1}",
                                                provider_key,
                                                "playlist_from_url",
                                            ),
                                        );
                                        res
                                    })
                                    .into(),
                            );
                        }
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
            #[tracing::instrument(level = "trace", skip(self, key, url))]
            pub async fn song_from_url(&self, key: String, url: String) -> Result<Song> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "song_from_url",
                                "app_lib::providers::handler",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/providers/handler.rs",
                                ),
                                ::core::option::Option::Some(281u32),
                                ::core::option::Option::Some("app_lib::providers::handler"),
                                ::tracing_core::field::FieldSet::new(
                                    &["key", "url"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&key) as &dyn Value,
                                                ),
                                            ),
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&url) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<Song> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        let mut provider_key = key;
                        let provider_store = self.provider_store.lock().await;
                        loop {
                            let provider = provider_store.get(&provider_key);
                            if let Some(provider) = provider {
                                let provider = provider.lock().await;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:281",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(281u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "calling provider {0} - {1}",
                                                                    provider_key,
                                                                    "song_from_url",
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                let res = provider.song_from_url(url.clone()).await;
                                match res {
                                    Ok(result) => return Ok(result),
                                    Err(MoosyncError::SwitchProviders(e)) => {
                                        provider_key = e;
                                        continue;
                                    }
                                    Err(err) => return Err(err),
                                }
                            }
                            return Err(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "Provider ({0}) not found for method {1}",
                                                provider_key,
                                                "song_from_url",
                                            ),
                                        );
                                        res
                                    })
                                    .into(),
                            );
                        }
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
            #[tracing::instrument(level = "trace", skip(self, key, url))]
            pub async fn match_url(&self, key: String, url: String) -> Result<bool> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "match_url",
                                "app_lib::providers::handler",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/providers/handler.rs",
                                ),
                                ::core::option::Option::Some(281u32),
                                ::core::option::Option::Some("app_lib::providers::handler"),
                                ::tracing_core::field::FieldSet::new(
                                    &["key", "url"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&key) as &dyn Value,
                                                ),
                                            ),
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&url) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<bool> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        let mut provider_key = key;
                        let provider_store = self.provider_store.lock().await;
                        loop {
                            let provider = provider_store.get(&provider_key);
                            if let Some(provider) = provider {
                                let provider = provider.lock().await;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:281",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(281u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "calling provider {0} - {1}",
                                                                    provider_key,
                                                                    "match_url",
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                let res = provider.match_url(url.clone()).await;
                                match res {
                                    Ok(result) => return Ok(result),
                                    Err(MoosyncError::SwitchProviders(e)) => {
                                        provider_key = e;
                                        continue;
                                    }
                                    Err(err) => return Err(err),
                                }
                            }
                            return Err(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "Provider ({0}) not found for method {1}",
                                                provider_key,
                                                "match_url",
                                            ),
                                        );
                                        res
                                    })
                                    .into(),
                            );
                        }
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
            #[tracing::instrument(level = "trace", skip(self, key))]
            pub async fn get_suggestions(&self, key: String) -> Result<Vec<Song>> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "get_suggestions",
                                "app_lib::providers::handler",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/providers/handler.rs",
                                ),
                                ::core::option::Option::Some(281u32),
                                ::core::option::Option::Some("app_lib::providers::handler"),
                                ::tracing_core::field::FieldSet::new(
                                    &["key"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&key) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<Vec<Song>> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        let mut provider_key = key;
                        let provider_store = self.provider_store.lock().await;
                        loop {
                            let provider = provider_store.get(&provider_key);
                            if let Some(provider) = provider {
                                let provider = provider.lock().await;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:281",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(281u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "calling provider {0} - {1}",
                                                                    provider_key,
                                                                    "get_suggestions",
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                let res = provider.get_suggestions().await;
                                match res {
                                    Ok(result) => return Ok(result),
                                    Err(MoosyncError::SwitchProviders(e)) => {
                                        provider_key = e;
                                        continue;
                                    }
                                    Err(err) => return Err(err),
                                }
                            }
                            return Err(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "Provider ({0}) not found for method {1}",
                                                provider_key,
                                                "get_suggestions",
                                            ),
                                        );
                                        res
                                    })
                                    .into(),
                            );
                        }
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
        }
        #[tracing::instrument(level = "trace", skip(app))]
        pub fn get_provider_handler_state(app: AppHandle) -> ProviderHandler {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current() || { false }
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "get_provider_handler_state",
                                    "app_lib::providers::handler",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/handler.rs",
                                    ),
                                    ::core::option::Option::Some(343u32),
                                    ::core::option::Option::Some("app_lib::providers::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: ProviderHandler = loop {};
                        return __tracing_attr_fake_return;
                    }
                    { ProviderHandler::new(app) }
                }
            }
        }
        #[allow(unreachable_code, clippy::diverging_sub_expression)]
        const _: () = if false {
            trait AsyncCommandMustReturnResult {}
            impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
            let _check: types::errors::Result<Vec<String>> = ::core::panicking::panic(
                "internal error: entered unreachable code",
            );
            let _: &dyn AsyncCommandMustReturnResult = &_check;
        };
        #[tracing::instrument(level = "trace", skip(db))]
        pub async fn get_provider_keys(
            db: State<'_, ProviderHandler>,
        ) -> types::errors::Result<Vec<String>> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "get_provider_keys",
                            "app_lib::providers::handler",
                            tracing::Level::TRACE,
                            ::core::option::Option::Some(
                                "src-tauri/src/providers/handler.rs",
                            ),
                            ::core::option::Option::Some(348u32),
                            ::core::option::Option::Some("app_lib::providers::handler"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = __CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        __CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        __CALLSITE.metadata(),
                    );
                    {};
                    span
                }
            };
            let __tracing_instrument_future = async move {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<Vec<String>> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/providers/handler.rs:348",
                                    "app_lib::providers::handler",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/handler.rs",
                                    ),
                                    ::core::option::Option::Some(348u32),
                                    ::core::option::Option::Some("app_lib::providers::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling async {0}", "get_provider_keys")
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.get_provider_keys().await;
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/providers/handler.rs:348",
                                        "app_lib::providers::handler",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/handler.rs",
                                        ),
                                        ::core::option::Option::Some(348u32),
                                        ::core::option::Option::Some("app_lib::providers::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/providers/handler.rs:348",
                                        "app_lib::providers::handler",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/handler.rs",
                                        ),
                                        ::core::option::Option::Some(348u32),
                                        ::core::option::Option::Some("app_lib::providers::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__get_provider_keys;
        #[allow(unreachable_code, clippy::diverging_sub_expression)]
        const _: () = if false {
            trait AsyncCommandMustReturnResult {}
            impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
            let _check: types::errors::Result<()> = ::core::panicking::panic(
                "internal error: entered unreachable code",
            );
            let _: &dyn AsyncCommandMustReturnResult = &_check;
        };
        #[tracing::instrument(level = "trace", skip(db))]
        pub async fn initialize_all_providers(
            db: State<'_, ProviderHandler>,
        ) -> types::errors::Result<()> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "initialize_all_providers",
                            "app_lib::providers::handler",
                            tracing::Level::TRACE,
                            ::core::option::Option::Some(
                                "src-tauri/src/providers/handler.rs",
                            ),
                            ::core::option::Option::Some(349u32),
                            ::core::option::Option::Some("app_lib::providers::handler"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = __CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        __CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        __CALLSITE.metadata(),
                    );
                    {};
                    span
                }
            };
            let __tracing_instrument_future = async move {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/providers/handler.rs:349",
                                    "app_lib::providers::handler",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/handler.rs",
                                    ),
                                    ::core::option::Option::Some(349u32),
                                    ::core::option::Option::Some("app_lib::providers::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!(
                                                        "calling async {0}",
                                                        "initialize_all_providers",
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.initialize_all_providers().await;
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/providers/handler.rs:349",
                                        "app_lib::providers::handler",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/handler.rs",
                                        ),
                                        ::core::option::Option::Some(349u32),
                                        ::core::option::Option::Some("app_lib::providers::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/providers/handler.rs:349",
                                        "app_lib::providers::handler",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/handler.rs",
                                        ),
                                        ::core::option::Option::Some(349u32),
                                        ::core::option::Option::Some("app_lib::providers::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__initialize_all_providers;
        #[allow(unreachable_code, clippy::diverging_sub_expression)]
        const _: () = if false {
            trait AsyncCommandMustReturnResult {}
            impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
            let _check: types::errors::Result<()> = ::core::panicking::panic(
                "internal error: entered unreachable code",
            );
            let _: &dyn AsyncCommandMustReturnResult = &_check;
        };
        #[tracing::instrument(level = "trace", skip(db, key, account_id))]
        pub async fn provider_login(
            db: State<'_, ProviderHandler>,
            key: String,
            account_id: String,
        ) -> types::errors::Result<()> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "provider_login",
                            "app_lib::providers::handler",
                            tracing::Level::TRACE,
                            ::core::option::Option::Some(
                                "src-tauri/src/providers/handler.rs",
                            ),
                            ::core::option::Option::Some(350u32),
                            ::core::option::Option::Some("app_lib::providers::handler"),
                            ::tracing_core::field::FieldSet::new(
                                &["key", "account_id"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = __CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        __CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&key) as &dyn Value,
                                            ),
                                        ),
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&account_id) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        __CALLSITE.metadata(),
                    );
                    {};
                    span
                }
            };
            let __tracing_instrument_future = async move {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/providers/handler.rs:350",
                                    "app_lib::providers::handler",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/handler.rs",
                                    ),
                                    ::core::option::Option::Some(350u32),
                                    ::core::option::Option::Some("app_lib::providers::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling async {0}", "provider_login")
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.provider_login(key, account_id).await;
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/providers/handler.rs:350",
                                        "app_lib::providers::handler",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/handler.rs",
                                        ),
                                        ::core::option::Option::Some(350u32),
                                        ::core::option::Option::Some("app_lib::providers::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/providers/handler.rs:350",
                                        "app_lib::providers::handler",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/handler.rs",
                                        ),
                                        ::core::option::Option::Some(350u32),
                                        ::core::option::Option::Some("app_lib::providers::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__provider_login;
        #[allow(unreachable_code, clippy::diverging_sub_expression)]
        const _: () = if false {
            trait AsyncCommandMustReturnResult {}
            impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
            let _check: types::errors::Result<()> = ::core::panicking::panic(
                "internal error: entered unreachable code",
            );
            let _: &dyn AsyncCommandMustReturnResult = &_check;
        };
        #[tracing::instrument(level = "trace", skip(db, key, account_id))]
        pub async fn provider_signout(
            db: State<'_, ProviderHandler>,
            key: String,
            account_id: String,
        ) -> types::errors::Result<()> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "provider_signout",
                            "app_lib::providers::handler",
                            tracing::Level::TRACE,
                            ::core::option::Option::Some(
                                "src-tauri/src/providers/handler.rs",
                            ),
                            ::core::option::Option::Some(351u32),
                            ::core::option::Option::Some("app_lib::providers::handler"),
                            ::tracing_core::field::FieldSet::new(
                                &["key", "account_id"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = __CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        __CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&key) as &dyn Value,
                                            ),
                                        ),
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&account_id) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        __CALLSITE.metadata(),
                    );
                    {};
                    span
                }
            };
            let __tracing_instrument_future = async move {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/providers/handler.rs:351",
                                    "app_lib::providers::handler",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/handler.rs",
                                    ),
                                    ::core::option::Option::Some(351u32),
                                    ::core::option::Option::Some("app_lib::providers::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling async {0}", "provider_signout")
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.provider_signout(key, account_id).await;
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/providers/handler.rs:351",
                                        "app_lib::providers::handler",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/handler.rs",
                                        ),
                                        ::core::option::Option::Some(351u32),
                                        ::core::option::Option::Some("app_lib::providers::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/providers/handler.rs:351",
                                        "app_lib::providers::handler",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/handler.rs",
                                        ),
                                        ::core::option::Option::Some(351u32),
                                        ::core::option::Option::Some("app_lib::providers::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__provider_signout;
        #[allow(unreachable_code, clippy::diverging_sub_expression)]
        const _: () = if false {
            trait AsyncCommandMustReturnResult {}
            impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
            let _check: types::errors::Result<()> = ::core::panicking::panic(
                "internal error: entered unreachable code",
            );
            let _: &dyn AsyncCommandMustReturnResult = &_check;
        };
        #[tracing::instrument(level = "trace", skip(db, key, code))]
        pub async fn provider_authorize(
            db: State<'_, ProviderHandler>,
            key: String,
            code: String,
        ) -> types::errors::Result<()> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "provider_authorize",
                            "app_lib::providers::handler",
                            tracing::Level::TRACE,
                            ::core::option::Option::Some(
                                "src-tauri/src/providers/handler.rs",
                            ),
                            ::core::option::Option::Some(352u32),
                            ::core::option::Option::Some("app_lib::providers::handler"),
                            ::tracing_core::field::FieldSet::new(
                                &["key", "code"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = __CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        __CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&key) as &dyn Value,
                                            ),
                                        ),
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&code) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        __CALLSITE.metadata(),
                    );
                    {};
                    span
                }
            };
            let __tracing_instrument_future = async move {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/providers/handler.rs:352",
                                    "app_lib::providers::handler",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/handler.rs",
                                    ),
                                    ::core::option::Option::Some(352u32),
                                    ::core::option::Option::Some("app_lib::providers::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling async {0}", "provider_authorize")
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.provider_authorize(key, code).await;
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/providers/handler.rs:352",
                                        "app_lib::providers::handler",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/handler.rs",
                                        ),
                                        ::core::option::Option::Some(352u32),
                                        ::core::option::Option::Some("app_lib::providers::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/providers/handler.rs:352",
                                        "app_lib::providers::handler",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/handler.rs",
                                        ),
                                        ::core::option::Option::Some(352u32),
                                        ::core::option::Option::Some("app_lib::providers::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__provider_authorize;
        #[allow(unreachable_code, clippy::diverging_sub_expression)]
        const _: () = if false {
            trait AsyncCommandMustReturnResult {}
            impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
            let _check: types::errors::Result<String> = ::core::panicking::panic(
                "internal error: entered unreachable code",
            );
            let _: &dyn AsyncCommandMustReturnResult = &_check;
        };
        #[tracing::instrument(level = "trace", skip(db, id))]
        pub async fn get_provider_key_by_id(
            db: State<'_, ProviderHandler>,
            id: String,
        ) -> types::errors::Result<String> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "get_provider_key_by_id",
                            "app_lib::providers::handler",
                            tracing::Level::TRACE,
                            ::core::option::Option::Some(
                                "src-tauri/src/providers/handler.rs",
                            ),
                            ::core::option::Option::Some(353u32),
                            ::core::option::Option::Some("app_lib::providers::handler"),
                            ::tracing_core::field::FieldSet::new(
                                &["id"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = __CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        __CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&id) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        __CALLSITE.metadata(),
                    );
                    {};
                    span
                }
            };
            let __tracing_instrument_future = async move {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<String> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/providers/handler.rs:353",
                                    "app_lib::providers::handler",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/handler.rs",
                                    ),
                                    ::core::option::Option::Some(353u32),
                                    ::core::option::Option::Some("app_lib::providers::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling async {0}", "get_provider_key_by_id")
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.get_provider_key_by_id(id).await;
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/providers/handler.rs:353",
                                        "app_lib::providers::handler",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/handler.rs",
                                        ),
                                        ::core::option::Option::Some(353u32),
                                        ::core::option::Option::Some("app_lib::providers::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/providers/handler.rs:353",
                                        "app_lib::providers::handler",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/handler.rs",
                                        ),
                                        ::core::option::Option::Some(353u32),
                                        ::core::option::Option::Some("app_lib::providers::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__get_provider_key_by_id;
        #[allow(unreachable_code, clippy::diverging_sub_expression)]
        const _: () = if false {
            trait AsyncCommandMustReturnResult {}
            impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
            let _check: types::errors::Result<(Vec<QueryablePlaylist>, Pagination)> = ::core::panicking::panic(
                "internal error: entered unreachable code",
            );
            let _: &dyn AsyncCommandMustReturnResult = &_check;
        };
        #[tracing::instrument(level = "trace", skip(db, cache, key, pagination))]
        pub async fn fetch_user_playlists(
            db: State<'_, ProviderHandler>,
            cache: State<'_, CacheHolder>,
            key: String,
            pagination: Pagination,
        ) -> types::errors::Result<(Vec<QueryablePlaylist>, Pagination)> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "fetch_user_playlists",
                            "app_lib::providers::handler",
                            tracing::Level::TRACE,
                            ::core::option::Option::Some(
                                "src-tauri/src/providers/handler.rs",
                            ),
                            ::core::option::Option::Some(354u32),
                            ::core::option::Option::Some("app_lib::providers::handler"),
                            ::tracing_core::field::FieldSet::new(
                                &["key", "pagination"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = __CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        __CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&key) as &dyn Value,
                                            ),
                                        ),
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&pagination) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        __CALLSITE.metadata(),
                    );
                    {};
                    span
                }
            };
            let __tracing_instrument_future = async move {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<
                        (Vec<QueryablePlaylist>, Pagination),
                    > = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    let mut cache_string = String::new();
                    cache_string.push_str("fetch_user_playlists");
                    {
                        cache_string
                            .push_str(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(format_args!("_{0:?}", key));
                                        res
                                    })
                                    .as_str(),
                            );
                    }
                    {
                        cache_string
                            .push_str(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("_{0:?}", pagination),
                                        );
                                        res
                                    })
                                    .as_str(),
                            );
                    }
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/providers/handler.rs:354",
                                    "app_lib::providers::handler",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/handler.rs",
                                    ),
                                    ::core::option::Option::Some(354u32),
                                    ::core::option::Option::Some("app_lib::providers::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!(
                                                        "calling cached async {0}: {1}",
                                                        "fetch_user_playlists",
                                                        cache_string,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let res = db.fetch_user_playlists(key, pagination).await;
                    match &res {
                        Ok(res) => {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/providers/handler.rs:354",
                                            "app_lib::providers::handler",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/providers/handler.rs",
                                            ),
                                            ::core::option::Option::Some(354u32),
                                            ::core::option::Option::Some("app_lib::providers::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Got result {0:?}", res) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            let cache_res = cache.set(cache_string.as_str(), res, 7200);
                            if let Ok(cache_res) = cache_res {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:354",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::TRACE,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(354u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::TRACE
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("Updated result in cache") as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            } else {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:354",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::ERROR,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(354u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::ERROR
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "Error updating cache {0:?}",
                                                                    cache_res.unwrap_err(),
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                        }
                        Err(e) => {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/providers/handler.rs:354",
                                            "app_lib::providers::handler",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/providers/handler.rs",
                                            ),
                                            ::core::option::Option::Some(354u32),
                                            ::core::option::Option::Some("app_lib::providers::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Error getting result {0:?}", e) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                    }
                    res
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__fetch_user_playlists;
        #[allow(unreachable_code, clippy::diverging_sub_expression)]
        const _: () = if false {
            trait AsyncCommandMustReturnResult {}
            impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
            let _check: types::errors::Result<(Vec<Song>, Pagination)> = ::core::panicking::panic(
                "internal error: entered unreachable code",
            );
            let _: &dyn AsyncCommandMustReturnResult = &_check;
        };
        #[tracing::instrument(level = "trace", skip(db, cache, key, playlist_id, pagination))]
        pub async fn fetch_playlist_content(
            db: State<'_, ProviderHandler>,
            cache: State<'_, CacheHolder>,
            key: String,
            playlist_id: String,
            pagination: Pagination,
        ) -> types::errors::Result<(Vec<Song>, Pagination)> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "fetch_playlist_content",
                            "app_lib::providers::handler",
                            tracing::Level::TRACE,
                            ::core::option::Option::Some(
                                "src-tauri/src/providers/handler.rs",
                            ),
                            ::core::option::Option::Some(355u32),
                            ::core::option::Option::Some("app_lib::providers::handler"),
                            ::tracing_core::field::FieldSet::new(
                                &["key", "playlist_id", "pagination"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = __CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        __CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&key) as &dyn Value,
                                            ),
                                        ),
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&playlist_id) as &dyn Value,
                                            ),
                                        ),
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&pagination) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        __CALLSITE.metadata(),
                    );
                    {};
                    span
                }
            };
            let __tracing_instrument_future = async move {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<
                        (Vec<Song>, Pagination),
                    > = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    let mut cache_string = String::new();
                    cache_string.push_str("fetch_playlist_content");
                    {
                        cache_string
                            .push_str(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(format_args!("_{0:?}", key));
                                        res
                                    })
                                    .as_str(),
                            );
                    }
                    {
                        cache_string
                            .push_str(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("_{0:?}", playlist_id),
                                        );
                                        res
                                    })
                                    .as_str(),
                            );
                    }
                    {
                        cache_string
                            .push_str(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("_{0:?}", pagination),
                                        );
                                        res
                                    })
                                    .as_str(),
                            );
                    }
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/providers/handler.rs:355",
                                    "app_lib::providers::handler",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/handler.rs",
                                    ),
                                    ::core::option::Option::Some(355u32),
                                    ::core::option::Option::Some("app_lib::providers::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!(
                                                        "calling cached async {0}: {1}",
                                                        "fetch_playlist_content",
                                                        cache_string,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let res = db
                        .fetch_playlist_content(key, playlist_id, pagination)
                        .await;
                    match &res {
                        Ok(res) => {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/providers/handler.rs:355",
                                            "app_lib::providers::handler",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/providers/handler.rs",
                                            ),
                                            ::core::option::Option::Some(355u32),
                                            ::core::option::Option::Some("app_lib::providers::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Got result {0:?}", res) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            let cache_res = cache.set(cache_string.as_str(), res, 7200);
                            if let Ok(cache_res) = cache_res {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:355",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::TRACE,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(355u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::TRACE
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("Updated result in cache") as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            } else {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:355",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::ERROR,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(355u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::ERROR
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "Error updating cache {0:?}",
                                                                    cache_res.unwrap_err(),
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                        }
                        Err(e) => {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/providers/handler.rs:355",
                                            "app_lib::providers::handler",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/providers/handler.rs",
                                            ),
                                            ::core::option::Option::Some(355u32),
                                            ::core::option::Option::Some("app_lib::providers::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Error getting result {0:?}", e) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                    }
                    res
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__fetch_playlist_content;
        #[allow(unreachable_code, clippy::diverging_sub_expression)]
        const _: () = if false {
            trait AsyncCommandMustReturnResult {}
            impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
            let _check: types::errors::Result<String> = ::core::panicking::panic(
                "internal error: entered unreachable code",
            );
            let _: &dyn AsyncCommandMustReturnResult = &_check;
        };
        #[tracing::instrument(level = "trace", skip(db, cache, key, song, player))]
        pub async fn fetch_playback_url(
            db: State<'_, ProviderHandler>,
            cache: State<'_, CacheHolder>,
            key: String,
            song: Song,
            player: String,
        ) -> types::errors::Result<String> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "fetch_playback_url",
                            "app_lib::providers::handler",
                            tracing::Level::TRACE,
                            ::core::option::Option::Some(
                                "src-tauri/src/providers/handler.rs",
                            ),
                            ::core::option::Option::Some(356u32),
                            ::core::option::Option::Some("app_lib::providers::handler"),
                            ::tracing_core::field::FieldSet::new(
                                &["key", "song", "player"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = __CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        __CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&key) as &dyn Value,
                                            ),
                                        ),
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&song) as &dyn Value,
                                            ),
                                        ),
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&player) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        __CALLSITE.metadata(),
                    );
                    {};
                    span
                }
            };
            let __tracing_instrument_future = async move {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<String> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    let mut cache_string = String::new();
                    cache_string.push_str("fetch_playback_url");
                    {
                        cache_string
                            .push_str(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(format_args!("_{0:?}", key));
                                        res
                                    })
                                    .as_str(),
                            );
                    }
                    {
                        cache_string
                            .push_str(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("_{0:?}", song),
                                        );
                                        res
                                    })
                                    .as_str(),
                            );
                    }
                    {
                        cache_string
                            .push_str(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("_{0:?}", player),
                                        );
                                        res
                                    })
                                    .as_str(),
                            );
                    }
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/providers/handler.rs:356",
                                    "app_lib::providers::handler",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/handler.rs",
                                    ),
                                    ::core::option::Option::Some(356u32),
                                    ::core::option::Option::Some("app_lib::providers::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!(
                                                        "calling cached async {0}: {1}",
                                                        "fetch_playback_url",
                                                        cache_string,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let res = db.fetch_playback_url(key, song, player).await;
                    match &res {
                        Ok(res) => {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/providers/handler.rs:356",
                                            "app_lib::providers::handler",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/providers/handler.rs",
                                            ),
                                            ::core::option::Option::Some(356u32),
                                            ::core::option::Option::Some("app_lib::providers::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Got result {0:?}", res) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            let cache_res = cache.set(cache_string.as_str(), res, 7200);
                            if let Ok(cache_res) = cache_res {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:356",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::TRACE,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(356u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::TRACE
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("Updated result in cache") as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            } else {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:356",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::ERROR,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(356u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::ERROR
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "Error updating cache {0:?}",
                                                                    cache_res.unwrap_err(),
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                        }
                        Err(e) => {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/providers/handler.rs:356",
                                            "app_lib::providers::handler",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/providers/handler.rs",
                                            ),
                                            ::core::option::Option::Some(356u32),
                                            ::core::option::Option::Some("app_lib::providers::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Error getting result {0:?}", e) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                    }
                    res
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__fetch_playback_url;
        #[allow(unreachable_code, clippy::diverging_sub_expression)]
        const _: () = if false {
            trait AsyncCommandMustReturnResult {}
            impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
            let _check: types::errors::Result<SearchResult> = ::core::panicking::panic(
                "internal error: entered unreachable code",
            );
            let _: &dyn AsyncCommandMustReturnResult = &_check;
        };
        #[tracing::instrument(level = "trace", skip(db, cache, key, term))]
        pub async fn provider_search(
            db: State<'_, ProviderHandler>,
            cache: State<'_, CacheHolder>,
            key: String,
            term: String,
        ) -> types::errors::Result<SearchResult> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "provider_search",
                            "app_lib::providers::handler",
                            tracing::Level::TRACE,
                            ::core::option::Option::Some(
                                "src-tauri/src/providers/handler.rs",
                            ),
                            ::core::option::Option::Some(357u32),
                            ::core::option::Option::Some("app_lib::providers::handler"),
                            ::tracing_core::field::FieldSet::new(
                                &["key", "term"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = __CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        __CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&key) as &dyn Value,
                                            ),
                                        ),
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&term) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        __CALLSITE.metadata(),
                    );
                    {};
                    span
                }
            };
            let __tracing_instrument_future = async move {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<
                        SearchResult,
                    > = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    let mut cache_string = String::new();
                    cache_string.push_str("provider_search");
                    {
                        cache_string
                            .push_str(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(format_args!("_{0:?}", key));
                                        res
                                    })
                                    .as_str(),
                            );
                    }
                    {
                        cache_string
                            .push_str(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("_{0:?}", term),
                                        );
                                        res
                                    })
                                    .as_str(),
                            );
                    }
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/providers/handler.rs:357",
                                    "app_lib::providers::handler",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/handler.rs",
                                    ),
                                    ::core::option::Option::Some(357u32),
                                    ::core::option::Option::Some("app_lib::providers::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!(
                                                        "calling cached async {0}: {1}",
                                                        "provider_search",
                                                        cache_string,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let res = db.provider_search(key, term).await;
                    match &res {
                        Ok(res) => {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/providers/handler.rs:357",
                                            "app_lib::providers::handler",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/providers/handler.rs",
                                            ),
                                            ::core::option::Option::Some(357u32),
                                            ::core::option::Option::Some("app_lib::providers::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Got result {0:?}", res) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            let cache_res = cache.set(cache_string.as_str(), res, 7200);
                            if let Ok(cache_res) = cache_res {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:357",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::TRACE,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(357u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::TRACE
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("Updated result in cache") as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            } else {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:357",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::ERROR,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(357u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::ERROR
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "Error updating cache {0:?}",
                                                                    cache_res.unwrap_err(),
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                        }
                        Err(e) => {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/providers/handler.rs:357",
                                            "app_lib::providers::handler",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/providers/handler.rs",
                                            ),
                                            ::core::option::Option::Some(357u32),
                                            ::core::option::Option::Some("app_lib::providers::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Error getting result {0:?}", e) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                    }
                    res
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__provider_search;
        #[allow(unreachable_code, clippy::diverging_sub_expression)]
        const _: () = if false {
            trait AsyncCommandMustReturnResult {}
            impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
            let _check: types::errors::Result<HashMap<String, ProviderStatus>> = ::core::panicking::panic(
                "internal error: entered unreachable code",
            );
            let _: &dyn AsyncCommandMustReturnResult = &_check;
        };
        #[tracing::instrument(level = "trace", skip(db))]
        pub async fn get_all_status(
            db: State<'_, ProviderHandler>,
        ) -> types::errors::Result<HashMap<String, ProviderStatus>> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "get_all_status",
                            "app_lib::providers::handler",
                            tracing::Level::TRACE,
                            ::core::option::Option::Some(
                                "src-tauri/src/providers/handler.rs",
                            ),
                            ::core::option::Option::Some(358u32),
                            ::core::option::Option::Some("app_lib::providers::handler"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = __CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        __CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        __CALLSITE.metadata(),
                    );
                    {};
                    span
                }
            };
            let __tracing_instrument_future = async move {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<
                        HashMap<String, ProviderStatus>,
                    > = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/providers/handler.rs:358",
                                    "app_lib::providers::handler",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/handler.rs",
                                    ),
                                    ::core::option::Option::Some(358u32),
                                    ::core::option::Option::Some("app_lib::providers::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling async {0}", "get_all_status")
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.get_all_status().await;
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/providers/handler.rs:358",
                                        "app_lib::providers::handler",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/handler.rs",
                                        ),
                                        ::core::option::Option::Some(358u32),
                                        ::core::option::Option::Some("app_lib::providers::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/providers/handler.rs:358",
                                        "app_lib::providers::handler",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/handler.rs",
                                        ),
                                        ::core::option::Option::Some(358u32),
                                        ::core::option::Option::Some("app_lib::providers::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__get_all_status;
        #[allow(unreachable_code, clippy::diverging_sub_expression)]
        const _: () = if false {
            trait AsyncCommandMustReturnResult {}
            impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
            let _check: types::errors::Result<QueryablePlaylist> = ::core::panicking::panic(
                "internal error: entered unreachable code",
            );
            let _: &dyn AsyncCommandMustReturnResult = &_check;
        };
        #[tracing::instrument(level = "trace", skip(db, cache, key, url))]
        pub async fn playlist_from_url(
            db: State<'_, ProviderHandler>,
            cache: State<'_, CacheHolder>,
            key: String,
            url: String,
        ) -> types::errors::Result<QueryablePlaylist> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "playlist_from_url",
                            "app_lib::providers::handler",
                            tracing::Level::TRACE,
                            ::core::option::Option::Some(
                                "src-tauri/src/providers/handler.rs",
                            ),
                            ::core::option::Option::Some(359u32),
                            ::core::option::Option::Some("app_lib::providers::handler"),
                            ::tracing_core::field::FieldSet::new(
                                &["key", "url"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = __CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        __CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&key) as &dyn Value,
                                            ),
                                        ),
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&url) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        __CALLSITE.metadata(),
                    );
                    {};
                    span
                }
            };
            let __tracing_instrument_future = async move {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<
                        QueryablePlaylist,
                    > = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    let mut cache_string = String::new();
                    cache_string.push_str("playlist_from_url");
                    {
                        cache_string
                            .push_str(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(format_args!("_{0:?}", key));
                                        res
                                    })
                                    .as_str(),
                            );
                    }
                    {
                        cache_string
                            .push_str(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(format_args!("_{0:?}", url));
                                        res
                                    })
                                    .as_str(),
                            );
                    }
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/providers/handler.rs:359",
                                    "app_lib::providers::handler",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/handler.rs",
                                    ),
                                    ::core::option::Option::Some(359u32),
                                    ::core::option::Option::Some("app_lib::providers::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!(
                                                        "calling cached async {0}: {1}",
                                                        "playlist_from_url",
                                                        cache_string,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let res = db.playlist_from_url(key, url).await;
                    match &res {
                        Ok(res) => {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/providers/handler.rs:359",
                                            "app_lib::providers::handler",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/providers/handler.rs",
                                            ),
                                            ::core::option::Option::Some(359u32),
                                            ::core::option::Option::Some("app_lib::providers::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Got result {0:?}", res) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            let cache_res = cache.set(cache_string.as_str(), res, 7200);
                            if let Ok(cache_res) = cache_res {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:359",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::TRACE,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(359u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::TRACE
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("Updated result in cache") as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            } else {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:359",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::ERROR,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(359u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::ERROR
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "Error updating cache {0:?}",
                                                                    cache_res.unwrap_err(),
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                        }
                        Err(e) => {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/providers/handler.rs:359",
                                            "app_lib::providers::handler",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/providers/handler.rs",
                                            ),
                                            ::core::option::Option::Some(359u32),
                                            ::core::option::Option::Some("app_lib::providers::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Error getting result {0:?}", e) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                    }
                    res
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__playlist_from_url;
        #[allow(unreachable_code, clippy::diverging_sub_expression)]
        const _: () = if false {
            trait AsyncCommandMustReturnResult {}
            impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
            let _check: types::errors::Result<Song> = ::core::panicking::panic(
                "internal error: entered unreachable code",
            );
            let _: &dyn AsyncCommandMustReturnResult = &_check;
        };
        #[tracing::instrument(level = "trace", skip(db, cache, key, url))]
        pub async fn song_from_url(
            db: State<'_, ProviderHandler>,
            cache: State<'_, CacheHolder>,
            key: String,
            url: String,
        ) -> types::errors::Result<Song> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "song_from_url",
                            "app_lib::providers::handler",
                            tracing::Level::TRACE,
                            ::core::option::Option::Some(
                                "src-tauri/src/providers/handler.rs",
                            ),
                            ::core::option::Option::Some(360u32),
                            ::core::option::Option::Some("app_lib::providers::handler"),
                            ::tracing_core::field::FieldSet::new(
                                &["key", "url"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = __CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        __CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&key) as &dyn Value,
                                            ),
                                        ),
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&url) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        __CALLSITE.metadata(),
                    );
                    {};
                    span
                }
            };
            let __tracing_instrument_future = async move {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<Song> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    let mut cache_string = String::new();
                    cache_string.push_str("song_from_url");
                    {
                        cache_string
                            .push_str(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(format_args!("_{0:?}", key));
                                        res
                                    })
                                    .as_str(),
                            );
                    }
                    {
                        cache_string
                            .push_str(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(format_args!("_{0:?}", url));
                                        res
                                    })
                                    .as_str(),
                            );
                    }
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/providers/handler.rs:360",
                                    "app_lib::providers::handler",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/handler.rs",
                                    ),
                                    ::core::option::Option::Some(360u32),
                                    ::core::option::Option::Some("app_lib::providers::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!(
                                                        "calling cached async {0}: {1}",
                                                        "song_from_url",
                                                        cache_string,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let res = db.song_from_url(key, url).await;
                    match &res {
                        Ok(res) => {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/providers/handler.rs:360",
                                            "app_lib::providers::handler",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/providers/handler.rs",
                                            ),
                                            ::core::option::Option::Some(360u32),
                                            ::core::option::Option::Some("app_lib::providers::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Got result {0:?}", res) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            let cache_res = cache.set(cache_string.as_str(), res, 7200);
                            if let Ok(cache_res) = cache_res {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:360",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::TRACE,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(360u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::TRACE
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("Updated result in cache") as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            } else {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:360",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::ERROR,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(360u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::ERROR
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "Error updating cache {0:?}",
                                                                    cache_res.unwrap_err(),
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                        }
                        Err(e) => {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/providers/handler.rs:360",
                                            "app_lib::providers::handler",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/providers/handler.rs",
                                            ),
                                            ::core::option::Option::Some(360u32),
                                            ::core::option::Option::Some("app_lib::providers::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Error getting result {0:?}", e) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                    }
                    res
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__song_from_url;
        #[allow(unreachable_code, clippy::diverging_sub_expression)]
        const _: () = if false {
            trait AsyncCommandMustReturnResult {}
            impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
            let _check: types::errors::Result<bool> = ::core::panicking::panic(
                "internal error: entered unreachable code",
            );
            let _: &dyn AsyncCommandMustReturnResult = &_check;
        };
        #[tracing::instrument(level = "trace", skip(db, cache, key, url))]
        pub async fn match_url(
            db: State<'_, ProviderHandler>,
            cache: State<'_, CacheHolder>,
            key: String,
            url: String,
        ) -> types::errors::Result<bool> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "match_url",
                            "app_lib::providers::handler",
                            tracing::Level::TRACE,
                            ::core::option::Option::Some(
                                "src-tauri/src/providers/handler.rs",
                            ),
                            ::core::option::Option::Some(361u32),
                            ::core::option::Option::Some("app_lib::providers::handler"),
                            ::tracing_core::field::FieldSet::new(
                                &["key", "url"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = __CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        __CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&key) as &dyn Value,
                                            ),
                                        ),
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&url) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        __CALLSITE.metadata(),
                    );
                    {};
                    span
                }
            };
            let __tracing_instrument_future = async move {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<bool> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    let mut cache_string = String::new();
                    cache_string.push_str("match_url");
                    {
                        cache_string
                            .push_str(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(format_args!("_{0:?}", key));
                                        res
                                    })
                                    .as_str(),
                            );
                    }
                    {
                        cache_string
                            .push_str(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(format_args!("_{0:?}", url));
                                        res
                                    })
                                    .as_str(),
                            );
                    }
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/providers/handler.rs:361",
                                    "app_lib::providers::handler",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/handler.rs",
                                    ),
                                    ::core::option::Option::Some(361u32),
                                    ::core::option::Option::Some("app_lib::providers::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!(
                                                        "calling cached async {0}: {1}",
                                                        "match_url",
                                                        cache_string,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let res = db.match_url(key, url).await;
                    match &res {
                        Ok(res) => {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/providers/handler.rs:361",
                                            "app_lib::providers::handler",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/providers/handler.rs",
                                            ),
                                            ::core::option::Option::Some(361u32),
                                            ::core::option::Option::Some("app_lib::providers::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Got result {0:?}", res) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            let cache_res = cache.set(cache_string.as_str(), res, 7200);
                            if let Ok(cache_res) = cache_res {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:361",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::TRACE,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(361u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::TRACE
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("Updated result in cache") as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            } else {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:361",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::ERROR,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(361u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::ERROR
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "Error updating cache {0:?}",
                                                                    cache_res.unwrap_err(),
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                        }
                        Err(e) => {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/providers/handler.rs:361",
                                            "app_lib::providers::handler",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/providers/handler.rs",
                                            ),
                                            ::core::option::Option::Some(361u32),
                                            ::core::option::Option::Some("app_lib::providers::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Error getting result {0:?}", e) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                    }
                    res
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__match_url;
        #[allow(unreachable_code, clippy::diverging_sub_expression)]
        const _: () = if false {
            trait AsyncCommandMustReturnResult {}
            impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
            let _check: types::errors::Result<Vec<Song>> = ::core::panicking::panic(
                "internal error: entered unreachable code",
            );
            let _: &dyn AsyncCommandMustReturnResult = &_check;
        };
        #[tracing::instrument(level = "trace", skip(db, cache, key))]
        pub async fn get_suggestions(
            db: State<'_, ProviderHandler>,
            cache: State<'_, CacheHolder>,
            key: String,
        ) -> types::errors::Result<Vec<Song>> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "get_suggestions",
                            "app_lib::providers::handler",
                            tracing::Level::TRACE,
                            ::core::option::Option::Some(
                                "src-tauri/src/providers/handler.rs",
                            ),
                            ::core::option::Option::Some(362u32),
                            ::core::option::Option::Some("app_lib::providers::handler"),
                            ::tracing_core::field::FieldSet::new(
                                &["key"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = __CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        __CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&key) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        __CALLSITE.metadata(),
                    );
                    {};
                    span
                }
            };
            let __tracing_instrument_future = async move {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<Vec<Song>> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    let mut cache_string = String::new();
                    cache_string.push_str("get_suggestions");
                    {
                        cache_string
                            .push_str(
                                ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(format_args!("_{0:?}", key));
                                        res
                                    })
                                    .as_str(),
                            );
                    }
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/providers/handler.rs:362",
                                    "app_lib::providers::handler",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/handler.rs",
                                    ),
                                    ::core::option::Option::Some(362u32),
                                    ::core::option::Option::Some("app_lib::providers::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!(
                                                        "calling cached async {0}: {1}",
                                                        "get_suggestions",
                                                        cache_string,
                                                    ) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let res = db.get_suggestions(key).await;
                    match &res {
                        Ok(res) => {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/providers/handler.rs:362",
                                            "app_lib::providers::handler",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/providers/handler.rs",
                                            ),
                                            ::core::option::Option::Some(362u32),
                                            ::core::option::Option::Some("app_lib::providers::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Got result {0:?}", res) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            let cache_res = cache.set(cache_string.as_str(), res, 7200);
                            if let Ok(cache_res) = cache_res {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:362",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::TRACE,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(362u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::TRACE
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("Updated result in cache") as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            } else {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/handler.rs:362",
                                                "app_lib::providers::handler",
                                                ::tracing::Level::ERROR,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/handler.rs",
                                                ),
                                                ::core::option::Option::Some(362u32),
                                                ::core::option::Option::Some("app_lib::providers::handler"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::ERROR
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!(
                                                                    "Error updating cache {0:?}",
                                                                    cache_res.unwrap_err(),
                                                                ) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                        }
                        Err(e) => {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/providers/handler.rs:362",
                                            "app_lib::providers::handler",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/providers/handler.rs",
                                            ),
                                            ::core::option::Option::Some(362u32),
                                            ::core::option::Option::Some("app_lib::providers::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Error getting result {0:?}", e) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                    }
                    res
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__get_suggestions;
    }
    pub mod spotify {
        use std::collections::{HashMap, HashSet};
        use async_trait::async_trait;
        use chrono::{DateTime, TimeDelta};
        use futures::{channel::mpsc::UnboundedSender, SinkExt, StreamExt};
        use oauth2::{CsrfToken, PkceCodeVerifier};
        use preferences::preferences::PreferenceConfig;
        use regex::Regex;
        use rspotify::{
            clients::{BaseClient, OAuthClient},
            model::{
                FullArtist, FullTrack, Id, PlaylistId, PlaylistTracksRef, SearchType,
                SimplifiedAlbum, SimplifiedArtist, SimplifiedPlaylist, TrackId,
            },
            AuthCodePkceSpotify, Token,
        };
        use serde::{Deserialize, Serialize};
        use serde_json::Value;
        use tauri::{AppHandle, Manager, State};
        use types::{
            entities::{
                EntityInfo, QueryableAlbum, QueryableArtist, QueryablePlaylist,
                SearchResult,
            },
            errors::Result, oauth::OAuth2Client,
            providers::generic::{Pagination, ProviderStatus},
            songs::{QueryableSong, Song, SongType},
        };
        use types::{errors::MoosyncError, providers::generic::GenericProvider};
        use url::Url;
        use crate::oauth::handler::OAuthHandler;
        use super::common::{
            authorize, get_oauth_client, login, refresh_login, LoginArgs,
            OAuthClientArgs, TokenHolder,
        };
        struct SpotifyConfig {
            client_secret: Option<String>,
            client_id: Option<String>,
            redirect_uri: &'static str,
            scopes: Vec<&'static str>,
            tokens: Option<TokenHolder>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SpotifyConfig {
            #[tracing::instrument(level = "trace", skip(self, f))]
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "SpotifyConfig",
                    "client_secret",
                    &self.client_secret,
                    "client_id",
                    &self.client_id,
                    "redirect_uri",
                    &self.redirect_uri,
                    "scopes",
                    &self.scopes,
                    "tokens",
                    &&self.tokens,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SpotifyConfig {
            #[tracing::instrument(level = "trace", skip(self))]
            #[inline]
            fn clone(&self) -> SpotifyConfig {
                SpotifyConfig {
                    client_secret: ::core::clone::Clone::clone(&self.client_secret),
                    client_id: ::core::clone::Clone::clone(&self.client_id),
                    redirect_uri: ::core::clone::Clone::clone(&self.redirect_uri),
                    scopes: ::core::clone::Clone::clone(&self.scopes),
                    tokens: ::core::clone::Clone::clone(&self.tokens),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for SpotifyConfig {
            #[tracing::instrument(level = "trace", skip())]
            #[inline]
            fn default() -> SpotifyConfig {
                SpotifyConfig {
                    client_secret: ::core::default::Default::default(),
                    client_id: ::core::default::Default::default(),
                    redirect_uri: ::core::default::Default::default(),
                    scopes: ::core::default::Default::default(),
                    tokens: ::core::default::Default::default(),
                }
            }
        }
        pub struct SpotifyProvider {
            app: AppHandle,
            config: SpotifyConfig,
            verifier: Option<(OAuth2Client, PkceCodeVerifier, CsrfToken)>,
            api_client: Option<AuthCodePkceSpotify>,
            status_tx: UnboundedSender<ProviderStatus>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SpotifyProvider {
            #[tracing::instrument(level = "trace", skip(self, f))]
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "SpotifyProvider",
                    "app",
                    &self.app,
                    "config",
                    &self.config,
                    "verifier",
                    &self.verifier,
                    "api_client",
                    &self.api_client,
                    "status_tx",
                    &&self.status_tx,
                )
            }
        }
        pub struct ArtistExtraInfo {
            artist_id: String,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ArtistExtraInfo {
            #[tracing::instrument(level = "trace", skip(self, f))]
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ArtistExtraInfo",
                    "artist_id",
                    &&self.artist_id,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ArtistExtraInfo {
            #[tracing::instrument(level = "trace", skip())]
            #[inline]
            fn default() -> ArtistExtraInfo {
                ArtistExtraInfo {
                    artist_id: ::core::default::Default::default(),
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ArtistExtraInfo {
                #[tracing::instrument(level = "trace", skip(self, __serializer))]
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ArtistExtraInfo",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "artist_id",
                        &self.artist_id,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ArtistExtraInfo {
                #[tracing::instrument(level = "trace", skip(__deserializer))]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        #[tracing::instrument(level = "trace", skip(self, __formatter))]
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        #[tracing::instrument(level = "trace", skip(self, __value))]
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        #[tracing::instrument(level = "trace", skip(self, __value))]
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "artist_id" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        #[tracing::instrument(level = "trace", skip(self, __value))]
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"artist_id" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[tracing::instrument(level = "trace", skip(__deserializer))]
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ArtistExtraInfo>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ArtistExtraInfo;
                        #[tracing::instrument(level = "trace", skip(self, __formatter))]
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ArtistExtraInfo",
                            )
                        }
                        #[tracing::instrument(level = "trace", skip(self, __seq))]
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ArtistExtraInfo with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ArtistExtraInfo {
                                artist_id: __field0,
                            })
                        }
                        #[tracing::instrument(level = "trace", skip(self, __map))]
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "artist_id",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("artist_id")?
                                }
                            };
                            _serde::__private::Ok(ArtistExtraInfo {
                                artist_id: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["artist_id"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ArtistExtraInfo",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ArtistExtraInfo>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct SpotifyExtraInfo {
            spotify: ArtistExtraInfo,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SpotifyExtraInfo {
            #[tracing::instrument(level = "trace", skip(self, f))]
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "SpotifyExtraInfo",
                    "spotify",
                    &&self.spotify,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for SpotifyExtraInfo {
            #[tracing::instrument(level = "trace", skip())]
            #[inline]
            fn default() -> SpotifyExtraInfo {
                SpotifyExtraInfo {
                    spotify: ::core::default::Default::default(),
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SpotifyExtraInfo {
                #[tracing::instrument(level = "trace", skip(self, __serializer))]
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "SpotifyExtraInfo",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "spotify",
                        &self.spotify,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SpotifyExtraInfo {
                #[tracing::instrument(level = "trace", skip(__deserializer))]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        #[tracing::instrument(level = "trace", skip(self, __formatter))]
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        #[tracing::instrument(level = "trace", skip(self, __value))]
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        #[tracing::instrument(level = "trace", skip(self, __value))]
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "spotify" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        #[tracing::instrument(level = "trace", skip(self, __value))]
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"spotify" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[tracing::instrument(level = "trace", skip(__deserializer))]
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SpotifyExtraInfo>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SpotifyExtraInfo;
                        #[tracing::instrument(level = "trace", skip(self, __formatter))]
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct SpotifyExtraInfo",
                            )
                        }
                        #[tracing::instrument(level = "trace", skip(self, __seq))]
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                ArtistExtraInfo,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct SpotifyExtraInfo with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(SpotifyExtraInfo {
                                spotify: __field0,
                            })
                        }
                        #[tracing::instrument(level = "trace", skip(self, __map))]
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                ArtistExtraInfo,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "spotify",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ArtistExtraInfo,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("spotify")?
                                }
                            };
                            _serde::__private::Ok(SpotifyExtraInfo {
                                spotify: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["spotify"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "SpotifyExtraInfo",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<SpotifyExtraInfo>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl SpotifyProvider {
            #[tracing::instrument(level = "trace", skip(app, status_tx))]
            pub fn new(
                app: AppHandle,
                status_tx: UnboundedSender<ProviderStatus>,
            ) -> Self {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "new",
                                        "app_lib::providers::spotify",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/spotify.rs",
                                        ),
                                        ::core::option::Option::Some(78u32),
                                        ::core::option::Option::Some("app_lib::providers::spotify"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Self = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            Self {
                                app,
                                config: SpotifyConfig::default(),
                                verifier: None,
                                api_client: None,
                                status_tx,
                            }
                        }
                    }
                }
            }
        }
        impl SpotifyProvider {
            #[tracing::instrument(level = "trace", skip(self))]
            fn get_oauth_client(&self) -> OAuth2Client {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "get_oauth_client",
                                        "app_lib::providers::spotify",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/spotify.rs",
                                        ),
                                        ::core::option::Option::Some(91u32),
                                        ::core::option::Option::Some("app_lib::providers::spotify"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: OAuth2Client = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            get_oauth_client(OAuthClientArgs {
                                auth_url: "https://accounts.spotify.com/authorize"
                                    .to_string(),
                                token_url: "https://accounts.spotify.com/api/token"
                                    .to_string(),
                                redirect_url: self.config.redirect_uri.to_string(),
                                client_id: self.config.client_id.clone().unwrap(),
                                client_secret: self.config.client_secret.clone().unwrap(),
                            })
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self))]
            async fn create_api_client(&mut self) {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "create_api_client",
                                "app_lib::providers::spotify",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/providers/spotify.rs",
                                ),
                                ::core::option::Option::Some(102u32),
                                ::core::option::Option::Some("app_lib::providers::spotify"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: () = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        if let Some(token) = &self.config.tokens {
                            self.api_client = Some(
                                AuthCodePkceSpotify::from_token(Token {
                                    access_token: token.access_token.clone(),
                                    expires_in: TimeDelta::seconds(
                                        token.expires_in.try_into().unwrap(),
                                    ),
                                    expires_at: Some(
                                        DateTime::from_timestamp_millis(token.expires_at).unwrap(),
                                    ),
                                    refresh_token: Some(token.refresh_token.clone()),
                                    scopes: HashSet::from_iter(
                                        self.config.scopes.iter().map(|v| v.to_string()),
                                    ),
                                }),
                            );
                            let res = self.fetch_user_details().await;
                            if let Ok(res) = res {
                                let _ = self.status_tx.send(res).await;
                            } else {
                                let _ = self
                                    .status_tx
                                    .send(ProviderStatus {
                                        key: self.key(),
                                        name: "Spotify".into(),
                                        user_name: None,
                                        logged_in: true,
                                        bg_color: "#07C330".into(),
                                        account_id: "spotify".into(),
                                    })
                                    .await;
                            }
                        }
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
            #[tracing::instrument(level = "trace", skip(self))]
            async fn refresh_login(&mut self) -> Result<()> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "refresh_login",
                                "app_lib::providers::spotify",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/providers/spotify.rs",
                                ),
                                ::core::option::Option::Some(132u32),
                                ::core::option::Option::Some("app_lib::providers::spotify"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<()> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        self.config.tokens = Some(
                            refresh_login(
                                    "MoosyncSpotifyRefreshToken",
                                    self.get_oauth_client(),
                                    &self.app,
                                )
                                .await?,
                        );
                        self.create_api_client().await;
                        Ok(())
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
            #[tracing::instrument(level = "trace", skip(self, playlist))]
            fn parse_playlist(&self, playlist: SimplifiedPlaylist) -> QueryablePlaylist {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "parse_playlist",
                                        "app_lib::providers::spotify",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/spotify.rs",
                                        ),
                                        ::core::option::Option::Some(147u32),
                                        ::core::option::Option::Some("app_lib::providers::spotify"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: QueryablePlaylist = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            QueryablePlaylist {
                                playlist_id: Some(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("spotify-playlist:{0}", playlist.id.id()),
                                        );
                                        res
                                    }),
                                ),
                                playlist_name: playlist.name,
                                playlist_coverpath: playlist
                                    .images
                                    .first()
                                    .map(|i| i.url.clone()),
                                playlist_song_count: playlist.tracks.total as f64,
                                extension: Some(self.key()),
                                ..Default::default()
                            }
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, artist))]
            fn parse_artists(&self, artist: SimplifiedArtist) -> QueryableArtist {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "parse_artists",
                                        "app_lib::providers::spotify",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/spotify.rs",
                                        ),
                                        ::core::option::Option::Some(159u32),
                                        ::core::option::Option::Some("app_lib::providers::spotify"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: QueryableArtist = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            QueryableArtist {
                                artist_id: Some(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!(
                                                "spotify-artist:{0}",
                                                artist.id.clone().unwrap(),
                                            ),
                                        );
                                        res
                                    }),
                                ),
                                artist_name: Some(artist.name),
                                artist_extra_info: Some(
                                    EntityInfo(
                                        serde_json::to_string(
                                                &SpotifyExtraInfo {
                                                    spotify: ArtistExtraInfo {
                                                        artist_id: artist.id.clone().unwrap().to_string(),
                                                    },
                                                },
                                            )
                                            .unwrap(),
                                    ),
                                ),
                                ..Default::default()
                            }
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, album))]
            fn parse_album(&self, album: SimplifiedAlbum) -> QueryableAlbum {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "parse_album",
                                        "app_lib::providers::spotify",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/spotify.rs",
                                        ),
                                        ::core::option::Option::Some(176u32),
                                        ::core::option::Option::Some("app_lib::providers::spotify"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: QueryableAlbum = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            QueryableAlbum {
                                album_id: Some(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("spotify-album:{0}", album.id.clone().unwrap()),
                                        );
                                        res
                                    }),
                                ),
                                album_name: Some(album.name),
                                album_artist: album.artists.first().map(|a| a.name.clone()),
                                album_coverpath_high: album
                                    .images
                                    .first()
                                    .map(|i| i.url.clone()),
                                album_coverpath_low: album
                                    .images
                                    .last()
                                    .map(|i| i.url.clone()),
                                ..Default::default()
                            }
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, item))]
            fn parse_playlist_item(&self, item: FullTrack) -> Song {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "parse_playlist_item",
                                        "app_lib::providers::spotify",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/spotify.rs",
                                        ),
                                        ::core::option::Option::Some(188u32),
                                        ::core::option::Option::Some("app_lib::providers::spotify"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Song = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            let id = item.id.unwrap().to_string();
                            Song {
                                song: QueryableSong {
                                    _id: Some(
                                        ::alloc::__export::must_use({
                                            let res = ::alloc::fmt::format(
                                                format_args!("spotify:{0}", id),
                                            );
                                            res
                                        }),
                                    ),
                                    title: Some(item.name),
                                    duration: Some(item.duration.num_seconds() as f64),
                                    type_: SongType::SPOTIFY,
                                    url: Some(id.clone()),
                                    song_cover_path_high: item
                                        .album
                                        .images
                                        .first()
                                        .map(|i| i.url.clone()),
                                    playback_url: Some(id),
                                    track_no: Some(item.disc_number as f64),
                                    provider_extension: Some(self.key()),
                                    ..Default::default()
                                },
                                album: Some(self.parse_album(item.album)),
                                artists: Some(
                                    item
                                        .artists
                                        .into_iter()
                                        .map(|a| self.parse_artists(a))
                                        .collect(),
                                ),
                                ..Default::default()
                            }
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self))]
            async fn fetch_user_details(&self) -> Result<ProviderStatus> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "fetch_user_details",
                                "app_lib::providers::spotify",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/providers/spotify.rs",
                                ),
                                ::core::option::Option::Some(215u32),
                                ::core::option::Option::Some("app_lib::providers::spotify"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<ProviderStatus> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/providers/spotify.rs:217",
                                        "app_lib::providers::spotify",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/spotify.rs",
                                        ),
                                        ::core::option::Option::Some(217u32),
                                        ::core::option::Option::Some("app_lib::providers::spotify"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!(
                                                            "Fetchinf user details {0:?}",
                                                            self.api_client,
                                                        ) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        if let Some(api_client) = &self.api_client {
                            let token = api_client.token.lock().await.unwrap();
                            drop(token);
                            let user = api_client.current_user().await?;
                            return Ok(ProviderStatus {
                                key: self.key(),
                                name: "Spotify".into(),
                                user_name: user.display_name,
                                logged_in: true,
                                bg_color: "#07C330".into(),
                                account_id: "spotify".into(),
                            });
                        }
                        Err("API client not initialized".into())
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
        }
        impl GenericProvider for SpotifyProvider {
            #[tracing::instrument(level = "trace", skip(self))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn initialize<'life0, 'async_trait>(
                &'life0 mut self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<()>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "initialize",
                                    "app_lib::providers::spotify",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/spotify.rs",
                                    ),
                                    ::core::option::Option::Some(239u32),
                                    ::core::option::Option::Some("app_lib::providers::spotify"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<()>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let mut __self = self;
                        let __ret: Result<()> = {
                            let _ = __self
                                .status_tx
                                .send(ProviderStatus {
                                    key: __self.key(),
                                    name: "Spotify".into(),
                                    user_name: None,
                                    logged_in: false,
                                    bg_color: "#07C330".into(),
                                    account_id: "spotify".into(),
                                })
                                .await;
                            let preferences: State<PreferenceConfig> = __self
                                .app
                                .state();
                            let spotify_config: Value = preferences
                                .inner()
                                .load_selective("spotify".into())?;
                            let client_id = spotify_config.get("client_id");
                            let client_secret = spotify_config.get("client_secret");
                            __self.config.client_id = client_id
                                .map(|v| v.as_str().unwrap().to_string());
                            __self.config.client_secret = client_secret
                                .map(|v| v.as_str().unwrap().to_string());
                            __self.config.redirect_uri = "https://moosync.app/spotify";
                            __self.config.scopes = <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    "playlist-read-private",
                                    "user-top-read",
                                    "user-library-read",
                                    "user-read-private",
                                    "streaming",
                                    "app-remote-control",
                                ]),
                            );
                            let res = __self.refresh_login().await;
                            if let Err(err) = res {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/spotify.rs:272",
                                                "app_lib::providers::spotify",
                                                ::tracing::Level::ERROR,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/spotify.rs",
                                                ),
                                                ::core::option::Option::Some(272u32),
                                                ::core::option::Option::Some("app_lib::providers::spotify"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::ERROR
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("spotify refresh login err: {0:?}", err)
                                                                    as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                            Ok(())
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self))]
            fn key(&self) -> String {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "key",
                                        "app_lib::providers::spotify",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/spotify.rs",
                                        ),
                                        ::core::option::Option::Some(278u32),
                                        ::core::option::Option::Some("app_lib::providers::spotify"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: String = loop {};
                            return __tracing_attr_fake_return;
                        }
                        { "spotify".into() }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, id))]
            fn match_id(&self, id: String) -> bool {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "match_id",
                                        "app_lib::providers::spotify",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/spotify.rs",
                                        ),
                                        ::core::option::Option::Some(283u32),
                                        ::core::option::Option::Some("app_lib::providers::spotify"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: bool = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            id.starts_with("spotify-playlist:")
                                || id.starts_with("spotify-artist:")
                                || id.starts_with("spotify-album:")
                                || id.starts_with("spotify:")
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, __arg1))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn login<'life0, 'async_trait>(
                &'life0 mut self,
                __arg1: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<()>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "login",
                                    "app_lib::providers::spotify",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/spotify.rs",
                                    ),
                                    ::core::option::Option::Some(291u32),
                                    ::core::option::Option::Some("app_lib::providers::spotify"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["__arg1"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&__arg1) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<()>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let mut __self = self;
                        let __arg1 = __arg1;
                        let __ret: Result<()> = {
                            __self.verifier = login(
                                LoginArgs {
                                    client_id: __self.config.client_id.clone(),
                                    client_secret: __self.config.client_secret.clone(),
                                    scopes: __self.config.scopes.clone(),
                                    extra_params: None,
                                },
                                __self.get_oauth_client(),
                                &__self.app,
                            )?;
                            let oauth_handler: State<OAuthHandler> = __self.app.state();
                            oauth_handler
                                .register_oauth_path(
                                    "spotifyoauthcallback".into(),
                                    __self.key(),
                                );
                            Ok(())
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, __arg1))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn signout<'life0, 'async_trait>(
                &'life0 mut self,
                __arg1: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<()>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "signout",
                                    "app_lib::providers::spotify",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/spotify.rs",
                                    ),
                                    ::core::option::Option::Some(310u32),
                                    ::core::option::Option::Some("app_lib::providers::spotify"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["__arg1"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&__arg1) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<()>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let mut __self = self;
                        let __arg1 = __arg1;
                        let __ret: Result<()> = {
                            __self.config.tokens = None;
                            __self.api_client = None;
                            __self.verifier = None;
                            let preferences: State<PreferenceConfig> = __self
                                .app
                                .state();
                            preferences
                                .set_secure(
                                    "MoosyncSpotifyRefreshToken".into(),
                                    None::<String>,
                                )?;
                            let _ = __self
                                .status_tx
                                .send(ProviderStatus {
                                    key: __self.key(),
                                    name: "Spotify".into(),
                                    user_name: None,
                                    logged_in: false,
                                    bg_color: "#07C330".into(),
                                    account_id: "spotify".into(),
                                })
                                .await;
                            Ok(())
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, code))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn authorize<'life0, 'async_trait>(
                &'life0 mut self,
                code: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<()>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "authorize",
                                    "app_lib::providers::spotify",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/spotify.rs",
                                    ),
                                    ::core::option::Option::Some(333u32),
                                    ::core::option::Option::Some("app_lib::providers::spotify"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<()>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let mut __self = self;
                        let code = code;
                        let __ret: Result<()> = {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/providers/spotify.rs:335",
                                            "app_lib::providers::spotify",
                                            ::tracing::Level::INFO,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/providers/spotify.rs",
                                            ),
                                            ::core::option::Option::Some(335u32),
                                            ::core::option::Option::Some("app_lib::providers::spotify"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::INFO
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::INFO
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Authorizing with code {0}", code)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            __self.config.tokens = Some(
                                authorize(
                                        "MoosyncSpotifyRefreshToken",
                                        code,
                                        &mut __self.verifier,
                                        &__self.app,
                                    )
                                    .await?,
                            );
                            __self.create_api_client().await;
                            Ok(())
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, pagination))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fetch_user_playlists<'life0, 'async_trait>(
                &'life0 self,
                pagination: Pagination,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(Vec<QueryablePlaylist>, Pagination)>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "fetch_user_playlists",
                                    "app_lib::providers::spotify",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/spotify.rs",
                                    ),
                                    ::core::option::Option::Some(350u32),
                                    ::core::option::Option::Some("app_lib::providers::spotify"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<(Vec<QueryablePlaylist>, Pagination)>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let __self = self;
                        let pagination = pagination;
                        let __ret: Result<(Vec<QueryablePlaylist>, Pagination)> = {
                            let mut ret = ::alloc::vec::Vec::new();
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/providers/spotify.rs:356",
                                            "app_lib::providers::spotify",
                                            ::tracing::Level::INFO,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/providers/spotify.rs",
                                            ),
                                            ::core::option::Option::Some(356u32),
                                            ::core::option::Option::Some("app_lib::providers::spotify"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::INFO
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::INFO
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!(
                                                                "Fetching spotify playlists {0:?}",
                                                                __self.api_client,
                                                            ) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            if let Some(api_client) = &__self.api_client {
                                let playlists = api_client
                                    .current_user_playlists_manual(
                                        Some(pagination.limit),
                                        Some(pagination.offset),
                                    )
                                    .await;
                                if let Ok(playlists) = playlists {
                                    for playlist in playlists.items {
                                        ret.push(__self.parse_playlist(playlist))
                                    }
                                }
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/spotify.rs:366",
                                                "app_lib::providers::spotify",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/spotify.rs",
                                                ),
                                                ::core::option::Option::Some(366u32),
                                                ::core::option::Option::Some("app_lib::providers::spotify"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("Got user playlists {0:?}", ret) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                return Ok((ret, pagination.next_page()));
                            }
                            Err("API client not initialized".into())
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, playlist_id, pagination))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn get_playlist_content<'life0, 'async_trait>(
                &'life0 self,
                playlist_id: String,
                pagination: Pagination,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(Vec<Song>, Pagination)>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "get_playlist_content",
                                    "app_lib::providers::spotify",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/spotify.rs",
                                    ),
                                    ::core::option::Option::Some(373u32),
                                    ::core::option::Option::Some("app_lib::providers::spotify"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<(Vec<Song>, Pagination)>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let __self = self;
                        let playlist_id = playlist_id;
                        let pagination = pagination;
                        let __ret: Result<(Vec<Song>, Pagination)> = {
                            let mut ret = ::alloc::vec::Vec::new();
                            if let Some(api_client) = &__self.api_client {
                                let playlist_id = playlist_id
                                    .strip_prefix("spotify-playlist:")
                                    .unwrap_or(&playlist_id);
                                let items = api_client
                                    .playlist_items_manual(
                                        PlaylistId::from_id_or_uri(playlist_id).unwrap(),
                                        None,
                                        None,
                                        Some(pagination.limit),
                                        Some(pagination.offset),
                                    )
                                    .await;
                                if let Ok(items) = items {
                                    for i in items.items {
                                        if i.is_local {
                                            continue;
                                        }
                                        match i.track.unwrap() {
                                            rspotify::model::PlayableItem::Track(t) => {
                                                ret.push(__self.parse_playlist_item(t));
                                            }
                                            rspotify::model::PlayableItem::Episode(_) => {
                                                continue;
                                            }
                                        }
                                    }
                                }
                                return Ok((ret, pagination.next_page()));
                            }
                            Err("API client not initialized".into())
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, __arg1, __arg2))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn get_playback_url<'life0, 'async_trait>(
                &'life0 self,
                __arg1: Song,
                __arg2: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<String>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "get_playback_url",
                                    "app_lib::providers::spotify",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/spotify.rs",
                                    ),
                                    ::core::option::Option::Some(414u32),
                                    ::core::option::Option::Some("app_lib::providers::spotify"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["__arg1", "__arg2"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&__arg1) as &dyn Value,
                                                    ),
                                                ),
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&__arg2) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<String>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let __self = self;
                        let __arg1 = __arg1;
                        let __arg2 = __arg2;
                        let __ret: Result<String> = {
                            Err(MoosyncError::SwitchProviders("youtube".into()))
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, term))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn search<'life0, 'async_trait>(
                &'life0 self,
                term: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<SearchResult>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "search",
                                    "app_lib::providers::spotify",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/spotify.rs",
                                    ),
                                    ::core::option::Option::Some(419u32),
                                    ::core::option::Option::Some("app_lib::providers::spotify"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<SearchResult>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let __self = self;
                        let term = term;
                        let __ret: Result<SearchResult> = {
                            let mut ret = SearchResult {
                                songs: ::alloc::vec::Vec::new(),
                                albums: ::alloc::vec::Vec::new(),
                                artists: ::alloc::vec::Vec::new(),
                                playlists: ::alloc::vec::Vec::new(),
                                ..Default::default()
                            };
                            if let Some(api_client) = &__self.api_client {
                                {
                                    if let Ok(rspotify::model::SearchResult::Tracks(items)) = api_client
                                        .search(
                                            &term,
                                            SearchType::Track,
                                            None,
                                            None,
                                            Some(50),
                                            Some(0),
                                        )
                                        .await
                                    {
                                        for item in items.items {
                                            (|item, vec: &mut Vec<Song>| {
                                                vec.push(__self.parse_playlist_item(item))
                                            })(item, &mut ret.songs);
                                        }
                                    }
                                    if let Ok(
                                        rspotify::model::SearchResult::Playlists(items),
                                    ) = api_client
                                        .search(
                                            &term,
                                            SearchType::Playlist,
                                            None,
                                            None,
                                            Some(50),
                                            Some(0),
                                        )
                                        .await
                                    {
                                        for item in items.items {
                                            (|item, vec: &mut Vec<QueryablePlaylist>| {
                                                vec.push(__self.parse_playlist(item))
                                            })(item, &mut ret.playlists);
                                        }
                                    }
                                    if let Ok(rspotify::model::SearchResult::Artists(items)) = api_client
                                        .search(
                                            &term,
                                            SearchType::Artist,
                                            None,
                                            None,
                                            Some(50),
                                            Some(0),
                                        )
                                        .await
                                    {
                                        for item in items.items {
                                            (|item: FullArtist, vec: &mut Vec<QueryableArtist>| {
                                                vec
                                                    .push(
                                                        __self
                                                            .parse_artists(SimplifiedArtist {
                                                                external_urls: item.external_urls,
                                                                href: Some(item.href),
                                                                id: Some(item.id),
                                                                name: item.name,
                                                            }),
                                                    )
                                            })(item, &mut ret.artists);
                                        }
                                    }
                                    if let Ok(rspotify::model::SearchResult::Albums(items)) = api_client
                                        .search(
                                            &term,
                                            SearchType::Album,
                                            None,
                                            None,
                                            Some(50),
                                            Some(0),
                                        )
                                        .await
                                    {
                                        for item in items.items {
                                            (|item, vec: &mut Vec<QueryableAlbum>| {
                                                vec.push(__self.parse_album(item))
                                            })(item, &mut ret.albums);
                                        }
                                    }
                                };
                                return Ok(ret);
                            }
                            Err("API client not initialized".into())
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, url))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn match_url<'life0, 'async_trait>(
                &'life0 self,
                url: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<bool>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "match_url",
                                    "app_lib::providers::spotify",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/spotify.rs",
                                    ),
                                    ::core::option::Option::Some(473u32),
                                    ::core::option::Option::Some("app_lib::providers::spotify"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<bool>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let __self = self;
                        let url = url;
                        let __ret: Result<bool> = {
                            let re = Regex::new(
                                    r"^(https:\/\/open.spotify.com\/(track|embed)\/|spotify:track:)([a-zA-Z0-9]+)(.*)$",
                                )
                                .unwrap();
                            if re.is_match(url.as_str()) {
                                return Ok(true);
                            }
                            let re = Regex::new(
                                    r"^(https:\/\/open.spotify.com\/playlist\/|spotify:playlist:)([a-zA-Z0-9]+)(.*)$",
                                )
                                .unwrap();
                            if re.is_match(url.as_str()) {
                                return Ok(true);
                            }
                            Ok(false)
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, url))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn playlist_from_url<'life0, 'async_trait>(
                &'life0 self,
                url: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<QueryablePlaylist>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "playlist_from_url",
                                    "app_lib::providers::spotify",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/spotify.rs",
                                    ),
                                    ::core::option::Option::Some(493u32),
                                    ::core::option::Option::Some("app_lib::providers::spotify"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<QueryablePlaylist>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let __self = self;
                        let url = url;
                        let __ret: Result<QueryablePlaylist> = {
                            let playlist_id = Url::parse(url.as_str());
                            let playlist_id = if let Ok(playlist_id) = playlist_id {
                                playlist_id.path().to_string()
                            } else {
                                url
                            };
                            if let Some(api_client) = &__self.api_client {
                                let playlists = api_client
                                    .playlist(
                                        PlaylistId::from_id_or_uri(playlist_id.as_str())
                                            .map_err(|_| MoosyncError::String(
                                                "Invalid playlist url".into(),
                                            ))?,
                                        None,
                                        None,
                                    )
                                    .await?;
                                let res = __self
                                    .parse_playlist(SimplifiedPlaylist {
                                        collaborative: playlists.collaborative,
                                        external_urls: playlists.external_urls,
                                        href: playlists.href,
                                        id: playlists.id,
                                        images: playlists.images,
                                        name: playlists.name,
                                        owner: playlists.owner,
                                        public: playlists.public,
                                        snapshot_id: playlists.snapshot_id,
                                        tracks: PlaylistTracksRef::default(),
                                    });
                                return Ok(res);
                            }
                            Err("API Client not initialized".into())
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, url))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn song_from_url<'life0, 'async_trait>(
                &'life0 self,
                url: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<Song>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "song_from_url",
                                    "app_lib::providers::spotify",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/spotify.rs",
                                    ),
                                    ::core::option::Option::Some(531u32),
                                    ::core::option::Option::Some("app_lib::providers::spotify"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<Song>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let __self = self;
                        let url = url;
                        let __ret: Result<Song> = {
                            let track_id = Url::parse(url.as_str());
                            let track_id = if let Ok(track_id) = track_id {
                                track_id.path().to_string()
                            } else {
                                url
                            };
                            if let Some(api_client) = &__self.api_client {
                                let res = api_client
                                    .track(TrackId::from_id_or_uri(track_id.as_str())?, None)
                                    .await?;
                                return Ok(__self.parse_playlist_item(res));
                            }
                            Err("API Client not initialized".into())
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn get_suggestions<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<Vec<Song>>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "get_suggestions",
                                    "app_lib::providers::spotify",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/spotify.rs",
                                    ),
                                    ::core::option::Option::Some(551u32),
                                    ::core::option::Option::Some("app_lib::providers::spotify"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<Vec<Song>>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let __self = self;
                        let __ret: Result<Vec<Song>> = {
                            if let Some(api_client) = &__self.api_client {
                                let mut i = 0;
                                let mut ret = ::alloc::vec::Vec::new();
                                while i < 5 {
                                    let user_top_tracks = api_client
                                        .current_user_top_tracks(None)
                                        .next()
                                        .await;
                                    if let Some(track) = user_top_tracks {
                                        let track = track?;
                                        if let Some(track_id) = track.id {
                                            ret.push(track_id);
                                            i += 1;
                                        }
                                    } else {
                                        break;
                                    }
                                }
                                let recom = api_client
                                    .recommendations(
                                        ::alloc::vec::Vec::new(),
                                        Some(::alloc::vec::Vec::new()),
                                        Some(::alloc::vec::Vec::new()),
                                        Some(ret),
                                        None,
                                        Some(100),
                                    )
                                    .await?;
                                return Ok(
                                    recom
                                        .tracks
                                        .iter()
                                        .map(|t| {
                                            __self
                                                .parse_playlist_item(FullTrack {
                                                    album: t.album.clone().unwrap_or_default(),
                                                    artists: t.artists.clone(),
                                                    disc_number: t.disc_number,
                                                    duration: t.duration,
                                                    id: t.id.clone(),
                                                    name: t.name.clone(),
                                                    track_number: t.track_number,
                                                    available_markets: ::alloc::vec::Vec::new(),
                                                    explicit: t.explicit,
                                                    external_urls: t.external_urls.clone(),
                                                    external_ids: HashMap::new(),
                                                    href: None,
                                                    is_local: false,
                                                    is_playable: None,
                                                    linked_from: None,
                                                    restrictions: None,
                                                    popularity: 0,
                                                    preview_url: t.preview_url.clone(),
                                                })
                                        })
                                        .collect(),
                                );
                            }
                            Err("API Client not initialized".into())
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
        }
    }
    pub mod youtube {
        use async_trait::async_trait;
        use futures::channel::mpsc::UnboundedSender;
        use futures::SinkExt;
        use google_youtube3::api::{
            Channel, ChannelSnippet, Playlist, PlaylistSnippet, Video,
        };
        use google_youtube3::hyper::client::HttpConnector;
        use google_youtube3::hyper_rustls::HttpsConnector;
        use google_youtube3::{hyper, hyper_rustls, YouTube};
        use oauth2::basic::BasicClient;
        use oauth2::{
            AuthUrl, ClientId, ClientSecret, CsrfToken, PkceCodeVerifier, RedirectUrl,
            TokenUrl,
        };
        use preferences::preferences::PreferenceConfig;
        use regex::Regex;
        use serde::{Deserialize, Serialize};
        use serde_json::Value;
        use std::collections::HashMap;
        use tauri::{AppHandle, Manager, State};
        use types::entities::{
            EntityInfo, QueryableAlbum, QueryableArtist, QueryablePlaylist, SearchResult,
        };
        use types::errors::{MoosyncError, Result};
        use types::providers::generic::{Pagination, ProviderStatus};
        use types::songs::{QueryableSong, Song, SongType};
        use types::{oauth::OAuth2Client, providers::generic::GenericProvider};
        use url::Url;
        use youtube::youtube::YoutubeScraper;
        use crate::oauth::handler::OAuthHandler;
        use super::common::{authorize, login, refresh_login, LoginArgs, TokenHolder};
        pub struct ArtistExtraInfo {
            artist_id: String,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ArtistExtraInfo {
            #[tracing::instrument(level = "trace", skip(self, f))]
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ArtistExtraInfo",
                    "artist_id",
                    &&self.artist_id,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ArtistExtraInfo {
            #[tracing::instrument(level = "trace", skip())]
            #[inline]
            fn default() -> ArtistExtraInfo {
                ArtistExtraInfo {
                    artist_id: ::core::default::Default::default(),
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ArtistExtraInfo {
                #[tracing::instrument(level = "trace", skip(self, __serializer))]
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ArtistExtraInfo",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "artist_id",
                        &self.artist_id,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ArtistExtraInfo {
                #[tracing::instrument(level = "trace", skip(__deserializer))]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        #[tracing::instrument(level = "trace", skip(self, __formatter))]
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        #[tracing::instrument(level = "trace", skip(self, __value))]
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        #[tracing::instrument(level = "trace", skip(self, __value))]
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "artist_id" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        #[tracing::instrument(level = "trace", skip(self, __value))]
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"artist_id" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[tracing::instrument(level = "trace", skip(__deserializer))]
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ArtistExtraInfo>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ArtistExtraInfo;
                        #[tracing::instrument(level = "trace", skip(self, __formatter))]
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ArtistExtraInfo",
                            )
                        }
                        #[tracing::instrument(level = "trace", skip(self, __seq))]
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ArtistExtraInfo with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ArtistExtraInfo {
                                artist_id: __field0,
                            })
                        }
                        #[tracing::instrument(level = "trace", skip(self, __map))]
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "artist_id",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("artist_id")?
                                }
                            };
                            _serde::__private::Ok(ArtistExtraInfo {
                                artist_id: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["artist_id"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ArtistExtraInfo",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ArtistExtraInfo>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct YoutubeExtraInfo {
            youtube: ArtistExtraInfo,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for YoutubeExtraInfo {
            #[tracing::instrument(level = "trace", skip(self, f))]
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "YoutubeExtraInfo",
                    "youtube",
                    &&self.youtube,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for YoutubeExtraInfo {
            #[tracing::instrument(level = "trace", skip())]
            #[inline]
            fn default() -> YoutubeExtraInfo {
                YoutubeExtraInfo {
                    youtube: ::core::default::Default::default(),
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for YoutubeExtraInfo {
                #[tracing::instrument(level = "trace", skip(self, __serializer))]
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "YoutubeExtraInfo",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "youtube",
                        &self.youtube,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for YoutubeExtraInfo {
                #[tracing::instrument(level = "trace", skip(__deserializer))]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        #[tracing::instrument(level = "trace", skip(self, __formatter))]
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        #[tracing::instrument(level = "trace", skip(self, __value))]
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        #[tracing::instrument(level = "trace", skip(self, __value))]
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "youtube" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        #[tracing::instrument(level = "trace", skip(self, __value))]
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"youtube" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[tracing::instrument(level = "trace", skip(__deserializer))]
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<YoutubeExtraInfo>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = YoutubeExtraInfo;
                        #[tracing::instrument(level = "trace", skip(self, __formatter))]
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct YoutubeExtraInfo",
                            )
                        }
                        #[tracing::instrument(level = "trace", skip(self, __seq))]
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                ArtistExtraInfo,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct YoutubeExtraInfo with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(YoutubeExtraInfo {
                                youtube: __field0,
                            })
                        }
                        #[tracing::instrument(level = "trace", skip(self, __map))]
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                ArtistExtraInfo,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "youtube",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ArtistExtraInfo,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("youtube")?
                                }
                            };
                            _serde::__private::Ok(YoutubeExtraInfo {
                                youtube: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["youtube"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "YoutubeExtraInfo",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<YoutubeExtraInfo>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        struct YoutubeConfig {
            client_secret: Option<String>,
            client_id: Option<String>,
            redirect_uri: &'static str,
            scopes: Vec<&'static str>,
            tokens: Option<TokenHolder>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for YoutubeConfig {
            #[tracing::instrument(level = "trace", skip(self, f))]
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "YoutubeConfig",
                    "client_secret",
                    &self.client_secret,
                    "client_id",
                    &self.client_id,
                    "redirect_uri",
                    &self.redirect_uri,
                    "scopes",
                    &self.scopes,
                    "tokens",
                    &&self.tokens,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for YoutubeConfig {
            #[tracing::instrument(level = "trace", skip(self))]
            #[inline]
            fn clone(&self) -> YoutubeConfig {
                YoutubeConfig {
                    client_secret: ::core::clone::Clone::clone(&self.client_secret),
                    client_id: ::core::clone::Clone::clone(&self.client_id),
                    redirect_uri: ::core::clone::Clone::clone(&self.redirect_uri),
                    scopes: ::core::clone::Clone::clone(&self.scopes),
                    tokens: ::core::clone::Clone::clone(&self.tokens),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for YoutubeConfig {
            #[tracing::instrument(level = "trace", skip())]
            #[inline]
            fn default() -> YoutubeConfig {
                YoutubeConfig {
                    client_secret: ::core::default::Default::default(),
                    client_id: ::core::default::Default::default(),
                    redirect_uri: ::core::default::Default::default(),
                    scopes: ::core::default::Default::default(),
                    tokens: ::core::default::Default::default(),
                }
            }
        }
        pub struct YoutubeProvider {
            app: AppHandle,
            config: YoutubeConfig,
            verifier: Option<(OAuth2Client, PkceCodeVerifier, CsrfToken)>,
            api_client: Option<YouTube<HttpsConnector<HttpConnector>>>,
            status_tx: UnboundedSender<ProviderStatus>,
        }
        impl std::fmt::Debug for YoutubeProvider {
            #[tracing::instrument(level = "trace", skip(self, f))]
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "fmt",
                                        "app_lib::providers::youtube",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/youtube.rs",
                                        ),
                                        ::core::option::Option::Some(75u32),
                                        ::core::option::Option::Some("app_lib::providers::youtube"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: core::fmt::Result = loop {};
                            return __tracing_attr_fake_return;
                        }
                        { <YoutubeConfig as std::fmt::Debug>::fmt(&self.config, f) }
                    }
                }
            }
        }
        impl YoutubeProvider {
            #[tracing::instrument(level = "trace", skip(app, status_tx))]
            pub fn new(
                app: AppHandle,
                status_tx: UnboundedSender<ProviderStatus>,
            ) -> Self {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "new",
                                        "app_lib::providers::youtube",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/youtube.rs",
                                        ),
                                        ::core::option::Option::Some(82u32),
                                        ::core::option::Option::Some("app_lib::providers::youtube"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Self = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            Self {
                                app,
                                config: YoutubeConfig::default(),
                                verifier: None,
                                api_client: None,
                                status_tx,
                            }
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self))]
            fn get_oauth_client(&self) -> OAuth2Client {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "get_oauth_client",
                                        "app_lib::providers::youtube",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/youtube.rs",
                                        ),
                                        ::core::option::Option::Some(93u32),
                                        ::core::option::Option::Some("app_lib::providers::youtube"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: OAuth2Client = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            BasicClient::new(
                                    ClientId::new(self.config.client_id.clone().unwrap()),
                                    Some(
                                        ClientSecret::new(
                                            self.config.client_secret.clone().unwrap(),
                                        ),
                                    ),
                                    AuthUrl::new(
                                            "https://accounts.google.com/o/oauth2/v2/auth".to_string(),
                                        )
                                        .unwrap(),
                                    Some(
                                        TokenUrl::new(
                                                "https://oauth2.googleapis.com/token".to_string(),
                                            )
                                            .unwrap(),
                                    ),
                                )
                                .set_redirect_uri(
                                    RedirectUrl::new(self.config.redirect_uri.to_string())
                                        .unwrap(),
                                )
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self))]
            async fn create_api_client(&mut self) {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "create_api_client",
                                "app_lib::providers::youtube",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/providers/youtube.rs",
                                ),
                                ::core::option::Option::Some(106u32),
                                ::core::option::Option::Some("app_lib::providers::youtube"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: () = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        if let Some(token) = &self.config.tokens {
                            let client = hyper::Client::builder()
                                .build(
                                    hyper_rustls::HttpsConnectorBuilder::new()
                                        .with_native_roots()
                                        .unwrap()
                                        .https_or_http()
                                        .enable_http1()
                                        .build(),
                                );
                            self.api_client = Some(
                                google_youtube3::YouTube::new(
                                    client,
                                    token.access_token.clone(),
                                ),
                            );
                            let res = self.fetch_user_details().await;
                            if let Ok(res) = res {
                                let _ = self.status_tx.send(res).await;
                            } else {
                                let _ = self
                                    .status_tx
                                    .send(ProviderStatus {
                                        key: self.key(),
                                        name: "Youtube".into(),
                                        user_name: None,
                                        logged_in: true,
                                        bg_color: "#E62017".into(),
                                        account_id: "youtube".into(),
                                    })
                                    .await;
                            }
                        }
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
            #[tracing::instrument(level = "trace", skip(self))]
            async fn refresh_login(&mut self) -> Result<()> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "refresh_login",
                                "app_lib::providers::youtube",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/providers/youtube.rs",
                                ),
                                ::core::option::Option::Some(142u32),
                                ::core::option::Option::Some("app_lib::providers::youtube"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<()> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        self.config.tokens = Some(
                            refresh_login(
                                    "MoosyncYoutubeRefreshToken",
                                    self.get_oauth_client(),
                                    &self.app,
                                )
                                .await?,
                        );
                        self.create_api_client().await;
                        Ok(())
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
            #[tracing::instrument(level = "trace", skip(self, resp))]
            fn parse_playlist(&self, resp: Playlist) -> QueryablePlaylist {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "parse_playlist",
                                        "app_lib::providers::youtube",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/youtube.rs",
                                        ),
                                        ::core::option::Option::Some(157u32),
                                        ::core::option::Option::Some("app_lib::providers::youtube"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: QueryablePlaylist = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            let snippet = resp.snippet.unwrap_or_default();
                            let content_details = resp
                                .content_details
                                .unwrap_or_default();
                            QueryablePlaylist {
                                playlist_id: Some(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("youtube-playlist:{0}", resp.id.unwrap()),
                                        );
                                        res
                                    }),
                                ),
                                playlist_name: snippet.title.unwrap_or_default(),
                                playlist_coverpath: snippet
                                    .thumbnails
                                    .map(|t| {
                                        t.maxres
                                            .or(t.default)
                                            .unwrap_or_default()
                                            .url
                                            .unwrap_or_default()
                                    }),
                                playlist_song_count: content_details
                                    .item_count
                                    .unwrap_or_default() as f64,
                                playlist_desc: snippet.description,
                                playlist_path: None,
                                extension: Some(self.key()),
                                icon: None,
                                library_item: None,
                            }
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, resp))]
            fn parse_channel(&self, resp: Channel) -> QueryableArtist {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "parse_channel",
                                        "app_lib::providers::youtube",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/youtube.rs",
                                        ),
                                        ::core::option::Option::Some(181u32),
                                        ::core::option::Option::Some("app_lib::providers::youtube"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: QueryableArtist = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            let snippet = resp.snippet.as_ref().unwrap();
                            QueryableArtist {
                                artist_id: Some(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("youtube-artist:{0}", resp.id.clone().unwrap()),
                                        );
                                        res
                                    }),
                                ),
                                artist_name: snippet.title.clone(),
                                artist_coverpath: snippet
                                    .thumbnails
                                    .clone()
                                    .map(|t| {
                                        t.maxres
                                            .or(t.default)
                                            .unwrap_or_default()
                                            .url
                                            .unwrap_or_default()
                                    }),
                                artist_extra_info: Some(
                                    EntityInfo(
                                        serde_json::to_string(
                                                &YoutubeExtraInfo {
                                                    youtube: ArtistExtraInfo {
                                                        artist_id: resp.id.unwrap(),
                                                    },
                                                },
                                            )
                                            .unwrap(),
                                    ),
                                ),
                                ..Default::default()
                            }
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, ids))]
            async fn fetch_song_details(&self, ids: Vec<String>) -> Result<Vec<Song>> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "fetch_song_details",
                                "app_lib::providers::youtube",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/providers/youtube.rs",
                                ),
                                ::core::option::Option::Some(206u32),
                                ::core::option::Option::Some("app_lib::providers::youtube"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<Vec<Song>> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/providers/youtube.rs:208",
                                        "app_lib::providers::youtube",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/youtube.rs",
                                        ),
                                        ::core::option::Option::Some(208u32),
                                        ::core::option::Option::Some("app_lib::providers::youtube"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Fetching song details for {0:?}", ids)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        if let Some(api_client) = &self.api_client {
                            let mut ret = ::alloc::vec::Vec::new();
                            for id_chunk in ids.chunks(50) {
                                let mut builder = api_client
                                    .videos()
                                    .list(
                                        &<[_]>::into_vec(
                                            #[rustc_box]
                                            ::alloc::boxed::Box::new([
                                                "contentDetails".into(),
                                                "snippet".into(),
                                            ]),
                                        ),
                                    );
                                for i in id_chunk {
                                    builder = builder.add_id(i);
                                }
                                let (_, resp) = builder.doit().await?;
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/youtube.rs:221",
                                                "app_lib::providers::youtube",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/youtube.rs",
                                                ),
                                                ::core::option::Option::Some(221u32),
                                                ::core::option::Option::Some("app_lib::providers::youtube"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("Got song response {0:?}", resp) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                if let Some(videos) = resp.items {
                                    for v in videos {
                                        ret.push(self.parse_video_item(v));
                                    }
                                }
                            }
                            return Ok(ret);
                        }
                        Err("API client not initialized".into())
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
            #[tracing::instrument(level = "trace", skip(self, resp))]
            fn parse_video_item(&self, resp: Video) -> Song {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "parse_video_item",
                                        "app_lib::providers::youtube",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/youtube.rs",
                                        ),
                                        ::core::option::Option::Some(235u32),
                                        ::core::option::Option::Some("app_lib::providers::youtube"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Song = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            let snippet = resp.snippet.unwrap_or_default();
                            let content_details = resp
                                .content_details
                                .unwrap_or_default();
                            let id = resp.id;
                            Song {
                                song: QueryableSong {
                                    _id: id
                                        .clone()
                                        .map(|id| ::alloc::__export::must_use({
                                            let res = ::alloc::fmt::format(
                                                format_args!("youtube:{0}", id),
                                            );
                                            res
                                        })),
                                    title: snippet.title,
                                    date: snippet.published_at.map(|v| v.to_string()),
                                    duration: content_details
                                        .duration
                                        .map(|d| {
                                            core::time::Duration::from(iso8601::duration(&d).unwrap())
                                                .as_secs() as f64
                                        }),
                                    type_: SongType::YOUTUBE,
                                    url: id.clone(),
                                    song_cover_path_high: snippet
                                        .thumbnails
                                        .clone()
                                        .map(|t| {
                                            t.maxres.unwrap_or_default().url.unwrap_or_default()
                                        }),
                                    playback_url: id,
                                    song_cover_path_low: snippet
                                        .thumbnails
                                        .map(|t| {
                                            t.standard.unwrap_or_default().url.unwrap_or_default()
                                        }),
                                    date_added: snippet
                                        .published_at
                                        .map(|v| v.timestamp_millis()),
                                    provider_extension: Some(self.key()),
                                    ..Default::default()
                                },
                                album: Some(QueryableAlbum {
                                    album_name: Some("Misc".into()),
                                    ..Default::default()
                                }),
                                artists: Some(
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            QueryableArtist {
                                                artist_id: snippet
                                                    .channel_id
                                                    .map(|id| ::alloc::__export::must_use({
                                                        let res = ::alloc::fmt::format(
                                                            format_args!("youtube-artist:{0}", id),
                                                        );
                                                        res
                                                    })),
                                                artist_name: snippet.channel_title,
                                                ..Default::default()
                                            },
                                        ]),
                                    ),
                                ),
                                genre: None,
                            }
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self))]
            async fn fetch_user_details(&self) -> Result<ProviderStatus> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "fetch_user_details",
                                "app_lib::providers::youtube",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/providers/youtube.rs",
                                ),
                                ::core::option::Option::Some(278u32),
                                ::core::option::Option::Some("app_lib::providers::youtube"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<ProviderStatus> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        if let Some(api_client) = &self.api_client {
                            let (_, user_info) = api_client
                                .channels()
                                .list(
                                    &<[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new(["snippet".into()]),
                                    ),
                                )
                                .mine(true)
                                .max_results(1)
                                .doit()
                                .await?;
                            let mut username = Some("".to_string());
                            if let Some(items) = user_info.items {
                                let channel = items.first().unwrap();
                                if let Some(snippet) = &channel.snippet {
                                    username = snippet.title.clone();
                                }
                            }
                            return Ok(ProviderStatus {
                                key: self.key(),
                                name: "Youtube".into(),
                                user_name: username,
                                logged_in: true,
                                bg_color: "#E62017".into(),
                                account_id: "youtube".into(),
                            });
                        }
                        Err("API client not initialized".into())
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
        }
        impl GenericProvider for YoutubeProvider {
            #[tracing::instrument(level = "trace", skip(self))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn initialize<'life0, 'async_trait>(
                &'life0 mut self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<()>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "initialize",
                                    "app_lib::providers::youtube",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/youtube.rs",
                                    ),
                                    ::core::option::Option::Some(312u32),
                                    ::core::option::Option::Some("app_lib::providers::youtube"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<()>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let mut __self = self;
                        let __ret: Result<()> = {
                            let _ = __self
                                .status_tx
                                .send(ProviderStatus {
                                    key: __self.key(),
                                    name: "Youtube".into(),
                                    user_name: None,
                                    logged_in: false,
                                    bg_color: "#E62017".into(),
                                    account_id: "youtube".into(),
                                })
                                .await;
                            let preferences: State<PreferenceConfig> = __self
                                .app
                                .state();
                            let youtube_config: Value = preferences
                                .inner()
                                .load_selective("youtube".into())?;
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/providers/youtube.rs:328",
                                            "app_lib::providers::youtube",
                                            ::tracing::Level::INFO,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/providers/youtube.rs",
                                            ),
                                            ::core::option::Option::Some(328u32),
                                            ::core::option::Option::Some("app_lib::providers::youtube"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::INFO
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::INFO
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("{0:?}", youtube_config) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            let client_id = youtube_config.get("client_id");
                            let client_secret = youtube_config.get("client_secret");
                            __self.config.client_id = client_id
                                .map(|v| v.as_str().unwrap().to_string());
                            __self.config.client_secret = client_secret
                                .map(|v| v.as_str().unwrap().to_string());
                            __self.config.redirect_uri = "https://moosync.app/youtube";
                            __self.config.scopes = <[_]>::into_vec(
                                #[rustc_box]
                                ::alloc::boxed::Box::new([
                                    "https://www.googleapis.com/auth/youtube.readonly",
                                ]),
                            );
                            let res = __self.refresh_login().await;
                            if let Err(err) = res {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/youtube.rs:339",
                                                "app_lib::providers::youtube",
                                                ::tracing::Level::ERROR,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/youtube.rs",
                                                ),
                                                ::core::option::Option::Some(339u32),
                                                ::core::option::Option::Some("app_lib::providers::youtube"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::ERROR
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("youtube refresh login err: {0:?}", err)
                                                                    as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            }
                            Ok(())
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self))]
            fn key(&self) -> String {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "key",
                                        "app_lib::providers::youtube",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/youtube.rs",
                                        ),
                                        ::core::option::Option::Some(345u32),
                                        ::core::option::Option::Some("app_lib::providers::youtube"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: String = loop {};
                            return __tracing_attr_fake_return;
                        }
                        { "youtube".into() }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, id))]
            fn match_id(&self, id: String) -> bool {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "match_id",
                                        "app_lib::providers::youtube",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/providers/youtube.rs",
                                        ),
                                        ::core::option::Option::Some(350u32),
                                        ::core::option::Option::Some("app_lib::providers::youtube"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: bool = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            id.starts_with("youtube-playlist:")
                                || id.starts_with("youtube-artist:")
                                || id.starts_with("youtube-album:")
                                || id.starts_with("youtube:")
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, __arg1))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn login<'life0, 'async_trait>(
                &'life0 mut self,
                __arg1: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<()>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "login",
                                    "app_lib::providers::youtube",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/youtube.rs",
                                    ),
                                    ::core::option::Option::Some(358u32),
                                    ::core::option::Option::Some("app_lib::providers::youtube"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["__arg1"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&__arg1) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<()>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let mut __self = self;
                        let __arg1 = __arg1;
                        let __ret: Result<()> = {
                            __self.verifier = login(
                                LoginArgs {
                                    client_id: __self.config.client_id.clone(),
                                    client_secret: __self.config.client_secret.clone(),
                                    scopes: __self.config.scopes.clone(),
                                    extra_params: Some(
                                        HashMap::from([
                                            ("prompt", "consent"),
                                            ("access_type", "offline"),
                                        ]),
                                    ),
                                },
                                __self.get_oauth_client(),
                                &__self.app,
                            )?;
                            let oauth_handler: State<OAuthHandler> = __self.app.state();
                            oauth_handler
                                .register_oauth_path(
                                    "youtubeoauthcallback".into(),
                                    __self.key(),
                                );
                            Ok(())
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, __arg1))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn signout<'life0, 'async_trait>(
                &'life0 mut self,
                __arg1: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<()>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "signout",
                                    "app_lib::providers::youtube",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/youtube.rs",
                                    ),
                                    ::core::option::Option::Some(380u32),
                                    ::core::option::Option::Some("app_lib::providers::youtube"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["__arg1"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&__arg1) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<()>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let mut __self = self;
                        let __arg1 = __arg1;
                        let __ret: Result<()> = {
                            __self.api_client = None;
                            __self.verifier = None;
                            __self.config.tokens = None;
                            let preferences: State<PreferenceConfig> = __self
                                .app
                                .state();
                            preferences
                                .set_secure(
                                    "MoosyncYoutubeRefreshToken".into(),
                                    None::<String>,
                                )?;
                            let _ = __self
                                .status_tx
                                .send(ProviderStatus {
                                    key: __self.key(),
                                    name: "Youtube".into(),
                                    user_name: None,
                                    logged_in: false,
                                    bg_color: "#E62017".into(),
                                    account_id: "youtube".into(),
                                })
                                .await;
                            Ok(())
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, code))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn authorize<'life0, 'async_trait>(
                &'life0 mut self,
                code: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<()>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "authorize",
                                    "app_lib::providers::youtube",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/youtube.rs",
                                    ),
                                    ::core::option::Option::Some(404u32),
                                    ::core::option::Option::Some("app_lib::providers::youtube"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<()>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let mut __self = self;
                        let code = code;
                        let __ret: Result<()> = {
                            __self.config.tokens = Some(
                                authorize(
                                        "MoosyncYoutubeRefreshToken",
                                        code,
                                        &mut __self.verifier,
                                        &__self.app,
                                    )
                                    .await?,
                            );
                            __self.create_api_client().await;
                            __self.fetch_user_details().await.unwrap();
                            Ok(())
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, pagination))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fetch_user_playlists<'life0, 'async_trait>(
                &'life0 self,
                pagination: Pagination,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(Vec<QueryablePlaylist>, Pagination)>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "fetch_user_playlists",
                                    "app_lib::providers::youtube",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/youtube.rs",
                                    ),
                                    ::core::option::Option::Some(423u32),
                                    ::core::option::Option::Some("app_lib::providers::youtube"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<(Vec<QueryablePlaylist>, Pagination)>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let __self = self;
                        let pagination = pagination;
                        let __ret: Result<(Vec<QueryablePlaylist>, Pagination)> = {
                            if let Some(api_client) = &__self.api_client {
                                if !pagination.is_first && pagination.token.is_none() {
                                    return Ok((::alloc::vec::Vec::new(), pagination));
                                }
                                let mut builder = api_client
                                    .playlists()
                                    .list(
                                        &<[_]>::into_vec(
                                            #[rustc_box]
                                            ::alloc::boxed::Box::new([
                                                "id".into(),
                                                "contentDetails".into(),
                                                "snippet".into(),
                                            ]),
                                        ),
                                    )
                                    .mine(true)
                                    .max_results(50);
                                if let Some(next_page) = pagination.token.clone() {
                                    builder = builder.page_token(next_page.as_str());
                                }
                                let (_, resp) = builder.doit().await?;
                                let ret = if let Some(items) = resp.items {
                                    items
                                        .into_iter()
                                        .map(|p| __self.parse_playlist(p))
                                        .collect()
                                } else {
                                    ::alloc::vec::Vec::new()
                                };
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/providers/youtube.rs:454",
                                                "app_lib::providers::youtube",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some(
                                                    "src-tauri/src/providers/youtube.rs",
                                                ),
                                                ::core::option::Option::Some(454u32),
                                                ::core::option::Option::Some("app_lib::providers::youtube"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("got user playlists: {0:?}", ret)
                                                                    as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                return Ok((
                                    ret,
                                    pagination.next_page_wtoken(resp.next_page_token),
                                ));
                            }
                            Err("API client not initialized".into())
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, playlist_id, pagination))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn get_playlist_content<'life0, 'async_trait>(
                &'life0 self,
                playlist_id: String,
                pagination: Pagination,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(Vec<Song>, Pagination)>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "get_playlist_content",
                                    "app_lib::providers::youtube",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/youtube.rs",
                                    ),
                                    ::core::option::Option::Some(461u32),
                                    ::core::option::Option::Some("app_lib::providers::youtube"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<(Vec<Song>, Pagination)>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let __self = self;
                        let playlist_id = playlist_id;
                        let pagination = pagination;
                        let __ret: Result<(Vec<Song>, Pagination)> = {
                            let playlist_id = playlist_id
                                .strip_prefix("youtube-playlist:")
                                .unwrap_or(&playlist_id);
                            if let Some(api_client) = &__self.api_client {
                                if !pagination.is_first && pagination.token.is_none() {
                                    return Ok((::alloc::vec::Vec::new(), pagination));
                                }
                                let mut builder = api_client
                                    .playlist_items()
                                    .list(
                                        &<[_]>::into_vec(
                                            #[rustc_box]
                                            ::alloc::boxed::Box::new(["id".into(), "snippet".into()]),
                                        ),
                                    )
                                    .playlist_id(playlist_id)
                                    .max_results(50);
                                if let Some(next_page) = pagination.token.clone() {
                                    builder = builder.page_token(next_page.as_str());
                                }
                                let (_, resp) = builder.doit().await?;
                                let ret = if let Some(items) = resp.items {
                                    __self
                                        .fetch_song_details(
                                            items
                                                .iter()
                                                .filter_map(|item| {
                                                    item.snippet
                                                        .as_ref()
                                                        .and_then(|id| {
                                                            if let Some(video_id) = id.resource_id.as_ref() {
                                                                video_id.video_id.clone()
                                                            } else {
                                                                None
                                                            }
                                                        })
                                                })
                                                .collect(),
                                        )
                                        .await?
                                } else {
                                    ::alloc::vec::Vec::new()
                                };
                                return Ok((
                                    ret,
                                    pagination.next_page_wtoken(resp.next_page_token),
                                ));
                            }
                            if !pagination.is_first {
                                return Ok((
                                    ::alloc::vec::Vec::new(),
                                    pagination.next_page(),
                                ));
                            }
                            let youtube_scraper: State<YoutubeScraper> = __self
                                .app
                                .state();
                            let res = youtube_scraper
                                .get_playlist_content(
                                    playlist_id.to_string(),
                                    pagination.clone(),
                                )
                                .await?;
                            return Ok((res.songs, pagination.next_page()));
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, song, player))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn get_playback_url<'life0, 'async_trait>(
                &'life0 self,
                song: Song,
                player: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<String>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "get_playback_url",
                                    "app_lib::providers::youtube",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/youtube.rs",
                                    ),
                                    ::core::option::Option::Some(521u32),
                                    ::core::option::Option::Some("app_lib::providers::youtube"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<String>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let __self = self;
                        let song = song;
                        let player = player;
                        let __ret: Result<String> = {
                            if song.song.provider_extension.unwrap_or_default()
                                != __self.key() && player == "youtube"
                            {
                                let youtube_scraper: State<YoutubeScraper> = __self
                                    .app
                                    .state();
                                let res = youtube_scraper
                                    .search_yt(
                                        ::alloc::__export::must_use({
                                            let res = ::alloc::fmt::format(
                                                format_args!(
                                                    "{0} - {1}",
                                                    song
                                                        .artists
                                                        .unwrap_or_default()
                                                        .iter()
                                                        .filter_map(|a| a.artist_name.clone())
                                                        .collect::<Vec<String>>()
                                                        .join(", "),
                                                    song.song.title.unwrap_or_default(),
                                                ),
                                            );
                                            res
                                        }),
                                    )
                                    .await?;
                                if let Some(first) = res.songs.first() {
                                    return Ok(first.song.url.clone().unwrap());
                                }
                            }
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/providers/youtube.rs:542",
                                            "app_lib::providers::youtube",
                                            ::tracing::Level::INFO,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/providers/youtube.rs",
                                            ),
                                            ::core::option::Option::Some(542u32),
                                            ::core::option::Option::Some("app_lib::providers::youtube"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::INFO
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::INFO
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Fetching song for {0} player", player)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            if player == "local" {
                                let youtube_scraper: State<YoutubeScraper> = __self
                                    .app
                                    .state();
                                return youtube_scraper
                                    .get_video_url(song.song.url.clone().unwrap())
                                    .await;
                            } else {
                                return Ok(song.song.url.clone().unwrap());
                            }
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, term))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn search<'life0, 'async_trait>(
                &'life0 self,
                term: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<SearchResult>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "search",
                                    "app_lib::providers::youtube",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/youtube.rs",
                                    ),
                                    ::core::option::Option::Some(553u32),
                                    ::core::option::Option::Some("app_lib::providers::youtube"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<SearchResult>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let __self = self;
                        let term = term;
                        let __ret: Result<SearchResult> = {
                            if let Some(api_client) = &__self.api_client {
                                let mut songs = ::alloc::vec::Vec::new();
                                let song_details = {
                                    let (_, search_results) = api_client
                                        .search()
                                        .list(
                                            &<[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new(["snippet".into()]),
                                            ),
                                        )
                                        .add_type("video")
                                        .q(&term)
                                        .max_results(50)
                                        .doit()
                                        .await?;
                                    search_results
                                        .items
                                        .map_or(
                                            ::alloc::vec::Vec::new(),
                                            |items| {
                                                items
                                                    .into_iter()
                                                    .filter_map(|item| {
                                                        item.id.as_ref().and_then(|id| id.video_id.clone())
                                                    })
                                                    .collect()
                                            },
                                        )
                                };
                                if !song_details.is_empty() {
                                    songs
                                        .extend(__self.fetch_song_details(song_details).await?);
                                }
                                let playlists = {
                                    let (_, search_results) = api_client
                                        .search()
                                        .list(
                                            &<[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new(["snippet".into()]),
                                            ),
                                        )
                                        .add_type("playlist")
                                        .q(&term)
                                        .max_results(50)
                                        .doit()
                                        .await?;
                                    search_results
                                        .items
                                        .map_or(
                                            ::alloc::vec::Vec::new(),
                                            |items| {
                                                items
                                                    .into_iter()
                                                    .filter_map(|item| {
                                                        item.id
                                                            .as_ref()
                                                            .and_then(|id| {
                                                                id.playlist_id
                                                                    .as_ref()
                                                                    .map(|playlist_id| {
                                                                        let snippet = item.snippet.as_ref().unwrap();
                                                                        let playlist = Playlist {
                                                                            id: Some(playlist_id.clone()),
                                                                            snippet: Some(PlaylistSnippet {
                                                                                description: snippet.description.clone(),
                                                                                thumbnails: snippet.thumbnails.clone(),
                                                                                title: snippet.title.clone(),
                                                                                ..Default::default()
                                                                            }),
                                                                            ..Default::default()
                                                                        };
                                                                        __self.parse_playlist(playlist)
                                                                    })
                                                            })
                                                    })
                                                    .collect()
                                            },
                                        )
                                };
                                let artists = {
                                    let (_, search_results) = api_client
                                        .search()
                                        .list(
                                            &<[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new(["snippet".into()]),
                                            ),
                                        )
                                        .add_type("channel")
                                        .q(&term)
                                        .max_results(50)
                                        .doit()
                                        .await?;
                                    search_results
                                        .items
                                        .map_or(
                                            ::alloc::vec::Vec::new(),
                                            |items| {
                                                items
                                                    .into_iter()
                                                    .filter_map(|item| {
                                                        item.id
                                                            .as_ref()
                                                            .and_then(|id| {
                                                                id.channel_id
                                                                    .as_ref()
                                                                    .map(|channel_id| {
                                                                        let snippet = item.snippet.as_ref().unwrap();
                                                                        let channel = Channel {
                                                                            id: Some(channel_id.clone()),
                                                                            snippet: Some(ChannelSnippet {
                                                                                description: snippet.description.clone(),
                                                                                thumbnails: snippet.thumbnails.clone(),
                                                                                title: snippet.title.clone(),
                                                                                ..Default::default()
                                                                            }),
                                                                            ..Default::default()
                                                                        };
                                                                        __self.parse_channel(channel)
                                                                    })
                                                            })
                                                    })
                                                    .collect()
                                            },
                                        )
                                };
                                return Ok(SearchResult {
                                    songs,
                                    playlists,
                                    artists,
                                    ..Default::default()
                                });
                            }
                            let youtube_scraper: State<YoutubeScraper> = __self
                                .app
                                .state();
                            youtube_scraper.search_yt(term).await
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, url))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn match_url<'life0, 'async_trait>(
                &'life0 self,
                url: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<bool>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "match_url",
                                    "app_lib::providers::youtube",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/youtube.rs",
                                    ),
                                    ::core::option::Option::Some(616u32),
                                    ::core::option::Option::Some("app_lib::providers::youtube"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<bool>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let __self = self;
                        let url = url;
                        let __ret: Result<bool> = {
                            let re = Regex::new(
                                    r"^((?:https?:)?\/\/)?((?:www|m|music)\.)?((?:youtube\.com|youtu.be))(\/(?:[\w-]+\?v=|embed\/|v\/)?)([\w-]+)(\S+)?$",
                                )
                                .unwrap();
                            Ok(re.is_match(url.as_str()))
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, url))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn playlist_from_url<'life0, 'async_trait>(
                &'life0 self,
                url: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<QueryablePlaylist>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "playlist_from_url",
                                    "app_lib::providers::youtube",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/youtube.rs",
                                    ),
                                    ::core::option::Option::Some(625u32),
                                    ::core::option::Option::Some("app_lib::providers::youtube"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<QueryablePlaylist>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let __self = self;
                        let url = url;
                        let __ret: Result<QueryablePlaylist> = {
                            let playlist_id = Url::parse(url.as_str())
                                .map_err(|_| MoosyncError::String(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("Failed to parse URL {0}", url),
                                        );
                                        res
                                    }),
                                ))?;
                            let playlist_id = playlist_id
                                .query_pairs()
                                .find(|(k, _)| k == "list");
                            if playlist_id.is_none() {
                                return Err("Invalid URL".into());
                            }
                            let playlist_id = playlist_id.unwrap().1.to_string();
                            if let Some(api_client) = &__self.api_client {
                                let (_, playlists) = api_client
                                    .playlists()
                                    .list(
                                        &<[_]>::into_vec(
                                            #[rustc_box]
                                            ::alloc::boxed::Box::new([
                                                "id".into(),
                                                "contentDetails".into(),
                                                "snippet".into(),
                                            ]),
                                        ),
                                    )
                                    .add_id(playlist_id.as_str())
                                    .max_results(1)
                                    .doit()
                                    .await?;
                                if let Some(items) = playlists.items {
                                    if let Some(first) = items.first() {
                                        let parsed = __self.parse_playlist(first.clone());
                                        return Ok(parsed);
                                    }
                                }
                            }
                            let youtube_scraper: State<YoutubeScraper> = __self
                                .app
                                .state();
                            let res = youtube_scraper.search_yt(playlist_id).await?;
                            if let Some(first) = res.playlists.first() {
                                return Ok(first.clone());
                            }
                            Err("Playlist not found".into())
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self, url))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn song_from_url<'life0, 'async_trait>(
                &'life0 self,
                url: String,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<Song>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "song_from_url",
                                    "app_lib::providers::youtube",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/youtube.rs",
                                    ),
                                    ::core::option::Option::Some(667u32),
                                    ::core::option::Option::Some("app_lib::providers::youtube"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<Song>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let __self = self;
                        let url = url;
                        let __ret: Result<Song> = {
                            let parsed_url = Url::parse(url.as_str())
                                .map_err(|_| MoosyncError::String(
                                    ::alloc::__export::must_use({
                                        let res = ::alloc::fmt::format(
                                            format_args!("Failed to parse URL {0}", url),
                                        );
                                        res
                                    }),
                                ))?;
                            let video_id = parsed_url
                                .query_pairs()
                                .find(|(k, _)| k == "v");
                            if video_id.is_none() {
                                return Err("Invalid URL".into());
                            }
                            let video_id = video_id.unwrap().1.to_string();
                            let res = __self
                                .fetch_song_details(
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([video_id.clone()]),
                                    ),
                                )
                                .await;
                            if let Ok(songs) = res {
                                if let Some(song) = songs.first() {
                                    return Ok(song.clone());
                                }
                            }
                            let youtube_scraper: State<YoutubeScraper> = __self
                                .app
                                .state();
                            let res = youtube_scraper.get_video_by_id(video_id).await?;
                            Ok(res)
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
            #[tracing::instrument(level = "trace", skip(self))]
            #[allow(
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn get_suggestions<'life0, 'async_trait>(
                &'life0 self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<Vec<Song>>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    let __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "get_suggestions",
                                    "app_lib::providers::youtube",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/providers/youtube.rs",
                                    ),
                                    ::core::option::Option::Some(690u32),
                                    ::core::option::Option::Some("app_lib::providers::youtube"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    let __tracing_instrument_future = async move {
                        if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                            Result<Vec<Song>>,
                        > {
                            #[allow(unreachable_code)] return __ret;
                        }
                        let __self = self;
                        let __ret: Result<Vec<Song>> = {
                            if let Some(api_client) = &__self.api_client {
                                let (_, resp) = api_client
                                    .search()
                                    .list(
                                        &<[_]>::into_vec(
                                            #[rustc_box]
                                            ::alloc::boxed::Box::new(["snippet".into()]),
                                        ),
                                    )
                                    .video_category_id("10")
                                    .max_results(50)
                                    .add_type("video")
                                    .doit()
                                    .await?;
                                if let Some(items) = resp.items {
                                    let ids: Vec<String> = items
                                        .iter()
                                        .filter_map(|item| {
                                            item.id.as_ref().and_then(|id| id.video_id.clone())
                                        })
                                        .collect();
                                    if !ids.is_empty() {
                                        return __self.fetch_song_details(ids).await;
                                    }
                                }
                            }
                            Err("Api Client not initialized".into())
                        };
                        #[allow(unreachable_code)] __ret
                    };
                    if !__tracing_attr_span.is_disabled() {
                        tracing::Instrument::instrument(
                                __tracing_instrument_future,
                                __tracing_attr_span,
                            )
                            .await
                    } else {
                        __tracing_instrument_future.await
                    }
                })
            }
        }
    }
}
mod rodio {
    use macros::generate_command_async;
    use rodio_player::RodioPlayer;
    use tauri::State;
    #[tracing::instrument(level = "trace", skip())]
    pub fn get_rodio_state() -> RodioPlayer {
        let rodio = RodioPlayer::new();
        rodio
    }
    #[allow(unreachable_code, clippy::diverging_sub_expression)]
    const _: () = if false {
        trait AsyncCommandMustReturnResult {}
        impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
        let _check: types::errors::Result<()> = ::core::panicking::panic(
            "internal error: entered unreachable code",
        );
        let _: &dyn AsyncCommandMustReturnResult = &_check;
    };
    #[tracing::instrument(level = "trace", skip(db, src))]
    pub async fn rodio_load(
        db: State<'_, RodioPlayer>,
        src: String,
    ) -> types::errors::Result<()> {
        {}
        let __tracing_attr_span = {
            use ::tracing::__macro_support::Callsite as _;
            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "rodio_load",
                        "app_lib::rodio",
                        tracing::Level::TRACE,
                        ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                        ::core::option::Option::Some(10u32),
                        ::core::option::Option::Some("app_lib::rodio"),
                        ::tracing_core::field::FieldSet::new(
                            &["src"],
                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = __CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    __CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = __CALLSITE.metadata();
                ::tracing::Span::new(
                    meta,
                    &{
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = meta.fields().iter();
                        meta.fields()
                            .value_set(
                                &[
                                    (
                                        &::core::iter::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::core::option::Option::Some(
                                            &tracing::field::debug(&src) as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    },
                )
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    __CALLSITE.metadata(),
                );
                {};
                span
            }
        };
        let __tracing_instrument_future = async move {
            #[allow(
                unknown_lints,
                unreachable_code,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::unreachable,
                clippy::let_with_type_underscore,
                clippy::empty_loop
            )]
            if false {
                let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                return __tracing_attr_fake_return;
            }
            {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event src-tauri/src/rodio/mod.rs:10",
                                "app_lib::rodio",
                                ::tracing::Level::INFO,
                                ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                                ::core::option::Option::Some(10u32),
                                ::core::option::Option::Some("app_lib::rodio"),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::INFO
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &format_args!("calling async {0}", "rodio_load")
                                                    as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let ret = db.rodio_load(src).await;
                if let Ok(ret) = &ret {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/rodio/mod.rs:10",
                                    "app_lib::rodio",
                                    ::tracing::Level::TRACE,
                                    ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                                    ::core::option::Option::Some(10u32),
                                    ::core::option::Option::Some("app_lib::rodio"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/rodio/mod.rs:10",
                                    "app_lib::rodio",
                                    ::tracing::Level::ERROR,
                                    ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                                    ::core::option::Option::Some(10u32),
                                    ::core::option::Option::Some("app_lib::rodio"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::ERROR
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::ERROR
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Error getting result {0:?}", ret)
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                }
                ret
            }
        };
        if !__tracing_attr_span.is_disabled() {
            tracing::Instrument::instrument(
                    __tracing_instrument_future,
                    __tracing_attr_span,
                )
                .await
        } else {
            __tracing_instrument_future.await
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__rodio_load;
    #[allow(unreachable_code, clippy::diverging_sub_expression)]
    const _: () = if false {
        trait AsyncCommandMustReturnResult {}
        impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
        let _check: types::errors::Result<()> = ::core::panicking::panic(
            "internal error: entered unreachable code",
        );
        let _: &dyn AsyncCommandMustReturnResult = &_check;
    };
    #[tracing::instrument(level = "trace", skip(db))]
    pub async fn rodio_play(db: State<'_, RodioPlayer>) -> types::errors::Result<()> {
        {}
        let __tracing_attr_span = {
            use ::tracing::__macro_support::Callsite as _;
            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "rodio_play",
                        "app_lib::rodio",
                        tracing::Level::TRACE,
                        ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                        ::core::option::Option::Some(11u32),
                        ::core::option::Option::Some("app_lib::rodio"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = __CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    __CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = __CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    __CALLSITE.metadata(),
                );
                {};
                span
            }
        };
        let __tracing_instrument_future = async move {
            #[allow(
                unknown_lints,
                unreachable_code,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::unreachable,
                clippy::let_with_type_underscore,
                clippy::empty_loop
            )]
            if false {
                let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                return __tracing_attr_fake_return;
            }
            {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event src-tauri/src/rodio/mod.rs:11",
                                "app_lib::rodio",
                                ::tracing::Level::INFO,
                                ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                                ::core::option::Option::Some(11u32),
                                ::core::option::Option::Some("app_lib::rodio"),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::INFO
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &format_args!("calling async {0}", "rodio_play")
                                                    as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let ret = db.rodio_play().await;
                if let Ok(ret) = &ret {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/rodio/mod.rs:11",
                                    "app_lib::rodio",
                                    ::tracing::Level::TRACE,
                                    ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                                    ::core::option::Option::Some(11u32),
                                    ::core::option::Option::Some("app_lib::rodio"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/rodio/mod.rs:11",
                                    "app_lib::rodio",
                                    ::tracing::Level::ERROR,
                                    ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                                    ::core::option::Option::Some(11u32),
                                    ::core::option::Option::Some("app_lib::rodio"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::ERROR
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::ERROR
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Error getting result {0:?}", ret)
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                }
                ret
            }
        };
        if !__tracing_attr_span.is_disabled() {
            tracing::Instrument::instrument(
                    __tracing_instrument_future,
                    __tracing_attr_span,
                )
                .await
        } else {
            __tracing_instrument_future.await
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__rodio_play;
    #[allow(unreachable_code, clippy::diverging_sub_expression)]
    const _: () = if false {
        trait AsyncCommandMustReturnResult {}
        impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
        let _check: types::errors::Result<()> = ::core::panicking::panic(
            "internal error: entered unreachable code",
        );
        let _: &dyn AsyncCommandMustReturnResult = &_check;
    };
    #[tracing::instrument(level = "trace", skip(db))]
    pub async fn rodio_pause(db: State<'_, RodioPlayer>) -> types::errors::Result<()> {
        {}
        let __tracing_attr_span = {
            use ::tracing::__macro_support::Callsite as _;
            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "rodio_pause",
                        "app_lib::rodio",
                        tracing::Level::TRACE,
                        ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                        ::core::option::Option::Some(12u32),
                        ::core::option::Option::Some("app_lib::rodio"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = __CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    __CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = __CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    __CALLSITE.metadata(),
                );
                {};
                span
            }
        };
        let __tracing_instrument_future = async move {
            #[allow(
                unknown_lints,
                unreachable_code,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::unreachable,
                clippy::let_with_type_underscore,
                clippy::empty_loop
            )]
            if false {
                let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                return __tracing_attr_fake_return;
            }
            {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event src-tauri/src/rodio/mod.rs:12",
                                "app_lib::rodio",
                                ::tracing::Level::INFO,
                                ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                                ::core::option::Option::Some(12u32),
                                ::core::option::Option::Some("app_lib::rodio"),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::INFO
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &format_args!("calling async {0}", "rodio_pause")
                                                    as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let ret = db.rodio_pause().await;
                if let Ok(ret) = &ret {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/rodio/mod.rs:12",
                                    "app_lib::rodio",
                                    ::tracing::Level::TRACE,
                                    ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                                    ::core::option::Option::Some(12u32),
                                    ::core::option::Option::Some("app_lib::rodio"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/rodio/mod.rs:12",
                                    "app_lib::rodio",
                                    ::tracing::Level::ERROR,
                                    ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                                    ::core::option::Option::Some(12u32),
                                    ::core::option::Option::Some("app_lib::rodio"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::ERROR
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::ERROR
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Error getting result {0:?}", ret)
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                }
                ret
            }
        };
        if !__tracing_attr_span.is_disabled() {
            tracing::Instrument::instrument(
                    __tracing_instrument_future,
                    __tracing_attr_span,
                )
                .await
        } else {
            __tracing_instrument_future.await
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__rodio_pause;
    #[allow(unreachable_code, clippy::diverging_sub_expression)]
    const _: () = if false {
        trait AsyncCommandMustReturnResult {}
        impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
        let _check: types::errors::Result<()> = ::core::panicking::panic(
            "internal error: entered unreachable code",
        );
        let _: &dyn AsyncCommandMustReturnResult = &_check;
    };
    #[tracing::instrument(level = "trace", skip(db))]
    pub async fn rodio_stop(db: State<'_, RodioPlayer>) -> types::errors::Result<()> {
        {}
        let __tracing_attr_span = {
            use ::tracing::__macro_support::Callsite as _;
            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "rodio_stop",
                        "app_lib::rodio",
                        tracing::Level::TRACE,
                        ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                        ::core::option::Option::Some(13u32),
                        ::core::option::Option::Some("app_lib::rodio"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = __CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    __CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = __CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    __CALLSITE.metadata(),
                );
                {};
                span
            }
        };
        let __tracing_instrument_future = async move {
            #[allow(
                unknown_lints,
                unreachable_code,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::unreachable,
                clippy::let_with_type_underscore,
                clippy::empty_loop
            )]
            if false {
                let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                return __tracing_attr_fake_return;
            }
            {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event src-tauri/src/rodio/mod.rs:13",
                                "app_lib::rodio",
                                ::tracing::Level::INFO,
                                ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                                ::core::option::Option::Some(13u32),
                                ::core::option::Option::Some("app_lib::rodio"),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::INFO
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &format_args!("calling async {0}", "rodio_stop")
                                                    as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let ret = db.rodio_stop().await;
                if let Ok(ret) = &ret {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/rodio/mod.rs:13",
                                    "app_lib::rodio",
                                    ::tracing::Level::TRACE,
                                    ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                                    ::core::option::Option::Some(13u32),
                                    ::core::option::Option::Some("app_lib::rodio"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/rodio/mod.rs:13",
                                    "app_lib::rodio",
                                    ::tracing::Level::ERROR,
                                    ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                                    ::core::option::Option::Some(13u32),
                                    ::core::option::Option::Some("app_lib::rodio"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::ERROR
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::ERROR
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Error getting result {0:?}", ret)
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                }
                ret
            }
        };
        if !__tracing_attr_span.is_disabled() {
            tracing::Instrument::instrument(
                    __tracing_instrument_future,
                    __tracing_attr_span,
                )
                .await
        } else {
            __tracing_instrument_future.await
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__rodio_stop;
    #[allow(unreachable_code, clippy::diverging_sub_expression)]
    const _: () = if false {
        trait AsyncCommandMustReturnResult {}
        impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
        let _check: types::errors::Result<()> = ::core::panicking::panic(
            "internal error: entered unreachable code",
        );
        let _: &dyn AsyncCommandMustReturnResult = &_check;
    };
    #[tracing::instrument(level = "trace", skip(db, pos))]
    pub async fn rodio_seek(
        db: State<'_, RodioPlayer>,
        pos: f64,
    ) -> types::errors::Result<()> {
        {}
        let __tracing_attr_span = {
            use ::tracing::__macro_support::Callsite as _;
            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "rodio_seek",
                        "app_lib::rodio",
                        tracing::Level::TRACE,
                        ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                        ::core::option::Option::Some(14u32),
                        ::core::option::Option::Some("app_lib::rodio"),
                        ::tracing_core::field::FieldSet::new(
                            &["pos"],
                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = __CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    __CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = __CALLSITE.metadata();
                ::tracing::Span::new(
                    meta,
                    &{
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = meta.fields().iter();
                        meta.fields()
                            .value_set(
                                &[
                                    (
                                        &::core::iter::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::core::option::Option::Some(
                                            &tracing::field::debug(&pos) as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    },
                )
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    __CALLSITE.metadata(),
                );
                {};
                span
            }
        };
        let __tracing_instrument_future = async move {
            #[allow(
                unknown_lints,
                unreachable_code,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::unreachable,
                clippy::let_with_type_underscore,
                clippy::empty_loop
            )]
            if false {
                let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                return __tracing_attr_fake_return;
            }
            {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event src-tauri/src/rodio/mod.rs:14",
                                "app_lib::rodio",
                                ::tracing::Level::INFO,
                                ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                                ::core::option::Option::Some(14u32),
                                ::core::option::Option::Some("app_lib::rodio"),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::INFO
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &format_args!("calling async {0}", "rodio_seek")
                                                    as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let ret = db.rodio_seek(pos).await;
                if let Ok(ret) = &ret {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/rodio/mod.rs:14",
                                    "app_lib::rodio",
                                    ::tracing::Level::TRACE,
                                    ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                                    ::core::option::Option::Some(14u32),
                                    ::core::option::Option::Some("app_lib::rodio"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/rodio/mod.rs:14",
                                    "app_lib::rodio",
                                    ::tracing::Level::ERROR,
                                    ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                                    ::core::option::Option::Some(14u32),
                                    ::core::option::Option::Some("app_lib::rodio"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::ERROR
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::ERROR
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Error getting result {0:?}", ret)
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                }
                ret
            }
        };
        if !__tracing_attr_span.is_disabled() {
            tracing::Instrument::instrument(
                    __tracing_instrument_future,
                    __tracing_attr_span,
                )
                .await
        } else {
            __tracing_instrument_future.await
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__rodio_seek;
    #[allow(unreachable_code, clippy::diverging_sub_expression)]
    const _: () = if false {
        trait AsyncCommandMustReturnResult {}
        impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
        let _check: types::errors::Result<()> = ::core::panicking::panic(
            "internal error: entered unreachable code",
        );
        let _: &dyn AsyncCommandMustReturnResult = &_check;
    };
    #[tracing::instrument(level = "trace", skip(db, volume))]
    pub async fn rodio_set_volume(
        db: State<'_, RodioPlayer>,
        volume: f32,
    ) -> types::errors::Result<()> {
        {}
        let __tracing_attr_span = {
            use ::tracing::__macro_support::Callsite as _;
            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "rodio_set_volume",
                        "app_lib::rodio",
                        tracing::Level::TRACE,
                        ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                        ::core::option::Option::Some(15u32),
                        ::core::option::Option::Some("app_lib::rodio"),
                        ::tracing_core::field::FieldSet::new(
                            &["volume"],
                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = __CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    __CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = __CALLSITE.metadata();
                ::tracing::Span::new(
                    meta,
                    &{
                        #[allow(unused_imports)]
                        use ::tracing::field::{debug, display, Value};
                        let mut iter = meta.fields().iter();
                        meta.fields()
                            .value_set(
                                &[
                                    (
                                        &::core::iter::Iterator::next(&mut iter)
                                            .expect("FieldSet corrupted (this is a bug)"),
                                        ::core::option::Option::Some(
                                            &tracing::field::debug(&volume) as &dyn Value,
                                        ),
                                    ),
                                ],
                            )
                    },
                )
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    __CALLSITE.metadata(),
                );
                {};
                span
            }
        };
        let __tracing_instrument_future = async move {
            #[allow(
                unknown_lints,
                unreachable_code,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::unreachable,
                clippy::let_with_type_underscore,
                clippy::empty_loop
            )]
            if false {
                let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                return __tracing_attr_fake_return;
            }
            {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event src-tauri/src/rodio/mod.rs:15",
                                "app_lib::rodio",
                                ::tracing::Level::INFO,
                                ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                                ::core::option::Option::Some(15u32),
                                ::core::option::Option::Some("app_lib::rodio"),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::INFO
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &format_args!("calling async {0}", "rodio_set_volume")
                                                    as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let ret = db.rodio_set_volume(volume).await;
                if let Ok(ret) = &ret {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/rodio/mod.rs:15",
                                    "app_lib::rodio",
                                    ::tracing::Level::TRACE,
                                    ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                                    ::core::option::Option::Some(15u32),
                                    ::core::option::Option::Some("app_lib::rodio"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/rodio/mod.rs:15",
                                    "app_lib::rodio",
                                    ::tracing::Level::ERROR,
                                    ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                                    ::core::option::Option::Some(15u32),
                                    ::core::option::Option::Some("app_lib::rodio"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::ERROR
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::ERROR
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Error getting result {0:?}", ret)
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                }
                ret
            }
        };
        if !__tracing_attr_span.is_disabled() {
            tracing::Instrument::instrument(
                    __tracing_instrument_future,
                    __tracing_attr_span,
                )
                .await
        } else {
            __tracing_instrument_future.await
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__rodio_set_volume;
    #[allow(unreachable_code, clippy::diverging_sub_expression)]
    const _: () = if false {
        trait AsyncCommandMustReturnResult {}
        impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
        let _check: types::errors::Result<f32> = ::core::panicking::panic(
            "internal error: entered unreachable code",
        );
        let _: &dyn AsyncCommandMustReturnResult = &_check;
    };
    #[tracing::instrument(level = "trace", skip(db))]
    pub async fn rodio_get_volume(
        db: State<'_, RodioPlayer>,
    ) -> types::errors::Result<f32> {
        {}
        let __tracing_attr_span = {
            use ::tracing::__macro_support::Callsite as _;
            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                static META: ::tracing::Metadata<'static> = {
                    ::tracing_core::metadata::Metadata::new(
                        "rodio_get_volume",
                        "app_lib::rodio",
                        tracing::Level::TRACE,
                        ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                        ::core::option::Option::Some(16u32),
                        ::core::option::Option::Some("app_lib::rodio"),
                        ::tracing_core::field::FieldSet::new(
                            &[],
                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                        ),
                        ::tracing::metadata::Kind::SPAN,
                    )
                };
                ::tracing::callsite::DefaultCallsite::new(&META)
            };
            let mut interest = ::tracing::subscriber::Interest::never();
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current()
                && {
                    interest = __CALLSITE.interest();
                    !interest.is_never()
                }
                && ::tracing::__macro_support::__is_enabled(
                    __CALLSITE.metadata(),
                    interest,
                )
            {
                let meta = __CALLSITE.metadata();
                ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
            } else {
                let span = ::tracing::__macro_support::__disabled_span(
                    __CALLSITE.metadata(),
                );
                {};
                span
            }
        };
        let __tracing_instrument_future = async move {
            #[allow(
                unknown_lints,
                unreachable_code,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::unreachable,
                clippy::let_with_type_underscore,
                clippy::empty_loop
            )]
            if false {
                let __tracing_attr_fake_return: types::errors::Result<f32> = loop {};
                return __tracing_attr_fake_return;
            }
            {
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event src-tauri/src/rodio/mod.rs:16",
                                "app_lib::rodio",
                                ::tracing::Level::INFO,
                                ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                                ::core::option::Option::Some(16u32),
                                ::core::option::Option::Some("app_lib::rodio"),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::INFO
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::INFO
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &format_args!("calling async {0}", "rodio_get_volume")
                                                    as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let ret = db.rodio_get_volume().await;
                if let Ok(ret) = &ret {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/rodio/mod.rs:16",
                                    "app_lib::rodio",
                                    ::tracing::Level::TRACE,
                                    ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                                    ::core::option::Option::Some(16u32),
                                    ::core::option::Option::Some("app_lib::rodio"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                } else {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/rodio/mod.rs:16",
                                    "app_lib::rodio",
                                    ::tracing::Level::ERROR,
                                    ::core::option::Option::Some("src-tauri/src/rodio/mod.rs"),
                                    ::core::option::Option::Some(16u32),
                                    ::core::option::Option::Some("app_lib::rodio"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::ERROR
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::ERROR
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("Error getting result {0:?}", ret)
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                }
                ret
            }
        };
        if !__tracing_attr_span.is_disabled() {
            tracing::Instrument::instrument(
                    __tracing_instrument_future,
                    __tracing_attr_span,
                )
                .await
        } else {
            __tracing_instrument_future.await
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__rodio_get_volume;
}
mod scanner {
    use database::database::Database;
    use file_scanner::scanner::ScannerHolder;
    use preferences::preferences::PreferenceConfig;
    use tauri::State;
    use types::errors::Result;
    #[tracing::instrument(level = "trace", skip())]
    pub fn get_scanner_state() -> ScannerHolder {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "get_scanner_state",
                                "app_lib::scanner",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/scanner/mod.rs",
                                ),
                                ::core::option::Option::Some(7u32),
                                ::core::option::Option::Some("app_lib::scanner"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: ScannerHolder = loop {};
                    return __tracing_attr_fake_return;
                }
                { ScannerHolder::new() }
            }
        }
    }
    #[tracing::instrument(level = "trace", skip(preferences))]
    fn get_scan_paths(preferences: &State<PreferenceConfig>) -> Result<Vec<String>> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "get_scan_paths",
                                "app_lib::scanner",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/scanner/mod.rs",
                                ),
                                ::core::option::Option::Some(12u32),
                                ::core::option::Option::Some("app_lib::scanner"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: Result<Vec<String>> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    let tmp: Vec<String> = preferences
                        .load_selective("music_paths".to_string())?;
                    Ok(tmp)
                }
            }
        }
    }
    #[tracing::instrument(level = "trace", skip(scanner, database, preferences, paths, force))]
    pub fn start_scan(
        scanner: State<ScannerHolder>,
        database: State<Database>,
        preferences: State<PreferenceConfig>,
        mut paths: Option<Vec<String>>,
        force: bool,
    ) -> Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "start_scan",
                                "app_lib::scanner",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/scanner/mod.rs",
                                ),
                                ::core::option::Option::Some(20u32),
                                ::core::option::Option::Some("app_lib::scanner"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    if paths.is_none() {
                        paths = Some(get_scan_paths(&preferences)?);
                    }
                    let thumbnail_dir: String = preferences
                        .load_selective("thumbnail_path".to_string())?;
                    let artist_split: String = preferences
                        .load_selective("artist_splitter".to_string())
                        .unwrap_or(";".to_string());
                    let scan_threads: f64 = preferences
                        .load_selective("scan_threads".to_string())
                        .unwrap_or(-1f64);
                    for path in paths.unwrap() {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/scanner/mod.rs:44",
                                        "app_lib::scanner",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/scanner/mod.rs",
                                        ),
                                        ::core::option::Option::Some(44u32),
                                        ::core::option::Option::Some("app_lib::scanner"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Scanning path: {0}", path) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        scanner
                            .start_scan(
                                database.inner(),
                                path,
                                thumbnail_dir.clone(),
                                artist_split.clone(),
                                scan_threads,
                                force,
                            )?;
                    }
                    Ok(())
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__start_scan;
}
mod themes {
    use std::{collections::HashMap, fs};
    use macros::generate_command;
    use tauri::{App, AppHandle, Manager, State};
    use themes::themes::ThemeHolder;
    use types::{errors::Result, themes::ThemeDetails};
    use crate::window::handler::WindowHandler;
    #[tracing::instrument(level = "trace", skip(app))]
    pub fn get_theme_handler_state(app: &mut App) -> ThemeHolder {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "get_theme_handler_state",
                                "app_lib::themes",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                ::core::option::Option::Some(10u32),
                                ::core::option::Option::Some("app_lib::themes"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: ThemeHolder = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    let path = app.path().app_local_data_dir().unwrap().join("themes");
                    if !path.exists() {
                        fs::create_dir_all(path.clone()).unwrap();
                    }
                    let tmp_dir = app.path().temp_dir().unwrap();
                    ThemeHolder::new(path, tmp_dir)
                }
            }
        }
    }
    #[tracing::instrument(level = "trace", skip(app, theme_handler, window_handler, id))]
    pub fn export_theme(
        app: AppHandle,
        theme_handler: State<ThemeHolder>,
        window_handler: State<WindowHandler>,
        id: String,
    ) -> Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "export_theme",
                                "app_lib::themes",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                ::core::option::Option::Some(22u32),
                                ::core::option::Option::Some("app_lib::themes"),
                                ::tracing_core::field::FieldSet::new(
                                    &["id"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&id) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    let selected_file = window_handler.open_save_file(app)?;
                    theme_handler.export_theme(id, selected_file)?;
                    Ok(())
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__export_theme;
    #[tracing::instrument(level = "trace", skip(db, theme))]
    pub fn save_theme(
        db: State<ThemeHolder>,
        theme: ThemeDetails,
    ) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "save_theme",
                                "app_lib::themes",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                ::core::option::Option::Some(35u32),
                                ::core::option::Option::Some("app_lib::themes"),
                                ::tracing_core::field::FieldSet::new(
                                    &["theme"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&theme) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/themes/mod.rs:35",
                                    "app_lib::themes",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                    ::core::option::Option::Some(35u32),
                                    ::core::option::Option::Some("app_lib::themes"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "save_theme") as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.save_theme(theme);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/themes/mod.rs:35",
                                        "app_lib::themes",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                        ::core::option::Option::Some(35u32),
                                        ::core::option::Option::Some("app_lib::themes"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/themes/mod.rs:35",
                                        "app_lib::themes",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                        ::core::option::Option::Some(35u32),
                                        ::core::option::Option::Some("app_lib::themes"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__save_theme;
    #[tracing::instrument(level = "trace", skip(db, id))]
    pub fn remove_theme(
        db: State<ThemeHolder>,
        id: String,
    ) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "remove_theme",
                                "app_lib::themes",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                ::core::option::Option::Some(36u32),
                                ::core::option::Option::Some("app_lib::themes"),
                                ::tracing_core::field::FieldSet::new(
                                    &["id"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&id) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/themes/mod.rs:36",
                                    "app_lib::themes",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                    ::core::option::Option::Some(36u32),
                                    ::core::option::Option::Some("app_lib::themes"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "remove_theme") as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.remove_theme(id);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/themes/mod.rs:36",
                                        "app_lib::themes",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                        ::core::option::Option::Some(36u32),
                                        ::core::option::Option::Some("app_lib::themes"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/themes/mod.rs:36",
                                        "app_lib::themes",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                        ::core::option::Option::Some(36u32),
                                        ::core::option::Option::Some("app_lib::themes"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__remove_theme;
    #[tracing::instrument(level = "trace", skip(db, id))]
    pub fn load_theme(
        db: State<ThemeHolder>,
        id: String,
    ) -> types::errors::Result<ThemeDetails> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "load_theme",
                                "app_lib::themes",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                ::core::option::Option::Some(37u32),
                                ::core::option::Option::Some("app_lib::themes"),
                                ::tracing_core::field::FieldSet::new(
                                    &["id"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&id) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<
                        ThemeDetails,
                    > = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/themes/mod.rs:37",
                                    "app_lib::themes",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                    ::core::option::Option::Some(37u32),
                                    ::core::option::Option::Some("app_lib::themes"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "load_theme") as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.load_theme(id);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/themes/mod.rs:37",
                                        "app_lib::themes",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                        ::core::option::Option::Some(37u32),
                                        ::core::option::Option::Some("app_lib::themes"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/themes/mod.rs:37",
                                        "app_lib::themes",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                        ::core::option::Option::Some(37u32),
                                        ::core::option::Option::Some("app_lib::themes"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__load_theme;
    #[tracing::instrument(level = "trace", skip(db))]
    pub fn load_all_themes(
        db: State<ThemeHolder>,
    ) -> types::errors::Result<HashMap<String, ThemeDetails>> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "load_all_themes",
                                "app_lib::themes",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                ::core::option::Option::Some(38u32),
                                ::core::option::Option::Some("app_lib::themes"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<
                        HashMap<String, ThemeDetails>,
                    > = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/themes/mod.rs:38",
                                    "app_lib::themes",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                    ::core::option::Option::Some(38u32),
                                    ::core::option::Option::Some("app_lib::themes"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "load_all_themes")
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.load_all_themes();
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/themes/mod.rs:38",
                                        "app_lib::themes",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                        ::core::option::Option::Some(38u32),
                                        ::core::option::Option::Some("app_lib::themes"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/themes/mod.rs:38",
                                        "app_lib::themes",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                        ::core::option::Option::Some(38u32),
                                        ::core::option::Option::Some("app_lib::themes"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__load_all_themes;
    #[tracing::instrument(level = "trace", skip(db, path))]
    pub fn import_theme(
        db: State<ThemeHolder>,
        path: String,
    ) -> types::errors::Result<()> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "import_theme",
                                "app_lib::themes",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                ::core::option::Option::Some(39u32),
                                ::core::option::Option::Some("app_lib::themes"),
                                ::tracing_core::field::FieldSet::new(
                                    &["path"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&path) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/themes/mod.rs:39",
                                    "app_lib::themes",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                    ::core::option::Option::Some(39u32),
                                    ::core::option::Option::Some("app_lib::themes"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "import_theme") as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.import_theme(path);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/themes/mod.rs:39",
                                        "app_lib::themes",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                        ::core::option::Option::Some(39u32),
                                        ::core::option::Option::Some("app_lib::themes"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/themes/mod.rs:39",
                                        "app_lib::themes",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                        ::core::option::Option::Some(39u32),
                                        ::core::option::Option::Some("app_lib::themes"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__import_theme;
    #[tracing::instrument(level = "trace", skip(db, css_path, root))]
    pub fn transform_css(
        db: State<ThemeHolder>,
        css_path: String,
        root: Option<String>,
    ) -> types::errors::Result<String> {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "transform_css",
                                "app_lib::themes",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                ::core::option::Option::Some(40u32),
                                ::core::option::Option::Some("app_lib::themes"),
                                ::tracing_core::field::FieldSet::new(
                                    &["css_path", "root"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&css_path) as &dyn Value,
                                                ),
                                            ),
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &tracing::field::debug(&root) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<String> = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/themes/mod.rs:40",
                                    "app_lib::themes",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                    ::core::option::Option::Some(40u32),
                                    ::core::option::Option::Some("app_lib::themes"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling {0}", "transform_css") as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db.transform_css(css_path, root);
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/themes/mod.rs:40",
                                        "app_lib::themes",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                        ::core::option::Option::Some(40u32),
                                        ::core::option::Option::Some("app_lib::themes"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/themes/mod.rs:40",
                                        "app_lib::themes",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some("src-tauri/src/themes/mod.rs"),
                                        ::core::option::Option::Some(40u32),
                                        ::core::option::Option::Some("app_lib::themes"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            }
        }
    }
    #[allow(unused_imports)]
    pub use __cmd__transform_css;
}
mod window {
    pub mod handler {
        use std::env;
        use std::path::PathBuf;
        use macros::{generate_command, generate_command_async};
        use open;
        use preferences::preferences::PreferenceConfig;
        use serde_json::Value;
        use tauri::menu::{MenuBuilder, MenuItemBuilder};
        use tauri::tray::{MouseButton, MouseButtonState, TrayIconEvent};
        use tauri::{
            App, AppHandle, Emitter, Manager, State, WebviewWindow, WebviewWindowBuilder,
            Window,
        };
        use tauri_plugin_dialog::{DialogExt, FilePath};
        use types::errors::Result;
        use types::preferences::CheckboxPreference;
        use types::window::{DialogFilter, FileResponse};
        pub struct WindowHandler {}
        #[automatically_derived]
        impl ::core::fmt::Debug for WindowHandler {
            #[tracing::instrument(level = "trace", skip(self, f))]
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "WindowHandler")
            }
        }
        impl WindowHandler {
            #[tracing::instrument(level = "trace", skip())]
            pub fn new() -> WindowHandler {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "new",
                                        "app_lib::window::handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(20u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: WindowHandler = loop {};
                            return __tracing_attr_fake_return;
                        }
                        { WindowHandler {} }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, window))]
            pub fn is_maximized(&self, window: Window) -> Result<bool> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "is_maximized",
                                        "app_lib::window::handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(25u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<bool> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        { Ok(window.is_maximized()?) }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self))]
            pub fn has_frame(&self) -> Result<bool> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "has_frame",
                                        "app_lib::window::handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(30u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<bool> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        { Ok(true || false) }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, window))]
            pub fn close_window(&self, window: Window) -> Result<()> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "close_window",
                                        "app_lib::window::handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(35u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<()> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            window.close()?;
                            Ok(())
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self))]
            pub fn get_platform(&self) -> Result<String> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "get_platform",
                                        "app_lib::window::handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(41u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<String> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        { Ok(env::consts::OS.to_string()) }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, window))]
            pub fn maximize_window(&self, window: Window) -> Result<()> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "maximize_window",
                                        "app_lib::window::handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(46u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<()> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            window.maximize()?;
                            Ok(())
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, window))]
            pub fn minimize_window(&self, window: Window) -> Result<()> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "minimize_window",
                                        "app_lib::window::handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(52u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<()> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            window.minimize()?;
                            Ok(())
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, app, preference))]
            pub fn update_zoom(
                &self,
                app: AppHandle,
                preference: State<PreferenceConfig>,
            ) -> Result<()> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "update_zoom",
                                        "app_lib::window::handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(58u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<()> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            let scale_factor: f64 = preference
                                .load_selective("zoomFactor".into())?;
                            let windows = app.webview_windows();
                            for window in windows.values() {
                                window
                                    .with_webview(move |webview| {
                                        #[cfg(target_os = "linux")]
                                        {
                                            use webkit2gtk::WebViewExt;
                                            webview.inner().set_zoom_level(scale_factor);
                                        }
                                    })?;
                            }
                            Ok(())
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, url))]
            pub fn open_external(&self, url: String) -> Result<()> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "open_external",
                                        "app_lib::window::handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(89u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<()> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            open::that(url)?;
                            Ok(())
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, app, is_main_window))]
            pub fn open_window(
                &self,
                app: AppHandle,
                is_main_window: bool,
            ) -> Result<()> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "open_window",
                                        "app_lib::window::handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(95u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<()> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            if !is_main_window {
                                WebviewWindowBuilder::new(
                                        &app,
                                        "settings",
                                        tauri::WebviewUrl::App("/preferenceWindow".into()),
                                    )
                                    .build()?;
                            }
                            Ok(())
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, window))]
            pub fn enable_fullscreen(&self, window: Window) -> Result<()> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "enable_fullscreen",
                                        "app_lib::window::handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(109u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<()> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            window.set_fullscreen(true)?;
                            Ok(())
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, window))]
            pub fn disable_fullscreen(&self, window: Window) -> Result<()> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "disable_fullscreen",
                                        "app_lib::window::handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(115u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<()> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            window.set_fullscreen(false)?;
                            Ok(())
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, window))]
            pub fn toggle_fullscreen(&self, window: Window) -> Result<()> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "toggle_fullscreen",
                                        "app_lib::window::handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(121u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<()> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            let is_fullscreen = window.is_fullscreen()?;
                            window.set_fullscreen(!is_fullscreen)?;
                            Ok(())
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, window))]
            pub fn toggle_dev_tools(&self, window: WebviewWindow) -> Result<()> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "toggle_dev_tools",
                                        "app_lib::window::handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(128u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<()> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        { Ok(()) }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, app))]
            pub fn restart_app(&self, app: AppHandle) -> Result<()> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "restart_app",
                                        "app_lib::window::handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(140u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &[],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{ meta.fields().value_set(&[]) },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<()> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            app.restart();
                        }
                    }
                }
            }
            #[tracing::instrument(level = "trace", skip(self, app, directory, multiple, filters))]
            pub async fn open_file_browser(
                &self,
                app: AppHandle,
                directory: bool,
                multiple: bool,
                filters: Vec<DialogFilter>,
            ) -> Result<Vec<FileResponse>> {
                {}
                let __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "open_file_browser",
                                "app_lib::window::handler",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/window/handler.rs",
                                ),
                                ::core::option::Option::Some(145u32),
                                ::core::option::Option::Some("app_lib::window::handler"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                let __tracing_instrument_future = async move {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: Result<Vec<FileResponse>> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        let mut dialog = app.dialog().file();
                        for filter in filters {
                            dialog = dialog
                                .add_filter(
                                    filter.name,
                                    filter
                                        .extensions
                                        .iter()
                                        .map(|e| e.as_str())
                                        .collect::<Vec<&str>>()
                                        .as_slice(),
                                );
                        }
                        let files = if directory {
                            if multiple {
                                dialog
                                    .blocking_pick_folders()
                                    .map(|v| {
                                        v.iter()
                                            .filter_map(|f| {
                                                if let FilePath::Path(path) = f {
                                                    Some(path.clone())
                                                } else {
                                                    None
                                                }
                                            })
                                            .collect()
                                    })
                            } else {
                                let file_path = dialog.blocking_pick_folder();
                                if let Some(FilePath::Path(path)) = file_path {
                                    Some(
                                        <[_]>::into_vec(
                                            #[rustc_box]
                                            ::alloc::boxed::Box::new([path]),
                                        ),
                                    )
                                } else {
                                    Some(::alloc::vec::Vec::new())
                                }
                            }
                        } else if multiple {
                            dialog
                                .blocking_pick_files()
                                .map(|v| {
                                    v.iter()
                                        .filter_map(|f| {
                                            if let FilePath::Path(path) = f {
                                                Some(path.clone())
                                            } else {
                                                None
                                            }
                                        })
                                        .collect()
                                })
                        } else {
                            let file_path = dialog.blocking_pick_file();
                            if let Some(FilePath::Path(path)) = file_path {
                                Some(
                                    <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([path]),
                                    ),
                                )
                            } else {
                                Some(::alloc::vec::Vec::new())
                            }
                        };
                        let mut ret = ::alloc::vec::Vec::new();
                        if let Some(files) = files {
                            for file in files {
                                ret.push(FileResponse {
                                    name: file
                                        .file_name()
                                        .unwrap()
                                        .to_string_lossy()
                                        .to_string(),
                                    path: file.to_string_lossy().to_string(),
                                    size: 0,
                                })
                            }
                        }
                        Ok(ret)
                    }
                };
                if !__tracing_attr_span.is_disabled() {
                    tracing::Instrument::instrument(
                            __tracing_instrument_future,
                            __tracing_attr_span,
                        )
                        .await
                } else {
                    __tracing_instrument_future.await
                }
            }
            #[tracing::instrument(level = "trace", skip(self, app))]
            pub fn open_save_file(&self, app: AppHandle) -> Result<PathBuf> {
                {}
                #[allow(clippy::suspicious_else_formatting)]
                {
                    let __tracing_attr_span;
                    let __tracing_attr_guard;
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        || { false }
                    {
                        __tracing_attr_span = {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "open_save_file",
                                        "app_lib::window::handler",
                                        tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(222u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["app"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::SPAN,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let mut interest = ::tracing::subscriber::Interest::never();
                            if tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    interest = __CALLSITE.interest();
                                    !interest.is_never()
                                }
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                            {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Span::new(
                                    meta,
                                    &{
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = meta.fields().iter();
                                        meta.fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &tracing::field::debug(&app) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    },
                                )
                            } else {
                                let span = ::tracing::__macro_support::__disabled_span(
                                    __CALLSITE.metadata(),
                                );
                                {};
                                span
                            }
                        };
                        __tracing_attr_guard = __tracing_attr_span.enter();
                    }
                    #[warn(clippy::suspicious_else_formatting)]
                    {
                        #[allow(
                            unknown_lints,
                            unreachable_code,
                            clippy::diverging_sub_expression,
                            clippy::let_unit_value,
                            clippy::unreachable,
                            clippy::let_with_type_underscore,
                            clippy::empty_loop
                        )]
                        if false {
                            let __tracing_attr_fake_return: Result<PathBuf> = loop {};
                            return __tracing_attr_fake_return;
                        }
                        {
                            let res = app.dialog().file().blocking_save_file();
                            if let Some(FilePath::Path(path)) = res {
                                return Ok(path.clone());
                            }
                            Err("No file selected".into())
                        }
                    }
                }
            }
        }
        #[tracing::instrument(level = "trace", skip())]
        pub fn get_window_state() -> WindowHandler {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current() || { false }
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "get_window_state",
                                    "app_lib::window::handler",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/window/handler.rs",
                                    ),
                                    ::core::option::Option::Some(232u32),
                                    ::core::option::Option::Some("app_lib::window::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: WindowHandler = loop {};
                        return __tracing_attr_fake_return;
                    }
                    { WindowHandler::new() }
                }
            }
        }
        #[tracing::instrument(level = "trace", skip(app))]
        pub fn handle_window_close(app: &AppHandle) -> Result<bool> {
            let preferences: State<PreferenceConfig> = app.state();
            let preferences: CheckboxPreference = preferences
                .load_selective_array("system_settings.minimize_to_tray".into())?;
            if preferences.enabled {
                return Ok(false);
            }
            Ok(true)
        }
        #[tracing::instrument(level = "trace", skip(app))]
        pub fn build_tray_menu(app: &App) -> Result<()> {
            let menu = MenuBuilder::new(app)
                .icon("show", "Show App", app.default_window_icon().cloned().unwrap())
                .icon("play", "Play", app.default_window_icon().cloned().unwrap())
                .icon("pause", "Pause", app.default_window_icon().cloned().unwrap())
                .icon("next", "Next", app.default_window_icon().cloned().unwrap())
                .icon("prev", "Prev", app.default_window_icon().cloned().unwrap())
                .icon("quit", "Quit", app.default_window_icon().cloned().unwrap())
                .build()?;
            tauri::tray::TrayIconBuilder::new()
                .menu(&menu)
                .on_menu_event(move |app, event| match event.id().as_ref() {
                    "show" => {
                        let _ = app.get_webview_window("main").unwrap().show();
                    }
                    "play" => {
                        let _ = app.emit("media_button_press", (0, Value::Null));
                    }
                    "pause" => {
                        let _ = app.emit("media_button_press", (1, Value::Null));
                    }
                    "next" => {
                        let _ = app.emit("media_button_press", (6, Value::Null));
                    }
                    "prev" => {
                        let _ = app.emit("media_button_press", (7, Value::Null));
                    }
                    "quit" => {
                        app.exit(0);
                    }
                    _ => {}
                })
                .on_tray_icon_event(|tray, event| {
                    if let TrayIconEvent::Click {
                        button: MouseButton::Left,
                        button_state: MouseButtonState::Up,
                        ..
                    } = event {
                        let app = tray.app_handle();
                        if let Some(webview_window) = app.get_webview_window("main") {
                            let _ = webview_window.show();
                            let _ = webview_window.set_focus();
                        }
                    }
                })
                .build(app)?;
            Ok(())
        }
        #[tracing::instrument(level = "trace", skip(db, window))]
        pub fn is_maximized(
            db: State<WindowHandler>,
            window: Window,
        ) -> types::errors::Result<bool> {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current() || { false }
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "is_maximized",
                                    "app_lib::window::handler",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/window/handler.rs",
                                    ),
                                    ::core::option::Option::Some(307u32),
                                    ::core::option::Option::Some("app_lib::window::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["window"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&window) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: types::errors::Result<bool> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/window/handler.rs:307",
                                        "app_lib::window::handler",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(307u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("calling {0}", "is_maximized") as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        let ret = db.is_maximized(window);
                        if let Ok(ret) = &ret {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:307",
                                            "app_lib::window::handler",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(307u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        } else {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:307",
                                            "app_lib::window::handler",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(307u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Error getting result {0:?}", ret)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                        ret
                    }
                }
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__is_maximized;
        #[tracing::instrument(level = "trace", skip(db))]
        pub fn has_frame(db: State<WindowHandler>) -> types::errors::Result<bool> {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current() || { false }
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "has_frame",
                                    "app_lib::window::handler",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/window/handler.rs",
                                    ),
                                    ::core::option::Option::Some(308u32),
                                    ::core::option::Option::Some("app_lib::window::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: types::errors::Result<bool> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/window/handler.rs:308",
                                        "app_lib::window::handler",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(308u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("calling {0}", "has_frame") as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        let ret = db.has_frame();
                        if let Ok(ret) = &ret {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:308",
                                            "app_lib::window::handler",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(308u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        } else {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:308",
                                            "app_lib::window::handler",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(308u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Error getting result {0:?}", ret)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                        ret
                    }
                }
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__has_frame;
        #[tracing::instrument(level = "trace", skip(db, window))]
        pub fn close_window(
            db: State<WindowHandler>,
            window: Window,
        ) -> types::errors::Result<()> {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current() || { false }
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "close_window",
                                    "app_lib::window::handler",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/window/handler.rs",
                                    ),
                                    ::core::option::Option::Some(309u32),
                                    ::core::option::Option::Some("app_lib::window::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["window"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&window) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/window/handler.rs:309",
                                        "app_lib::window::handler",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(309u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("calling {0}", "close_window") as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        let ret = db.close_window(window);
                        if let Ok(ret) = &ret {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:309",
                                            "app_lib::window::handler",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(309u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        } else {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:309",
                                            "app_lib::window::handler",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(309u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Error getting result {0:?}", ret)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                        ret
                    }
                }
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__close_window;
        #[tracing::instrument(level = "trace", skip(db))]
        pub fn get_platform(db: State<WindowHandler>) -> types::errors::Result<String> {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current() || { false }
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "get_platform",
                                    "app_lib::window::handler",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/window/handler.rs",
                                    ),
                                    ::core::option::Option::Some(310u32),
                                    ::core::option::Option::Some("app_lib::window::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: types::errors::Result<String> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/window/handler.rs:310",
                                        "app_lib::window::handler",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(310u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("calling {0}", "get_platform") as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        let ret = db.get_platform();
                        if let Ok(ret) = &ret {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:310",
                                            "app_lib::window::handler",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(310u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        } else {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:310",
                                            "app_lib::window::handler",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(310u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Error getting result {0:?}", ret)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                        ret
                    }
                }
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__get_platform;
        #[tracing::instrument(level = "trace", skip(db, window))]
        pub fn maximize_window(
            db: State<WindowHandler>,
            window: Window,
        ) -> types::errors::Result<()> {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current() || { false }
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "maximize_window",
                                    "app_lib::window::handler",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/window/handler.rs",
                                    ),
                                    ::core::option::Option::Some(311u32),
                                    ::core::option::Option::Some("app_lib::window::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["window"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&window) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/window/handler.rs:311",
                                        "app_lib::window::handler",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(311u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("calling {0}", "maximize_window")
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        let ret = db.maximize_window(window);
                        if let Ok(ret) = &ret {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:311",
                                            "app_lib::window::handler",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(311u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        } else {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:311",
                                            "app_lib::window::handler",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(311u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Error getting result {0:?}", ret)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                        ret
                    }
                }
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__maximize_window;
        #[tracing::instrument(level = "trace", skip(db, window))]
        pub fn minimize_window(
            db: State<WindowHandler>,
            window: Window,
        ) -> types::errors::Result<()> {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current() || { false }
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "minimize_window",
                                    "app_lib::window::handler",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/window/handler.rs",
                                    ),
                                    ::core::option::Option::Some(312u32),
                                    ::core::option::Option::Some("app_lib::window::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["window"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&window) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/window/handler.rs:312",
                                        "app_lib::window::handler",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(312u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("calling {0}", "minimize_window")
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        let ret = db.minimize_window(window);
                        if let Ok(ret) = &ret {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:312",
                                            "app_lib::window::handler",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(312u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        } else {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:312",
                                            "app_lib::window::handler",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(312u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Error getting result {0:?}", ret)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                        ret
                    }
                }
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__minimize_window;
        #[tracing::instrument(level = "trace", skip(db, app, preference))]
        pub fn update_zoom(
            db: State<WindowHandler>,
            app: AppHandle,
            preference: State<PreferenceConfig>,
        ) -> types::errors::Result<()> {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current() || { false }
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "update_zoom",
                                    "app_lib::window::handler",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/window/handler.rs",
                                    ),
                                    ::core::option::Option::Some(313u32),
                                    ::core::option::Option::Some("app_lib::window::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["app", "preference"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&app) as &dyn Value,
                                                    ),
                                                ),
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&preference) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/window/handler.rs:313",
                                        "app_lib::window::handler",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(313u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("calling {0}", "update_zoom") as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        let ret = db.update_zoom(app, preference);
                        if let Ok(ret) = &ret {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:313",
                                            "app_lib::window::handler",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(313u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        } else {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:313",
                                            "app_lib::window::handler",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(313u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Error getting result {0:?}", ret)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                        ret
                    }
                }
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__update_zoom;
        #[tracing::instrument(level = "trace", skip(db, url))]
        pub fn open_external(
            db: State<WindowHandler>,
            url: String,
        ) -> types::errors::Result<()> {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current() || { false }
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "open_external",
                                    "app_lib::window::handler",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/window/handler.rs",
                                    ),
                                    ::core::option::Option::Some(314u32),
                                    ::core::option::Option::Some("app_lib::window::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["url"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&url) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/window/handler.rs:314",
                                        "app_lib::window::handler",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(314u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("calling {0}", "open_external") as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        let ret = db.open_external(url);
                        if let Ok(ret) = &ret {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:314",
                                            "app_lib::window::handler",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(314u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        } else {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:314",
                                            "app_lib::window::handler",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(314u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Error getting result {0:?}", ret)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                        ret
                    }
                }
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__open_external;
        #[tracing::instrument(level = "trace", skip(db, app, is_main_window))]
        pub fn open_window(
            db: State<WindowHandler>,
            app: AppHandle,
            is_main_window: bool,
        ) -> types::errors::Result<()> {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current() || { false }
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "open_window",
                                    "app_lib::window::handler",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/window/handler.rs",
                                    ),
                                    ::core::option::Option::Some(315u32),
                                    ::core::option::Option::Some("app_lib::window::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["app", "is_main_window"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&app) as &dyn Value,
                                                    ),
                                                ),
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&is_main_window) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/window/handler.rs:315",
                                        "app_lib::window::handler",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(315u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("calling {0}", "open_window") as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        let ret = db.open_window(app, is_main_window);
                        if let Ok(ret) = &ret {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:315",
                                            "app_lib::window::handler",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(315u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        } else {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:315",
                                            "app_lib::window::handler",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(315u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Error getting result {0:?}", ret)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                        ret
                    }
                }
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__open_window;
        #[tracing::instrument(level = "trace", skip(db, window))]
        pub fn enable_fullscreen(
            db: State<WindowHandler>,
            window: Window,
        ) -> types::errors::Result<()> {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current() || { false }
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "enable_fullscreen",
                                    "app_lib::window::handler",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/window/handler.rs",
                                    ),
                                    ::core::option::Option::Some(316u32),
                                    ::core::option::Option::Some("app_lib::window::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["window"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&window) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/window/handler.rs:316",
                                        "app_lib::window::handler",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(316u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("calling {0}", "enable_fullscreen")
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        let ret = db.enable_fullscreen(window);
                        if let Ok(ret) = &ret {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:316",
                                            "app_lib::window::handler",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(316u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        } else {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:316",
                                            "app_lib::window::handler",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(316u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Error getting result {0:?}", ret)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                        ret
                    }
                }
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__enable_fullscreen;
        #[tracing::instrument(level = "trace", skip(db, window))]
        pub fn disable_fullscreen(
            db: State<WindowHandler>,
            window: Window,
        ) -> types::errors::Result<()> {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current() || { false }
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "disable_fullscreen",
                                    "app_lib::window::handler",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/window/handler.rs",
                                    ),
                                    ::core::option::Option::Some(317u32),
                                    ::core::option::Option::Some("app_lib::window::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["window"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&window) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/window/handler.rs:317",
                                        "app_lib::window::handler",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(317u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("calling {0}", "disable_fullscreen")
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        let ret = db.disable_fullscreen(window);
                        if let Ok(ret) = &ret {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:317",
                                            "app_lib::window::handler",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(317u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        } else {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:317",
                                            "app_lib::window::handler",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(317u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Error getting result {0:?}", ret)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                        ret
                    }
                }
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__disable_fullscreen;
        #[tracing::instrument(level = "trace", skip(db, window))]
        pub fn toggle_fullscreen(
            db: State<WindowHandler>,
            window: Window,
        ) -> types::errors::Result<()> {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current() || { false }
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "toggle_fullscreen",
                                    "app_lib::window::handler",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/window/handler.rs",
                                    ),
                                    ::core::option::Option::Some(318u32),
                                    ::core::option::Option::Some("app_lib::window::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["window"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&window) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/window/handler.rs:318",
                                        "app_lib::window::handler",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(318u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("calling {0}", "toggle_fullscreen")
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        let ret = db.toggle_fullscreen(window);
                        if let Ok(ret) = &ret {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:318",
                                            "app_lib::window::handler",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(318u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        } else {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:318",
                                            "app_lib::window::handler",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(318u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Error getting result {0:?}", ret)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                        ret
                    }
                }
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__toggle_fullscreen;
        #[tracing::instrument(level = "trace", skip(db, window))]
        pub fn toggle_dev_tools(
            db: State<WindowHandler>,
            window: WebviewWindow,
        ) -> types::errors::Result<()> {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current() || { false }
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "toggle_dev_tools",
                                    "app_lib::window::handler",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/window/handler.rs",
                                    ),
                                    ::core::option::Option::Some(319u32),
                                    ::core::option::Option::Some("app_lib::window::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["window"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&window) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/window/handler.rs:319",
                                        "app_lib::window::handler",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(319u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("calling {0}", "toggle_dev_tools")
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        let ret = db.toggle_dev_tools(window);
                        if let Ok(ret) = &ret {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:319",
                                            "app_lib::window::handler",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(319u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        } else {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:319",
                                            "app_lib::window::handler",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(319u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Error getting result {0:?}", ret)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                        ret
                    }
                }
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__toggle_dev_tools;
        #[tracing::instrument(level = "trace", skip(db, app))]
        pub fn restart_app(
            db: State<WindowHandler>,
            app: AppHandle,
        ) -> types::errors::Result<()> {
            {}
            #[allow(clippy::suspicious_else_formatting)]
            {
                let __tracing_attr_span;
                let __tracing_attr_guard;
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current() || { false }
                {
                    __tracing_attr_span = {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "restart_app",
                                    "app_lib::window::handler",
                                    tracing::Level::TRACE,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/window/handler.rs",
                                    ),
                                    ::core::option::Option::Some(320u32),
                                    ::core::option::Option::Some("app_lib::window::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["app"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::SPAN,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let mut interest = ::tracing::subscriber::Interest::never();
                        if tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                interest = __CALLSITE.interest();
                                !interest.is_never()
                            }
                            && ::tracing::__macro_support::__is_enabled(
                                __CALLSITE.metadata(),
                                interest,
                            )
                        {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Span::new(
                                meta,
                                &{
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = meta.fields().iter();
                                    meta.fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &tracing::field::debug(&app) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                },
                            )
                        } else {
                            let span = ::tracing::__macro_support::__disabled_span(
                                __CALLSITE.metadata(),
                            );
                            {};
                            span
                        }
                    };
                    __tracing_attr_guard = __tracing_attr_span.enter();
                }
                #[warn(clippy::suspicious_else_formatting)]
                {
                    #[allow(
                        unknown_lints,
                        unreachable_code,
                        clippy::diverging_sub_expression,
                        clippy::let_unit_value,
                        clippy::unreachable,
                        clippy::let_with_type_underscore,
                        clippy::empty_loop
                    )]
                    if false {
                        let __tracing_attr_fake_return: types::errors::Result<()> = loop {};
                        return __tracing_attr_fake_return;
                    }
                    {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/window/handler.rs:320",
                                        "app_lib::window::handler",
                                        ::tracing::Level::INFO,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(320u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::INFO
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::INFO
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("calling {0}", "restart_app") as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        let ret = db.restart_app(app);
                        if let Ok(ret) = &ret {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:320",
                                            "app_lib::window::handler",
                                            ::tracing::Level::TRACE,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(320u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::TRACE
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        } else {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event src-tauri/src/window/handler.rs:320",
                                            "app_lib::window::handler",
                                            ::tracing::Level::ERROR,
                                            ::core::option::Option::Some(
                                                "src-tauri/src/window/handler.rs",
                                            ),
                                            ::core::option::Option::Some(320u32),
                                            ::core::option::Option::Some("app_lib::window::handler"),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::ERROR
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::core::iter::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::core::option::Option::Some(
                                                            &format_args!("Error getting result {0:?}", ret)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                        }
                        ret
                    }
                }
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__restart_app;
        #[allow(unreachable_code, clippy::diverging_sub_expression)]
        const _: () = if false {
            trait AsyncCommandMustReturnResult {}
            impl<A, B> AsyncCommandMustReturnResult for ::std::result::Result<A, B> {}
            let _check: types::errors::Result<Vec<FileResponse>> = ::core::panicking::panic(
                "internal error: entered unreachable code",
            );
            let _: &dyn AsyncCommandMustReturnResult = &_check;
        };
        #[tracing::instrument(level = "trace", skip(db, app, directory, multiple, filters))]
        pub async fn open_file_browser(
            db: State<'_, WindowHandler>,
            app: AppHandle,
            directory: bool,
            multiple: bool,
            filters: Vec<DialogFilter>,
        ) -> types::errors::Result<Vec<FileResponse>> {
            {}
            let __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "open_file_browser",
                            "app_lib::window::handler",
                            tracing::Level::TRACE,
                            ::core::option::Option::Some(
                                "src-tauri/src/window/handler.rs",
                            ),
                            ::core::option::Option::Some(321u32),
                            ::core::option::Option::Some("app_lib::window::handler"),
                            ::tracing_core::field::FieldSet::new(
                                &["app", "directory", "multiple", "filters"],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = __CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        __CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Span::new(
                        meta,
                        &{
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = meta.fields().iter();
                            meta.fields()
                                .value_set(
                                    &[
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&app) as &dyn Value,
                                            ),
                                        ),
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&directory) as &dyn Value,
                                            ),
                                        ),
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&multiple) as &dyn Value,
                                            ),
                                        ),
                                        (
                                            &::core::iter::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::core::option::Option::Some(
                                                &tracing::field::debug(&filters) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        },
                    )
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        __CALLSITE.metadata(),
                    );
                    {};
                    span
                }
            };
            let __tracing_instrument_future = async move {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: types::errors::Result<
                        Vec<FileResponse>,
                    > = loop {};
                    return __tracing_attr_fake_return;
                }
                {
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event src-tauri/src/window/handler.rs:321",
                                    "app_lib::window::handler",
                                    ::tracing::Level::INFO,
                                    ::core::option::Option::Some(
                                        "src-tauri/src/window/handler.rs",
                                    ),
                                    ::core::option::Option::Some(321u32),
                                    ::core::option::Option::Some("app_lib::window::handler"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::INFO
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::INFO
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::core::iter::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::core::option::Option::Some(
                                                    &format_args!("calling async {0}", "open_file_browser")
                                                        as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    let ret = db
                        .open_file_browser(app, directory, multiple, filters)
                        .await;
                    if let Ok(ret) = &ret {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/window/handler.rs:321",
                                        "app_lib::window::handler",
                                        ::tracing::Level::TRACE,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(321u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::TRACE
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::TRACE
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Got result {0:?}", ret) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    } else {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event src-tauri/src/window/handler.rs:321",
                                        "app_lib::window::handler",
                                        ::tracing::Level::ERROR,
                                        ::core::option::Option::Some(
                                            "src-tauri/src/window/handler.rs",
                                        ),
                                        ::core::option::Option::Some(321u32),
                                        ::core::option::Option::Some("app_lib::window::handler"),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::core::iter::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::core::option::Option::Some(
                                                        &format_args!("Error getting result {0:?}", ret)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                    }
                    ret
                }
            };
            if !__tracing_attr_span.is_disabled() {
                tracing::Instrument::instrument(
                        __tracing_instrument_future,
                        __tracing_attr_span,
                    )
                    .await
            } else {
                __tracing_instrument_future.await
            }
        }
        #[allow(unused_imports)]
        pub use __cmd__open_file_browser;
    }
}
mod youtube {
    use youtube::youtube::YoutubeScraper;
    #[tracing::instrument(level = "trace", skip())]
    pub fn get_youtube_scraper_state() -> YoutubeScraper {
        {}
        #[allow(clippy::suspicious_else_formatting)]
        {
            let __tracing_attr_span;
            let __tracing_attr_guard;
            if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                && tracing::Level::TRACE
                    <= ::tracing::level_filters::LevelFilter::current() || { false }
            {
                __tracing_attr_span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "get_youtube_scraper_state",
                                "app_lib::youtube",
                                tracing::Level::TRACE,
                                ::core::option::Option::Some(
                                    "src-tauri/src/youtube/mod.rs",
                                ),
                                ::core::option::Option::Some(3u32),
                                ::core::option::Option::Some("app_lib::youtube"),
                                ::tracing_core::field::FieldSet::new(
                                    &[],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = __CALLSITE.interest();
                            !interest.is_never()
                        }
                        && ::tracing::__macro_support::__is_enabled(
                            __CALLSITE.metadata(),
                            interest,
                        )
                    {
                        let meta = __CALLSITE.metadata();
                        ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                    } else {
                        let span = ::tracing::__macro_support::__disabled_span(
                            __CALLSITE.metadata(),
                        );
                        {};
                        span
                    }
                };
                __tracing_attr_guard = __tracing_attr_span.enter();
            }
            #[warn(clippy::suspicious_else_formatting)]
            {
                #[allow(
                    unknown_lints,
                    unreachable_code,
                    clippy::diverging_sub_expression,
                    clippy::let_unit_value,
                    clippy::unreachable,
                    clippy::let_with_type_underscore,
                    clippy::empty_loop
                )]
                if false {
                    let __tracing_attr_fake_return: YoutubeScraper = loop {};
                    return __tracing_attr_fake_return;
                }
                { YoutubeScraper::default() }
            }
        }
    }
}
#[tracing::instrument(level = "trace", skip())]
pub fn run() {
    {}
    #[allow(clippy::suspicious_else_formatting)]
    {
        let __tracing_attr_span;
        let __tracing_attr_guard;
        if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
            && tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
            || { false }
        {
            __tracing_attr_span = {
                use ::tracing::__macro_support::Callsite as _;
                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "run",
                            "app_lib",
                            tracing::Level::TRACE,
                            ::core::option::Option::Some("src-tauri/src/lib.rs"),
                            ::core::option::Option::Some(81u32),
                            ::core::option::Option::Some("app_lib"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    ::tracing::callsite::DefaultCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && tracing::Level::TRACE
                        <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = __CALLSITE.interest();
                        !interest.is_never()
                    }
                    && ::tracing::__macro_support::__is_enabled(
                        __CALLSITE.metadata(),
                        interest,
                    )
                {
                    let meta = __CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = ::tracing::__macro_support::__disabled_span(
                        __CALLSITE.metadata(),
                    );
                    {};
                    span
                }
            };
            __tracing_attr_guard = __tracing_attr_span.enter();
        }
        #[warn(clippy::suspicious_else_formatting)]
        {
            #[allow(
                unknown_lints,
                unreachable_code,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::unreachable,
                clippy::let_with_type_underscore,
                clippy::empty_loop
            )]
            if false {
                let __tracing_attr_fake_return: () = loop {};
                return __tracing_attr_fake_return;
            }
            {
                tauri::Builder::default()
                    .plugin(tauri_plugin_updater::Builder::new().build())
                    .plugin(tauri_plugin_deep_link::init())
                    .plugin(
                        tauri_plugin_single_instance::init(|app, argv, _cwd| {
                            if let Some(url) = argv.get(1) {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/lib.rs:89",
                                                "app_lib",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some("src-tauri/src/lib.rs"),
                                                ::core::option::Option::Some(89u32),
                                                ::core::option::Option::Some("app_lib"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("Got url {0}", url) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                                let state: State<OAuthHandler> = app.state();
                                state.handle_oauth(app.clone(), url.to_string()).unwrap();
                            }
                        }),
                    )
                    .plugin(tauri_plugin_dialog::init())
                    .invoke_handler(move |__tauri_invoke__| {
                        let __tauri_cmd__ = __tauri_invoke__.message.command();
                        match __tauri_cmd__ {
                            "save_selective" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = save_selective(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "save_selective",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "save_selective",
                                                key: "key",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "save_selective",
                                                key: "value",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "load_selective" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = load_selective(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "load_selective",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "load_selective",
                                                key: "key",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "load_selective_array" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = load_selective_array(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "load_selective_array",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "load_selective_array",
                                                key: "key",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "get_secure" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = get_secure(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_secure",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_secure",
                                                key: "key",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "set_secure" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = set_secure(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "set_secure",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "set_secure",
                                                key: "key",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "set_secure",
                                                key: "value",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "insert_songs" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = insert_songs(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "insert_songs",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "insert_songs",
                                                key: "songs",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "remove_songs" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = remove_songs(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "remove_songs",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "remove_songs",
                                                key: "songs",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "get_songs_by_options" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = get_songs_by_options(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_songs_by_options",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_songs_by_options",
                                                key: "options",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "get_entity_by_options" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = get_entity_by_options(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_entity_by_options",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_entity_by_options",
                                                key: "options",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "search_all" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = search_all(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "search_all",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "search_all",
                                                key: "term",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "create_playlist" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = create_playlist(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "create_playlist",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "create_playlist",
                                                key: "playlist",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "add_to_playlist" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = add_to_playlist(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "add_to_playlist",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "add_to_playlist",
                                                key: "id",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "add_to_playlist",
                                                key: "songs",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "remove_from_playlist" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = remove_from_playlist(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "remove_from_playlist",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "remove_from_playlist",
                                                key: "id",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "remove_from_playlist",
                                                key: "songs",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "remove_playlist" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = remove_playlist(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "remove_playlist",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "remove_playlist",
                                                key: "id",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "update_album" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = update_album(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "update_album",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "update_album",
                                                key: "album",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "update_artist" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = update_artist(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "update_artist",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "update_artist",
                                                key: "artist",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "update_playlist" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = update_playlist(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "update_playlist",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "update_playlist",
                                                key: "playlist",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "update_songs" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = update_songs(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "update_songs",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "update_songs",
                                                key: "songs",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "update_lyrics" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = update_lyrics(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "update_lyrics",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "update_lyrics",
                                                key: "id",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "update_lyrics",
                                                key: "lyrics",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "increment_play_count" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = increment_play_count(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "increment_play_count",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "increment_play_count",
                                                key: "id",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "increment_play_time" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = increment_play_time(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "increment_play_time",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "increment_play_time",
                                                key: "id",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "increment_play_time",
                                                key: "duration",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "export_playlist" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = export_playlist(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "export_playlist",
                                                key: "app",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "export_playlist",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "export_playlist",
                                                key: "windowHandler",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "export_playlist",
                                                key: "id",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "is_maximized" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = is_maximized(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "is_maximized",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "is_maximized",
                                                key: "window",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "has_frame" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = has_frame(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "has_frame",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "close_window" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = close_window(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "close_window",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "close_window",
                                                key: "window",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "get_platform" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = get_platform(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_platform",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "maximize_window" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = maximize_window(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "maximize_window",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "maximize_window",
                                                key: "window",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "minimize_window" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = minimize_window(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "minimize_window",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "minimize_window",
                                                key: "window",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "update_zoom" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = update_zoom(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "update_zoom",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "update_zoom",
                                                key: "app",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "update_zoom",
                                                key: "preference",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "open_external" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = open_external(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "open_external",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "open_external",
                                                key: "url",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "open_window" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = open_window(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "open_window",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "open_window",
                                                key: "app",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "open_window",
                                                key: "isMainWindow",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "enable_fullscreen" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = enable_fullscreen(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "enable_fullscreen",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "enable_fullscreen",
                                                key: "window",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "disable_fullscreen" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = disable_fullscreen(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "disable_fullscreen",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "disable_fullscreen",
                                                key: "window",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "toggle_fullscreen" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = toggle_fullscreen(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "toggle_fullscreen",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "toggle_fullscreen",
                                                key: "window",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "toggle_dev_tools" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = toggle_dev_tools(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "toggle_dev_tools",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "toggle_dev_tools",
                                                key: "window",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "restart_app" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = restart_app(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "restart_app",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "restart_app",
                                                key: "app",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "open_file_browser" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = open_file_browser(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "open_file_browser",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "open_file_browser",
                                                key: "app",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "open_file_browser",
                                                key: "directory",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "open_file_browser",
                                                key: "multiple",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "open_file_browser",
                                                key: "filters",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "start_scan" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = start_scan(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "start_scan",
                                                key: "scanner",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "start_scan",
                                                key: "database",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "start_scan",
                                                key: "preferences",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "start_scan",
                                                key: "paths",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "start_scan",
                                                key: "force",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "initialize_librespot" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                let result = initialize_librespot(
                                    match ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                        plugin: ::core::option::Option::None,
                                        name: "initialize_librespot",
                                        key: "app",
                                        message: &__tauri_message__,
                                        acl: &__tauri_acl__,
                                    }) {
                                        Ok(arg) => arg,
                                        Err(err) => {
                                            __tauri_resolver__.invoke_error(err);
                                            return true;
                                        }
                                    },
                                    match ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                        plugin: ::core::option::Option::None,
                                        name: "initialize_librespot",
                                        key: "window",
                                        message: &__tauri_message__,
                                        acl: &__tauri_acl__,
                                    }) {
                                        Ok(arg) => arg,
                                        Err(err) => {
                                            __tauri_resolver__.invoke_error(err);
                                            return true;
                                        }
                                    },
                                    match ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                        plugin: ::core::option::Option::None,
                                        name: "initialize_librespot",
                                        key: "librespot",
                                        message: &__tauri_message__,
                                        acl: &__tauri_acl__,
                                    }) {
                                        Ok(arg) => arg,
                                        Err(err) => {
                                            __tauri_resolver__.invoke_error(err);
                                            return true;
                                        }
                                    },
                                );
                                let kind = (&result).blocking_kind();
                                kind.block(result, __tauri_resolver__);
                                return true;
                            }
                            "librespot_play" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = librespot_play(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "librespot_play",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "librespot_pause" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = librespot_pause(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "librespot_pause",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "librespot_close" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = librespot_close(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "librespot_close",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "librespot_load" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = librespot_load(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "librespot_load",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "librespot_load",
                                                key: "uri",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "librespot_load",
                                                key: "autoplay",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "librespot_seek" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = librespot_seek(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "librespot_seek",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "librespot_seek",
                                                key: "pos",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "librespot_volume" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = librespot_volume(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "librespot_volume",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "librespot_volume",
                                                key: "volume",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "librespot_get_token" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = librespot_get_token(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "librespot_get_token",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "librespot_get_token",
                                                key: "scopes",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "register_event" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = register_event(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "register_event",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "register_event",
                                                key: "event",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "get_canvaz" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = get_canvaz(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_canvaz",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_canvaz",
                                                key: "cache",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_canvaz",
                                                key: "uri",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "load_all_themes" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = load_all_themes(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "load_all_themes",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "load_theme" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = load_theme(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "load_theme",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "load_theme",
                                                key: "id",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "save_theme" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = save_theme(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "save_theme",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "save_theme",
                                                key: "theme",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "remove_theme" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = remove_theme(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "remove_theme",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "remove_theme",
                                                key: "id",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "import_theme" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = import_theme(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "import_theme",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "import_theme",
                                                key: "path",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "export_theme" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = export_theme(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "export_theme",
                                                key: "app",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "export_theme",
                                                key: "themeHandler",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "export_theme",
                                                key: "windowHandler",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "export_theme",
                                                key: "id",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "transform_css" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = transform_css(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "transform_css",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "transform_css",
                                                key: "cssPath",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "transform_css",
                                                key: "root",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "set_metadata" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = set_metadata(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "set_metadata",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "set_metadata",
                                                key: "metadata",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "set_playback_state" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = set_playback_state(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "set_playback_state",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "set_playback_state",
                                                key: "state",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "set_position" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = set_position(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "set_position",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "set_position",
                                                key: "duration",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "get_lyrics" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = get_lyrics(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_lyrics",
                                                key: "lyrics",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_lyrics",
                                                key: "librespot",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_lyrics",
                                                key: "cache",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_lyrics",
                                                key: "id",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_lyrics",
                                                key: "url",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_lyrics",
                                                key: "artists",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_lyrics",
                                                key: "title",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "install_extension" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = install_extension(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "install_extension",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "install_extension",
                                                key: "extPath",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "remove_extension" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = remove_extension(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "remove_extension",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "remove_extension",
                                                key: "extPath",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "download_extension" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = download_extension(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "download_extension",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "download_extension",
                                                key: "fetchedExt",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "get_installed_extensions" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = get_installed_extensions(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_installed_extensions",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "get_extension_manifest" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = get_extension_manifest(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_extension_manifest",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_extension_manifest",
                                                key: "cache",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "get_extension_icon" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = get_extension_icon(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_extension_icon",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_extension_icon",
                                                key: "cache",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_extension_icon",
                                                key: "args",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "send_extra_event" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = send_extra_event(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "send_extra_event",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "send_extra_event",
                                                key: "args",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "get_provider_keys" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = get_provider_keys(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_provider_keys",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "initialize_all_providers" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = initialize_all_providers(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "initialize_all_providers",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "provider_login" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = provider_login(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "provider_login",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "provider_login",
                                                key: "key",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "provider_login",
                                                key: "accountId",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "provider_signout" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = provider_signout(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "provider_signout",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "provider_signout",
                                                key: "key",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "provider_signout",
                                                key: "accountId",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "provider_authorize" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = provider_authorize(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "provider_authorize",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "provider_authorize",
                                                key: "key",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "provider_authorize",
                                                key: "code",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "get_provider_key_by_id" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = get_provider_key_by_id(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_provider_key_by_id",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_provider_key_by_id",
                                                key: "id",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "fetch_user_playlists" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = fetch_user_playlists(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "fetch_user_playlists",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "fetch_user_playlists",
                                                key: "cache",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "fetch_user_playlists",
                                                key: "key",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "fetch_user_playlists",
                                                key: "pagination",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "fetch_playlist_content" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = fetch_playlist_content(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "fetch_playlist_content",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "fetch_playlist_content",
                                                key: "cache",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "fetch_playlist_content",
                                                key: "key",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "fetch_playlist_content",
                                                key: "playlistId",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "fetch_playlist_content",
                                                key: "pagination",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "fetch_playback_url" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = fetch_playback_url(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "fetch_playback_url",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "fetch_playback_url",
                                                key: "cache",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "fetch_playback_url",
                                                key: "key",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "fetch_playback_url",
                                                key: "song",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "fetch_playback_url",
                                                key: "player",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "provider_search" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = provider_search(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "provider_search",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "provider_search",
                                                key: "cache",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "provider_search",
                                                key: "key",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "provider_search",
                                                key: "term",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "get_all_status" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = get_all_status(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_all_status",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "match_url" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = match_url(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "match_url",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "match_url",
                                                key: "cache",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "match_url",
                                                key: "key",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "match_url",
                                                key: "url",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "playlist_from_url" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = playlist_from_url(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "playlist_from_url",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "playlist_from_url",
                                                key: "cache",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "playlist_from_url",
                                                key: "key",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "playlist_from_url",
                                                key: "url",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "song_from_url" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = song_from_url(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "song_from_url",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "song_from_url",
                                                key: "cache",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "song_from_url",
                                                key: "key",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "song_from_url",
                                                key: "url",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "get_suggestions" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = get_suggestions(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_suggestions",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_suggestions",
                                                key: "cache",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "get_suggestions",
                                                key: "key",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "rodio_get_volume" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = rodio_get_volume(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "rodio_get_volume",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "rodio_load" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = rodio_load(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "rodio_load",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "rodio_load",
                                                key: "src",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "rodio_pause" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = rodio_pause(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "rodio_pause",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "rodio_play" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = rodio_play(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "rodio_play",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "rodio_seek" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = rodio_seek(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "rodio_seek",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "rodio_seek",
                                                key: "pos",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "rodio_set_volume" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = rodio_set_volume(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "rodio_set_volume",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "rodio_set_volume",
                                                key: "volume",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            "rodio_stop" => {
                                #[allow(unused_imports)]
                                use ::tauri::ipc::private::*;
                                #[allow(unused_variables)]
                                let ::tauri::ipc::Invoke {
                                    message: __tauri_message__,
                                    resolver: __tauri_resolver__,
                                    acl: __tauri_acl__,
                                } = __tauri_invoke__;
                                __tauri_resolver__
                                    .respond_async_serialized(async move {
                                        let result = rodio_stop(
                                            ::tauri::ipc::CommandArg::from_command(::tauri::ipc::CommandItem {
                                                plugin: ::core::option::Option::None,
                                                name: "rodio_stop",
                                                key: "db",
                                                message: &__tauri_message__,
                                                acl: &__tauri_acl__,
                                            })?,
                                        );
                                        let kind = (&result).async_kind();
                                        kind.future(result).await
                                    });
                                return true;
                            }
                            _ => {
                                return false;
                            }
                        }
                    })
                    .setup(|app| {
                        let filter = EnvFilter::from_env("MOOSYNC_LOG");
                        let layer = fmt::layer().pretty().with_target(true);
                        let log_path = app.path().app_log_dir()?;
                        if !log_path.exists() {
                            fs::create_dir_all(log_path.clone())?;
                        }
                        let file_appender = RollingFileAppender::new(
                            Rotation::DAILY,
                            log_path,
                            "moosync",
                        );
                        let log_layer = fmt::layer()
                            .pretty()
                            .with_ansi(false)
                            .with_target(true)
                            .with_writer(file_appender);
                        let subscriber = tracing_subscriber::registry()
                            .with(layer)
                            .with(log_layer)
                            .with(filter);
                        tracing::subscriber::set_global_default(subscriber).unwrap();
                        let db = get_db_state(app);
                        app.manage(db);
                        let cache = get_cache_state(app);
                        app.manage(cache);
                        let config = get_preference_state(app)?;
                        app.manage(config);
                        let oauth = get_oauth_state()?;
                        app.manage(oauth);
                        let window_state = get_window_state();
                        app.manage(window_state);
                        let yt_state = get_youtube_scraper_state();
                        app.manage(yt_state);
                        let scanner_state = get_scanner_state();
                        app.manage(scanner_state);
                        let librespot_state = get_librespot_state();
                        app.manage(librespot_state);
                        let theme_handler_state = get_theme_handler_state(app);
                        app.manage(theme_handler_state);
                        let mpris_state = get_mpris_state(app.app_handle().clone())?;
                        app.manage(mpris_state);
                        let lyrics_state = get_lyrics_state();
                        app.manage(lyrics_state);
                        let ext_state = get_extension_state(app.app_handle().clone())?;
                        app.manage(ext_state);
                        let provider_handler_state = get_provider_handler_state(
                            app.app_handle().clone(),
                        );
                        app.manage(provider_handler_state);
                        let rodio_state = get_rodio_state();
                        app.manage(rodio_state);
                        initial(app);
                        handle_pref_changes(app.handle().clone());
                        app.listen(
                            "deep-link://new-url",
                            |url| {
                                {
                                    use ::tracing::__macro_support::Callsite as _;
                                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                        static META: ::tracing::Metadata<'static> = {
                                            ::tracing_core::metadata::Metadata::new(
                                                "event src-tauri/src/lib.rs:263",
                                                "app_lib",
                                                ::tracing::Level::INFO,
                                                ::core::option::Option::Some("src-tauri/src/lib.rs"),
                                                ::core::option::Option::Some(263u32),
                                                ::core::option::Option::Some("app_lib"),
                                                ::tracing_core::field::FieldSet::new(
                                                    &["message"],
                                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                                ),
                                                ::tracing::metadata::Kind::EVENT,
                                            )
                                        };
                                        ::tracing::callsite::DefaultCallsite::new(&META)
                                    };
                                    let enabled = ::tracing::Level::INFO
                                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                        && ::tracing::Level::INFO
                                            <= ::tracing::level_filters::LevelFilter::current()
                                        && {
                                            let interest = __CALLSITE.interest();
                                            !interest.is_never()
                                                && ::tracing::__macro_support::__is_enabled(
                                                    __CALLSITE.metadata(),
                                                    interest,
                                                )
                                        };
                                    if enabled {
                                        (|value_set: ::tracing::field::ValueSet| {
                                            let meta = __CALLSITE.metadata();
                                            ::tracing::Event::dispatch(meta, &value_set);
                                        })({
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = __CALLSITE.metadata().fields().iter();
                                            __CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &::core::iter::Iterator::next(&mut iter)
                                                                .expect("FieldSet corrupted (this is a bug)"),
                                                            ::core::option::Option::Some(
                                                                &format_args!("got url {0:?}", url) as &dyn Value,
                                                            ),
                                                        ),
                                                    ],
                                                )
                                        });
                                    } else {
                                    }
                                };
                            },
                        );
                        build_tray_menu(app)?;
                        Ok(())
                    })
                    .on_window_event(|window, event| {
                        if let tauri::WindowEvent::CloseRequested { api, .. } = event {
                            if let Ok(should_close) = handle_window_close(
                                window.app_handle(),
                            ) {
                                if !should_close {
                                    window.hide().unwrap();
                                    api.prevent_close();
                                }
                            }
                        }
                    })
                    .run({
                        #[allow(unused_mut, clippy::let_and_return)]
                        let mut context = ::tauri::Context::new(
                            ::tauri::utils::config::Config {
                                schema: None,
                                product_name: ::core::option::Option::Some(
                                    "Moosync".into(),
                                ),
                                version: ::core::option::Option::Some("0.0.0".into()),
                                identifier: "app.moosync.moosync".into(),
                                app: ::tauri::utils::config::AppConfig {
                                    windows: <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            ::tauri::utils::config::WindowConfig {
                                                label: "main".into(),
                                                url: ::tauri::utils::config::WebviewUrl::App(
                                                    ::std::path::PathBuf::from("/mainWindow"),
                                                ),
                                                user_agent: ::core::option::Option::None,
                                                drag_drop_enabled: true,
                                                center: false,
                                                x: ::core::option::Option::None,
                                                y: ::core::option::Option::None,
                                                width: 1024f64,
                                                height: 800f64,
                                                min_width: ::core::option::Option::None,
                                                min_height: ::core::option::Option::None,
                                                max_width: ::core::option::Option::None,
                                                max_height: ::core::option::Option::None,
                                                resizable: true,
                                                maximizable: true,
                                                minimizable: true,
                                                closable: true,
                                                title: "Tauri App".into(),
                                                proxy_url: ::core::option::Option::None,
                                                fullscreen: false,
                                                focus: true,
                                                transparent: false,
                                                maximized: false,
                                                visible: true,
                                                decorations: true,
                                                always_on_bottom: false,
                                                always_on_top: false,
                                                visible_on_all_workspaces: false,
                                                content_protected: false,
                                                skip_taskbar: false,
                                                theme: ::core::option::Option::None,
                                                title_bar_style: ::tauri::utils::TitleBarStyle::Visible,
                                                hidden_title: false,
                                                accept_first_mouse: false,
                                                tabbing_identifier: ::core::option::Option::None,
                                                additional_browser_args: ::core::option::Option::None,
                                                shadow: true,
                                                window_effects: ::core::option::Option::None,
                                                incognito: false,
                                                parent: ::core::option::Option::None,
                                                zoom_hotkeys_enabled: false,
                                            },
                                        ]),
                                    ),
                                    security: ::tauri::utils::config::SecurityConfig {
                                        csp: ::core::option::Option::Some(
                                            ::tauri::utils::config::Csp::Policy(
                                                "default-src tauri: 'self'; img-src tauri: 'self' asset: media: https://asset.localhost https: http:; media-src blob: tauri: 'self' http: https: asset: media: https://asset.localhost ; connect-src ipc: tauri: http://ipc.localhost asset: ; style-src 'unsafe-inline' tauri:; frame-src youtube.com https://www.youtube.com; script-src 'wasm-unsafe-eval';"
                                                    .into(),
                                            ),
                                        ),
                                        dev_csp: ::core::option::Option::None,
                                        freeze_prototype: false,
                                        dangerous_disable_asset_csp_modification: ::tauri::utils::config::DisabledCspModificationKind::Flag(
                                            false,
                                        ),
                                        asset_protocol: ::tauri::utils::config::AssetProtocolConfig {
                                            scope: ::tauri::utils::config::FsScope::Scope {
                                                allow: <[_]>::into_vec(
                                                    #[rustc_box]
                                                    ::alloc::boxed::Box::new([
                                                        ::std::path::PathBuf::from("**/*"),
                                                    ]),
                                                ),
                                                deny: ::alloc::vec::Vec::new(),
                                                require_literal_leading_dot: ::core::option::Option::Some(
                                                    false,
                                                ),
                                            },
                                            ..Default::default()
                                        },
                                        pattern: ::tauri::utils::config::PatternKind::Brownfield,
                                        capabilities: ::alloc::vec::Vec::new(),
                                    },
                                    tray_icon: ::core::option::Option::None,
                                    macos_private_api: false,
                                    with_global_tauri: true,
                                    enable_gtk_app_id: false,
                                },
                                build: ::tauri::utils::config::BuildConfig {
                                    runner: None,
                                    dev_url: ::core::option::Option::Some(
                                        "http://localhost:1420/".parse().unwrap(),
                                    ),
                                    frontend_dist: ::core::option::Option::Some(
                                        ::tauri::utils::config::FrontendDist::Directory(
                                            ::std::path::PathBuf::from("../dist"),
                                        ),
                                    ),
                                    before_dev_command: None,
                                    before_build_command: None,
                                    before_bundle_command: None,
                                    features: None,
                                },
                                bundle: ::tauri::utils::config::BundleConfig {
                                    active: true,
                                    publisher: None,
                                    homepage: None,
                                    icon: <[_]>::into_vec(
                                        #[rustc_box]
                                        ::alloc::boxed::Box::new([
                                            "icons/32x32.png".into(),
                                            "icons/128x128.png".into(),
                                            "icons/128x128@2x.png".into(),
                                            "icons/icon.icns".into(),
                                            "icons/icon.ico".into(),
                                        ]),
                                    ),
                                    targets: Default::default(),
                                    create_updater_artifacts: Default::default(),
                                    resources: None,
                                    copyright: None,
                                    category: None,
                                    license: ::core::option::Option::None,
                                    license_file: ::core::option::Option::None,
                                    file_associations: None,
                                    short_description: None,
                                    long_description: None,
                                    external_bin: ::core::option::Option::Some(
                                        <[_]>::into_vec(
                                            #[rustc_box]
                                            ::alloc::boxed::Box::new([
                                                "binaries/exthost".into(),
                                                "binaries/exthost-wasm".into(),
                                            ]),
                                        ),
                                    ),
                                    windows: ::tauri::utils::config::WindowsConfig {
                                        webview_install_mode: ::tauri::utils::config::WebviewInstallMode::DownloadBootstrapper {
                                            silent: true,
                                        },
                                        ..Default::default()
                                    },
                                    linux: Default::default(),
                                    macos: Default::default(),
                                    ios: Default::default(),
                                    android: Default::default(),
                                },
                                plugins: ::tauri::utils::config::PluginConfig({
                                    let mut map = ::std::collections::HashMap::new();
                                    map.insert(
                                        "deep-link".into(),
                                        ::serde_json::Value::Object({
                                            let mut map = ::serde_json::Map::new();
                                            map.insert(
                                                "desktop".into(),
                                                ::serde_json::Value::Object({
                                                    let mut map = ::serde_json::Map::new();
                                                    map.insert(
                                                        "schemes".into(),
                                                        ::serde_json::Value::Array(
                                                            <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new([
                                                                    ::serde_json::Value::String("moosync".into()),
                                                                ]),
                                                            ),
                                                        ),
                                                    );
                                                    map
                                                }),
                                            );
                                            map.insert(
                                                "mobile".into(),
                                                ::serde_json::Value::Array(
                                                    <[_]>::into_vec(
                                                        #[rustc_box]
                                                        ::alloc::boxed::Box::new([
                                                            ::serde_json::Value::Object({
                                                                let mut map = ::serde_json::Map::new();
                                                                map.insert(
                                                                    "host".into(),
                                                                    ::serde_json::Value::String("moosync.app".into()),
                                                                );
                                                                map.insert(
                                                                    "pathPrefix".into(),
                                                                    ::serde_json::Value::Array(
                                                                        <[_]>::into_vec(
                                                                            #[rustc_box]
                                                                            ::alloc::boxed::Box::new([
                                                                                ::serde_json::Value::String("/youtube".into()),
                                                                                ::serde_json::Value::String("/spotify".into()),
                                                                            ]),
                                                                        ),
                                                                    ),
                                                                );
                                                                map
                                                            }),
                                                        ]),
                                                    ),
                                                ),
                                            );
                                            map
                                        }),
                                    );
                                    map.insert(
                                        "updater".into(),
                                        ::serde_json::Value::Object({
                                            let mut map = ::serde_json::Map::new();
                                            map.insert(
                                                "active".into(),
                                                ::serde_json::Value::Bool(true),
                                            );
                                            map.insert(
                                                "dialog".into(),
                                                ::serde_json::Value::Bool(true),
                                            );
                                            map.insert(
                                                "endpoints".into(),
                                                ::serde_json::Value::Array(
                                                    <[_]>::into_vec(
                                                        #[rustc_box]
                                                        ::alloc::boxed::Box::new([
                                                            ::serde_json::Value::String(
                                                                "https://github.com/Moosync/tauri/releases/latest/download/latest.json"
                                                                    .into(),
                                                            ),
                                                        ]),
                                                    ),
                                                ),
                                            );
                                            map.insert(
                                                "pubkey".into(),
                                                ::serde_json::Value::String(
                                                    "dW50cnVzdGVkIGNvbW1lbnQ6IG1pbmlzaWduIHB1YmxpYyBrZXk6IEQ4MDc4MUJFMTA3QzM2RjYKUldUMk5ud1F2b0VIMkNtSlZMcDhBSWxkVUxCaWNkYUZ6RGRHMC9PSkd1bEdscnhRY3lHNFRTYlEK"
                                                        .into(),
                                                ),
                                            );
                                            map
                                        }),
                                    );
                                    map
                                }),
                            },
                            ::std::boxed::Box::new({
                                #[allow(unused_imports)]
                                use ::tauri::utils::assets::{
                                    CspHash, EmbeddedAssets, phf, phf::phf_map,
                                };
                                EmbeddedAssets::new(
                                    phf::Map {
                                        key: 12913932095322966823u64,
                                        disps: &[],
                                        entries: &[],
                                    },
                                    &[],
                                    phf::Map {
                                        key: 12913932095322966823u64,
                                        disps: &[],
                                        entries: &[],
                                    },
                                )
                            }),
                            ::std::option::Option::Some(
                                ::tauri::image::Image::new(
                                    b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xbf0\x10\xff\xbf0 \xff\xbf00\xff\xbf0\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xbf0\x10\xff\xc12\x80\xff\xc11\xdf\xff\xc11\xff\xff\xc11\xff\xff\xc11\xff\xff\xc11\xff\xff\xc11\xdf\xff\xc22\x9f\xff\xbf0 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xc22`\xff\xc11\xef\xff\xc11\xff\xff\xc11\xff\xff\xc11\xff\xff\xc11\xff\xff\xc11\xff\xff\xc11\xff\xff\xc11\xff\xff\xc11\xff\xff\xc11\xff\xff\xc12\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xc12\x80\xff\xc11\xff\xff\xc11\xff\xff\xc11\xff\xff\xc11\xff\xff\xc00\xdf\xff\xc00\x9f\xff\xc00\xaf\xff\xc00\xcf\xff\xc11\xff\xff\xc11\xff\xff\xc11\xff\xff\xc11\xff\xff\xc22\x8f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xbf0`\xff\xc11\xff\xff\xc11\xff\xff\xc11\xff\xff\xc00\xbf\xff\xc21?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xbf0 \xff\xc00\x9f\xff\xc11\xff\xff\xc11\xff\xff\xc11\xff\xff\xc12\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xbf0 \xff\xc11\xdf\xff\xc11\xff\xff\xc11\xff\xff\xc10\x7f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xbf0p\xff\xc11\xff\xff\xc11\xff\xff\xc11\xff\xff\xbf0@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xc22\x9f\xff\xc11\xef\xff\xc00\x9f\xff\xc10_\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xc10\x8f\xff\xc11\xff\xff\xc11\xff\xff\xc21\xbf\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xbf0 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xbf0\x10\xff\xbf0\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xbf0\x10\xff\xc11\xef\xff\xc11\xff\xff\xc11\xff\xff\xbf0\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00#\xc9\xdcP#\xc8\xdc\x9f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xc12\x80\xff\xc11\xff\xff\xc11\xff\xff\xc22\x8f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xc10\x8f\xff\xc11\xff\xff\xc11\xff\xff\xc20O\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00$\xc7\xdb@%\xc8\xdc\xdf$\xc8\xdb\xff$\xc8\xdb\xbf\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xbf0@\xff\xc11\xff\xff\xc11\xff\xff\xc11\xff\xff\xc11\xff\xff\xc10_\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xbf0`\xff\xc11\xff\xff\xc11\xff\xff\xc10o\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00$\xc7\xdb\x80$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xff#\xc8\xdc\x9f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xbf0`\xff\xc11\xff\xff\xc11\xff\xff\xc11\xff\xff\xc11\xff\xff\xc10\x7f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xbf0@\xff\xc11\xff\xff\xc11\xff\xff\xc10\x7f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00$\xc6\xdbp$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xbf%\xc5\xda0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xbf0\x10\xff\xc11\xff\xff\xc11\xff\xff\xc11\xff\xff\xc11\xff\xff\xc20O\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xc10o\xff\xc11\xff\xff\xc11\xff\xff\xc10o\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00(\xc7\xdf $\xc7\xdc\xef$\xc8\xdb\xff$\xc8\xdb\xff$\xc9\xda\x8f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xbf0P\xff\xc00\xcf\xff\xc00\xdf\xff\xc10o\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xc22\x9f\xff\xc11\xff\xff\xc11\xff\xff\xc21?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00%\xc8\xdc\x9f$\xc8\xdb\xff$\xc8\xdb\xff#\xc8\xda\x9f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xbf0 \xff\xc11\xff\xff\xc11\xff\xff\xc11\xef\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 \xcf\xdf\x10$\xc8\xdb\xff$\xc8\xdb\xff$\xc7\xdb\xef \xc7\xd7 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xc22\x9f\xff\xc11\xff\xff\xc11\xff\xff\xc00\x9f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00$\xc7\xdb@$\xc8\xdb\xff$\xc8\xdb\xff#\xc8\xda\x9f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00$\xc6\xdbp%\xc8\xda\xdf$\xc9\xda\xcf#\xc9\xd9P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xc12\x90\xff\xc11\xff\xff\xc11\xff\xff\xc11\xdf\xff\xbf0 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00$\xc9\xdb\x7f$\xc8\xdb\xff$\xc8\xdb\xff#\xc8\xdbO\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00#\xc9\xdcP$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xff \xcf\xcf\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xbf0@\xff\xc11\xcf\xff\xc11\xff\xff\xc11\xff\xff\xc11\xff\xff\xc10_\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00$\xc9\xdb\x7f$\xc8\xdb\xff$\xc8\xdb\xff$\xca\xdb?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00$\xc9\xdb\x7f$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xff#\xc9\xdc_\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xc21\xbf\xff\xc11\xff\xff\xc11\xff\xff\xc11\xff\xff\xc10o\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00$\xc9\xdb\x7f$\xc8\xdb\xff$\xc8\xdb\xff#\xc9\xdc_\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00%\xc7\xda`$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xff$\xca\xdb?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xc21\xbf\xff\xc11\xff\xff\xc11\xdf\xff\xc21?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00%\xc7\xda`$\xc8\xdb\xff$\xc8\xdb\xff$\xc9\xda\x8f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00$\xc9\xdb\x8f$\xc8\xdb\xff$\xc7\xdb\xef$\xc9\xdb\x7f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xc10\x8f\xff\xc21?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 \xcf\xdf\x10$\xc8\xdb\xff$\xc8\xdb\xff$\xc7\xdb\xef \xcf\xcf\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 \xcf\xcf\x10 \xcf\xcf\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 \xcf\xdf\x10$\xc7\xdb@\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00$\xc8\xdb\xbf$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\x8f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00%\xc7\xda`$\xc8\xdb\xaf$\xc7\xdc\xef$\xc9\xdb\x7f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00$\xc7\xdb@$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xff$\xc6\xd8p\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00$\xc7\xdb\x80$\xc8\xdb\xff$\xc8\xdb\xff#\xc8\xda\xdf \xc7\xd7 \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00$\xc9\xdb\x7f$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xff#\xc8\xdc\x9f \xc7\xdf \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00$\xc7\xdb@$\xc8\xdb\xbf$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xff#\xc9\xdc_\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00$\xc9\xdb\x8f$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xff$\xc9\xda\xcf$\xc8\xdb\xaf$\xc8\xdb\xaf%\xc8\xda\xdf$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xff$\xc9\xdb\x7f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00$\xc9\xdb\x7f$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xff$\xc7\xdb\xef#\xc9\xd9P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00(\xc7\xd7 %\xc8\xda\x9f%\xc8\xda\xdf$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xff$\xc8\xdb\xbf$\xc9\xdb\x7f \xcf\xcf\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00 \xcf\xcf\x10!\xce\xde\x1f!\xce\xde\x1f \xcf\xcf\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
                                    32u32,
                                    32u32,
                                ),
                            ),
                            ::std::option::Option::None,
                            ::tauri::PackageInfo {
                                name: "Moosync".to_string(),
                                version: "0.0.0".to_string().parse().unwrap(),
                                authors: "you",
                                description: "A Tauri App",
                                crate_name: "moosync",
                            },
                            (),
                            ::tauri::Pattern::Brownfield,
                            ::tauri::ipc::RuntimeAuthority::new(
                                {
                                    let mut map = ::std::collections::BTreeMap::new();
                                    map.insert(
                                        "core:app".into(),
                                        ::tauri::utils::acl::manifest::Manifest {
                                            default_permission: ::core::option::Option::Some(::tauri::utils::acl::PermissionSet {
                                                identifier: "default".into(),
                                                description: "Default permissions for the plugin.".into(),
                                                permissions: <[_]>::into_vec(
                                                    #[rustc_box]
                                                    ::alloc::boxed::Box::new([
                                                        "allow-version".into(),
                                                        "allow-name".into(),
                                                        "allow-tauri-version".into(),
                                                    ]),
                                                ),
                                            }),
                                            permissions: {
                                                let mut map = ::std::collections::BTreeMap::new();
                                                map.insert(
                                                    "allow-app-hide".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-app-hide".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the app_hide command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["app_hide".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-app-show".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-app-show".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the app_show command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["app_show".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-default-window-icon".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-default-window-icon".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the default_window_icon command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["default_window_icon".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-name".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-name".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the name command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["name".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-tauri-version".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-tauri-version".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the tauri_version command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["tauri_version".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-version".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-version".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the version command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["version".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-app-hide".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-app-hide".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the app_hide command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["app_hide".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-app-show".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-app-show".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the app_show command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["app_show".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-default-window-icon".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-default-window-icon".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the default_window_icon command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["default_window_icon".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-name".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-name".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the name command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["name".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-tauri-version".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-tauri-version".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the tauri_version command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["tauri_version".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-version".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-version".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the version command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["version".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map
                                            },
                                            permission_sets: ::std::collections::BTreeMap::new(),
                                            global_scope_schema: ::core::option::Option::None,
                                        },
                                    );
                                    map.insert(
                                        "core:event".into(),
                                        ::tauri::utils::acl::manifest::Manifest {
                                            default_permission: ::core::option::Option::Some(::tauri::utils::acl::PermissionSet {
                                                identifier: "default".into(),
                                                description: "Default permissions for the plugin.".into(),
                                                permissions: <[_]>::into_vec(
                                                    #[rustc_box]
                                                    ::alloc::boxed::Box::new([
                                                        "allow-listen".into(),
                                                        "allow-unlisten".into(),
                                                        "allow-emit".into(),
                                                        "allow-emit-to".into(),
                                                    ]),
                                                ),
                                            }),
                                            permissions: {
                                                let mut map = ::std::collections::BTreeMap::new();
                                                map.insert(
                                                    "allow-emit".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-emit".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the emit command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["emit".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-emit-to".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-emit-to".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the emit_to command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["emit_to".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-listen".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-listen".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the listen command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["listen".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-unlisten".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-unlisten".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the unlisten command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["unlisten".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-emit".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-emit".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the emit command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["emit".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-emit-to".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-emit-to".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the emit_to command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["emit_to".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-listen".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-listen".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the listen command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["listen".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-unlisten".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-unlisten".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the unlisten command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["unlisten".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map
                                            },
                                            permission_sets: ::std::collections::BTreeMap::new(),
                                            global_scope_schema: ::core::option::Option::None,
                                        },
                                    );
                                    map.insert(
                                        "core:image".into(),
                                        ::tauri::utils::acl::manifest::Manifest {
                                            default_permission: ::core::option::Option::Some(::tauri::utils::acl::PermissionSet {
                                                identifier: "default".into(),
                                                description: "Default permissions for the plugin.".into(),
                                                permissions: <[_]>::into_vec(
                                                    #[rustc_box]
                                                    ::alloc::boxed::Box::new([
                                                        "allow-new".into(),
                                                        "allow-from-bytes".into(),
                                                        "allow-from-path".into(),
                                                        "allow-rgba".into(),
                                                        "allow-size".into(),
                                                    ]),
                                                ),
                                            }),
                                            permissions: {
                                                let mut map = ::std::collections::BTreeMap::new();
                                                map.insert(
                                                    "allow-from-bytes".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-from-bytes".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the from_bytes command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["from_bytes".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-from-path".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-from-path".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the from_path command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["from_path".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-new".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-new".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the new command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["new".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-rgba".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-rgba".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the rgba command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["rgba".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-size".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-size".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the size command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["size".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-from-bytes".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-from-bytes".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the from_bytes command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["from_bytes".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-from-path".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-from-path".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the from_path command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["from_path".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-new".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-new".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the new command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["new".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-rgba".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-rgba".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the rgba command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["rgba".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-size".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-size".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the size command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["size".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map
                                            },
                                            permission_sets: ::std::collections::BTreeMap::new(),
                                            global_scope_schema: ::core::option::Option::None,
                                        },
                                    );
                                    map.insert(
                                        "core:menu".into(),
                                        ::tauri::utils::acl::manifest::Manifest {
                                            default_permission: ::core::option::Option::Some(::tauri::utils::acl::PermissionSet {
                                                identifier: "default".into(),
                                                description: "Default permissions for the plugin.".into(),
                                                permissions: <[_]>::into_vec(
                                                    #[rustc_box]
                                                    ::alloc::boxed::Box::new([
                                                        "allow-new".into(),
                                                        "allow-append".into(),
                                                        "allow-prepend".into(),
                                                        "allow-insert".into(),
                                                        "allow-remove".into(),
                                                        "allow-remove-at".into(),
                                                        "allow-items".into(),
                                                        "allow-get".into(),
                                                        "allow-popup".into(),
                                                        "allow-create-default".into(),
                                                        "allow-set-as-app-menu".into(),
                                                        "allow-set-as-window-menu".into(),
                                                        "allow-text".into(),
                                                        "allow-set-text".into(),
                                                        "allow-is-enabled".into(),
                                                        "allow-set-enabled".into(),
                                                        "allow-set-accelerator".into(),
                                                        "allow-set-as-windows-menu-for-nsapp".into(),
                                                        "allow-set-as-help-menu-for-nsapp".into(),
                                                        "allow-is-checked".into(),
                                                        "allow-set-checked".into(),
                                                        "allow-set-icon".into(),
                                                    ]),
                                                ),
                                            }),
                                            permissions: {
                                                let mut map = ::std::collections::BTreeMap::new();
                                                map.insert(
                                                    "allow-append".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-append".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the append command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["append".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-create-default".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-create-default".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the create_default command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["create_default".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-get".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-get".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the get command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["get".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-insert".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-insert".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the insert command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["insert".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-is-checked".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-is-checked".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the is_checked command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_checked".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-is-enabled".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-is-enabled".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the is_enabled command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_enabled".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-items".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-items".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the items command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["items".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-new".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-new".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the new command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["new".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-popup".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-popup".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the popup command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["popup".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-prepend".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-prepend".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the prepend command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["prepend".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-remove".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-remove".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the remove command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["remove".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-remove-at".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-remove-at".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the remove_at command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["remove_at".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-accelerator".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-accelerator".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_accelerator command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_accelerator".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-as-app-menu".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-as-app-menu".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_as_app_menu command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_as_app_menu".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-as-help-menu-for-nsapp".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-as-help-menu-for-nsapp".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_as_help_menu_for_nsapp command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new([
                                                                    "set_as_help_menu_for_nsapp".into(),
                                                                ]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-as-window-menu".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-as-window-menu".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_as_window_menu command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_as_window_menu".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-as-windows-menu-for-nsapp".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-as-windows-menu-for-nsapp".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_as_windows_menu_for_nsapp command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new([
                                                                    "set_as_windows_menu_for_nsapp".into(),
                                                                ]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-checked".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-checked".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_checked command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_checked".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-enabled".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-enabled".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_enabled command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_enabled".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-icon".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-icon".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_icon command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_icon".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-text".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-text".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_text command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_text".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-text".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-text".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the text command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["text".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-append".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-append".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the append command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["append".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-create-default".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-create-default".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the create_default command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["create_default".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-get".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-get".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the get command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["get".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-insert".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-insert".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the insert command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["insert".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-is-checked".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-is-checked".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the is_checked command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_checked".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-is-enabled".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-is-enabled".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the is_enabled command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_enabled".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-items".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-items".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the items command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["items".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-new".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-new".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the new command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["new".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-popup".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-popup".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the popup command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["popup".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-prepend".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-prepend".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the prepend command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["prepend".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-remove".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-remove".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the remove command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["remove".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-remove-at".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-remove-at".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the remove_at command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["remove_at".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-accelerator".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-accelerator".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_accelerator command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_accelerator".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-as-app-menu".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-as-app-menu".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_as_app_menu command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_as_app_menu".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-as-help-menu-for-nsapp".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-as-help-menu-for-nsapp".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_as_help_menu_for_nsapp command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new([
                                                                    "set_as_help_menu_for_nsapp".into(),
                                                                ]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-as-window-menu".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-as-window-menu".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_as_window_menu command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_as_window_menu".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-as-windows-menu-for-nsapp".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-as-windows-menu-for-nsapp".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_as_windows_menu_for_nsapp command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new([
                                                                    "set_as_windows_menu_for_nsapp".into(),
                                                                ]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-checked".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-checked".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_checked command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_checked".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-enabled".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-enabled".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_enabled command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_enabled".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-icon".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-icon".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_icon command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_icon".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-text".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-text".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_text command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_text".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-text".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-text".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the text command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["text".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map
                                            },
                                            permission_sets: ::std::collections::BTreeMap::new(),
                                            global_scope_schema: ::core::option::Option::None,
                                        },
                                    );
                                    map.insert(
                                        "core:path".into(),
                                        ::tauri::utils::acl::manifest::Manifest {
                                            default_permission: ::core::option::Option::Some(::tauri::utils::acl::PermissionSet {
                                                identifier: "default".into(),
                                                description: "Default permissions for the plugin.".into(),
                                                permissions: <[_]>::into_vec(
                                                    #[rustc_box]
                                                    ::alloc::boxed::Box::new([
                                                        "allow-resolve-directory".into(),
                                                        "allow-resolve".into(),
                                                        "allow-normalize".into(),
                                                        "allow-join".into(),
                                                        "allow-dirname".into(),
                                                        "allow-extname".into(),
                                                        "allow-basename".into(),
                                                        "allow-is-absolute".into(),
                                                    ]),
                                                ),
                                            }),
                                            permissions: {
                                                let mut map = ::std::collections::BTreeMap::new();
                                                map.insert(
                                                    "allow-basename".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-basename".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the basename command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["basename".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-dirname".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-dirname".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the dirname command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["dirname".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-extname".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-extname".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the extname command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["extname".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-is-absolute".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-is-absolute".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the is_absolute command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_absolute".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-join".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-join".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the join command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["join".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-normalize".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-normalize".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the normalize command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["normalize".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-resolve".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-resolve".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the resolve command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["resolve".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-resolve-directory".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-resolve-directory".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the resolve_directory command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["resolve_directory".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-basename".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-basename".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the basename command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["basename".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-dirname".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-dirname".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the dirname command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["dirname".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-extname".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-extname".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the extname command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["extname".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-is-absolute".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-is-absolute".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the is_absolute command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_absolute".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-join".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-join".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the join command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["join".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-normalize".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-normalize".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the normalize command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["normalize".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-resolve".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-resolve".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the resolve command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["resolve".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-resolve-directory".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-resolve-directory".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the resolve_directory command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["resolve_directory".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map
                                            },
                                            permission_sets: ::std::collections::BTreeMap::new(),
                                            global_scope_schema: ::core::option::Option::None,
                                        },
                                    );
                                    map.insert(
                                        "core:resources".into(),
                                        ::tauri::utils::acl::manifest::Manifest {
                                            default_permission: ::core::option::Option::Some(::tauri::utils::acl::PermissionSet {
                                                identifier: "default".into(),
                                                description: "Default permissions for the plugin.".into(),
                                                permissions: <[_]>::into_vec(
                                                    #[rustc_box]
                                                    ::alloc::boxed::Box::new(["allow-close".into()]),
                                                ),
                                            }),
                                            permissions: {
                                                let mut map = ::std::collections::BTreeMap::new();
                                                map.insert(
                                                    "allow-close".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-close".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the close command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["close".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-close".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-close".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the close command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["close".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map
                                            },
                                            permission_sets: ::std::collections::BTreeMap::new(),
                                            global_scope_schema: ::core::option::Option::None,
                                        },
                                    );
                                    map.insert(
                                        "core:tray".into(),
                                        ::tauri::utils::acl::manifest::Manifest {
                                            default_permission: ::core::option::Option::Some(::tauri::utils::acl::PermissionSet {
                                                identifier: "default".into(),
                                                description: "Default permissions for the plugin.".into(),
                                                permissions: <[_]>::into_vec(
                                                    #[rustc_box]
                                                    ::alloc::boxed::Box::new([
                                                        "allow-new".into(),
                                                        "allow-get-by-id".into(),
                                                        "allow-remove-by-id".into(),
                                                        "allow-set-icon".into(),
                                                        "allow-set-menu".into(),
                                                        "allow-set-tooltip".into(),
                                                        "allow-set-title".into(),
                                                        "allow-set-visible".into(),
                                                        "allow-set-temp-dir-path".into(),
                                                        "allow-set-icon-as-template".into(),
                                                        "allow-set-show-menu-on-left-click".into(),
                                                    ]),
                                                ),
                                            }),
                                            permissions: {
                                                let mut map = ::std::collections::BTreeMap::new();
                                                map.insert(
                                                    "allow-get-by-id".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-get-by-id".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the get_by_id command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["get_by_id".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-new".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-new".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the new command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["new".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-remove-by-id".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-remove-by-id".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the remove_by_id command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["remove_by_id".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-icon".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-icon".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_icon command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_icon".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-icon-as-template".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-icon-as-template".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_icon_as_template command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_icon_as_template".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-menu".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-menu".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_menu command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_menu".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-show-menu-on-left-click".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-show-menu-on-left-click".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_show_menu_on_left_click command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new([
                                                                    "set_show_menu_on_left_click".into(),
                                                                ]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-temp-dir-path".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-temp-dir-path".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_temp_dir_path command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_temp_dir_path".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-title".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-title".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_title command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_title".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-tooltip".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-tooltip".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_tooltip command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_tooltip".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-visible".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-visible".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_visible command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_visible".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-get-by-id".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-get-by-id".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the get_by_id command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["get_by_id".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-new".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-new".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the new command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["new".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-remove-by-id".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-remove-by-id".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the remove_by_id command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["remove_by_id".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-icon".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-icon".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_icon command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_icon".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-icon-as-template".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-icon-as-template".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_icon_as_template command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_icon_as_template".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-menu".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-menu".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_menu command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_menu".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-show-menu-on-left-click".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-show-menu-on-left-click".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_show_menu_on_left_click command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new([
                                                                    "set_show_menu_on_left_click".into(),
                                                                ]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-temp-dir-path".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-temp-dir-path".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_temp_dir_path command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_temp_dir_path".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-title".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-title".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_title command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_title".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-tooltip".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-tooltip".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_tooltip command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_tooltip".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-visible".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-visible".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_visible command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_visible".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map
                                            },
                                            permission_sets: ::std::collections::BTreeMap::new(),
                                            global_scope_schema: ::core::option::Option::None,
                                        },
                                    );
                                    map.insert(
                                        "core:webview".into(),
                                        ::tauri::utils::acl::manifest::Manifest {
                                            default_permission: ::core::option::Option::Some(::tauri::utils::acl::PermissionSet {
                                                identifier: "default".into(),
                                                description: "Default permissions for the plugin.".into(),
                                                permissions: <[_]>::into_vec(
                                                    #[rustc_box]
                                                    ::alloc::boxed::Box::new([
                                                        "allow-get-all-webviews".into(),
                                                        "allow-webview-position".into(),
                                                        "allow-webview-size".into(),
                                                        "allow-internal-toggle-devtools".into(),
                                                    ]),
                                                ),
                                            }),
                                            permissions: {
                                                let mut map = ::std::collections::BTreeMap::new();
                                                map.insert(
                                                    "allow-create-webview".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-create-webview".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the create_webview command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["create_webview".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-create-webview-window".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-create-webview-window".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the create_webview_window command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["create_webview_window".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-get-all-webviews".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-get-all-webviews".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the get_all_webviews command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["get_all_webviews".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-internal-toggle-devtools".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-internal-toggle-devtools".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the internal_toggle_devtools command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new([
                                                                    "internal_toggle_devtools".into(),
                                                                ]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-print".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-print".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the print command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["print".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-reparent".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-reparent".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the reparent command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["reparent".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-webview-focus".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-webview-focus".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_webview_focus command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_webview_focus".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-webview-position".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-webview-position".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_webview_position command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_webview_position".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-webview-size".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-webview-size".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_webview_size command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_webview_size".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-webview-zoom".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-webview-zoom".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_webview_zoom command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_webview_zoom".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-webview-close".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-webview-close".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the webview_close command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["webview_close".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-webview-position".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-webview-position".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the webview_position command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["webview_position".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-webview-size".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-webview-size".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the webview_size command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["webview_size".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-create-webview".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-create-webview".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the create_webview command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["create_webview".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-create-webview-window".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-create-webview-window".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the create_webview_window command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["create_webview_window".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-get-all-webviews".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-get-all-webviews".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the get_all_webviews command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["get_all_webviews".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-internal-toggle-devtools".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-internal-toggle-devtools".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the internal_toggle_devtools command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new([
                                                                    "internal_toggle_devtools".into(),
                                                                ]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-print".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-print".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the print command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["print".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-reparent".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-reparent".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the reparent command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["reparent".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-webview-focus".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-webview-focus".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_webview_focus command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_webview_focus".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-webview-position".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-webview-position".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_webview_position command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_webview_position".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-webview-size".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-webview-size".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_webview_size command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_webview_size".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-webview-zoom".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-webview-zoom".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_webview_zoom command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_webview_zoom".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-webview-close".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-webview-close".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the webview_close command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["webview_close".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-webview-position".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-webview-position".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the webview_position command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["webview_position".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-webview-size".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-webview-size".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the webview_size command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["webview_size".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map
                                            },
                                            permission_sets: ::std::collections::BTreeMap::new(),
                                            global_scope_schema: ::core::option::Option::None,
                                        },
                                    );
                                    map.insert(
                                        "core:window".into(),
                                        ::tauri::utils::acl::manifest::Manifest {
                                            default_permission: ::core::option::Option::Some(::tauri::utils::acl::PermissionSet {
                                                identifier: "default".into(),
                                                description: "Default permissions for the plugin.".into(),
                                                permissions: <[_]>::into_vec(
                                                    #[rustc_box]
                                                    ::alloc::boxed::Box::new([
                                                        "allow-get-all-windows".into(),
                                                        "allow-scale-factor".into(),
                                                        "allow-inner-position".into(),
                                                        "allow-outer-position".into(),
                                                        "allow-inner-size".into(),
                                                        "allow-outer-size".into(),
                                                        "allow-is-fullscreen".into(),
                                                        "allow-is-minimized".into(),
                                                        "allow-is-maximized".into(),
                                                        "allow-is-focused".into(),
                                                        "allow-is-decorated".into(),
                                                        "allow-is-resizable".into(),
                                                        "allow-is-maximizable".into(),
                                                        "allow-is-minimizable".into(),
                                                        "allow-is-closable".into(),
                                                        "allow-is-visible".into(),
                                                        "allow-title".into(),
                                                        "allow-current-monitor".into(),
                                                        "allow-primary-monitor".into(),
                                                        "allow-monitor-from-point".into(),
                                                        "allow-available-monitors".into(),
                                                        "allow-cursor-position".into(),
                                                        "allow-theme".into(),
                                                        "allow-internal-toggle-maximize".into(),
                                                    ]),
                                                ),
                                            }),
                                            permissions: {
                                                let mut map = ::std::collections::BTreeMap::new();
                                                map.insert(
                                                    "allow-available-monitors".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-available-monitors".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the available_monitors command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["available_monitors".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-center".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-center".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the center command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["center".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-close".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-close".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the close command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["close".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-create".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-create".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the create command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["create".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-current-monitor".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-current-monitor".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the current_monitor command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["current_monitor".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-cursor-position".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-cursor-position".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the cursor_position command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["cursor_position".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-destroy".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-destroy".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the destroy command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["destroy".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-get-all-windows".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-get-all-windows".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the get_all_windows command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["get_all_windows".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-hide".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-hide".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the hide command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["hide".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-inner-position".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-inner-position".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the inner_position command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["inner_position".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-inner-size".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-inner-size".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the inner_size command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["inner_size".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-internal-toggle-maximize".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-internal-toggle-maximize".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the internal_toggle_maximize command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new([
                                                                    "internal_toggle_maximize".into(),
                                                                ]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-is-closable".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-is-closable".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the is_closable command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_closable".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-is-decorated".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-is-decorated".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the is_decorated command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_decorated".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-is-focused".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-is-focused".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the is_focused command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_focused".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-is-fullscreen".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-is-fullscreen".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the is_fullscreen command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_fullscreen".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-is-maximizable".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-is-maximizable".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the is_maximizable command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_maximizable".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-is-maximized".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-is-maximized".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the is_maximized command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_maximized".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-is-minimizable".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-is-minimizable".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the is_minimizable command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_minimizable".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-is-minimized".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-is-minimized".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the is_minimized command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_minimized".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-is-resizable".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-is-resizable".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the is_resizable command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_resizable".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-is-visible".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-is-visible".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the is_visible command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_visible".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-maximize".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-maximize".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the maximize command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["maximize".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-minimize".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-minimize".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the minimize command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["minimize".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-monitor-from-point".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-monitor-from-point".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the monitor_from_point command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["monitor_from_point".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-outer-position".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-outer-position".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the outer_position command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["outer_position".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-outer-size".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-outer-size".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the outer_size command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["outer_size".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-primary-monitor".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-primary-monitor".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the primary_monitor command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["primary_monitor".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-request-user-attention".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-request-user-attention".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the request_user_attention command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["request_user_attention".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-scale-factor".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-scale-factor".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the scale_factor command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["scale_factor".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-always-on-bottom".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-always-on-bottom".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_always_on_bottom command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_always_on_bottom".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-always-on-top".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-always-on-top".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_always_on_top command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_always_on_top".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-closable".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-closable".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_closable command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_closable".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-content-protected".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-content-protected".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_content_protected command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_content_protected".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-cursor-grab".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-cursor-grab".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_cursor_grab command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_cursor_grab".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-cursor-icon".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-cursor-icon".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_cursor_icon command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_cursor_icon".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-cursor-position".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-cursor-position".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_cursor_position command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_cursor_position".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-cursor-visible".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-cursor-visible".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_cursor_visible command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_cursor_visible".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-decorations".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-decorations".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_decorations command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_decorations".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-effects".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-effects".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_effects command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_effects".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-focus".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-focus".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_focus command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_focus".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-fullscreen".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-fullscreen".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_fullscreen command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_fullscreen".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-icon".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-icon".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_icon command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_icon".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-ignore-cursor-events".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-ignore-cursor-events".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_ignore_cursor_events command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new([
                                                                    "set_ignore_cursor_events".into(),
                                                                ]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-max-size".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-max-size".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_max_size command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_max_size".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-maximizable".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-maximizable".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_maximizable command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_maximizable".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-min-size".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-min-size".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_min_size command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_min_size".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-minimizable".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-minimizable".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_minimizable command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_minimizable".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-position".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-position".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_position command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_position".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-progress-bar".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-progress-bar".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_progress_bar command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_progress_bar".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-resizable".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-resizable".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_resizable command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_resizable".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-shadow".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-shadow".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_shadow command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_shadow".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-size".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-size".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_size command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_size".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-size-constraints".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-size-constraints".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_size_constraints command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_size_constraints".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-skip-taskbar".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-skip-taskbar".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_skip_taskbar command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_skip_taskbar".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-title".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-title".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_title command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_title".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-title-bar-style".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-title-bar-style".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_title_bar_style command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_title_bar_style".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-set-visible-on-all-workspaces".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-set-visible-on-all-workspaces".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the set_visible_on_all_workspaces command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new([
                                                                    "set_visible_on_all_workspaces".into(),
                                                                ]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-show".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-show".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the show command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["show".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-start-dragging".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-start-dragging".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the start_dragging command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["start_dragging".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-start-resize-dragging".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-start-resize-dragging".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the start_resize_dragging command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["start_resize_dragging".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-theme".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-theme".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the theme command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["theme".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-title".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-title".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the title command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["title".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-toggle-maximize".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-toggle-maximize".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the toggle_maximize command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["toggle_maximize".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-unmaximize".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-unmaximize".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the unmaximize command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["unmaximize".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-unminimize".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-unminimize".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the unminimize command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["unminimize".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-available-monitors".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-available-monitors".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the available_monitors command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["available_monitors".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-center".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-center".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the center command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["center".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-close".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-close".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the close command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["close".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-create".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-create".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the create command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["create".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-current-monitor".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-current-monitor".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the current_monitor command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["current_monitor".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-cursor-position".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-cursor-position".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the cursor_position command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["cursor_position".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-destroy".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-destroy".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the destroy command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["destroy".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-get-all-windows".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-get-all-windows".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the get_all_windows command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["get_all_windows".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-hide".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-hide".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the hide command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["hide".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-inner-position".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-inner-position".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the inner_position command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["inner_position".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-inner-size".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-inner-size".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the inner_size command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["inner_size".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-internal-toggle-maximize".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-internal-toggle-maximize".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the internal_toggle_maximize command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new([
                                                                    "internal_toggle_maximize".into(),
                                                                ]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-is-closable".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-is-closable".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the is_closable command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_closable".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-is-decorated".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-is-decorated".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the is_decorated command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_decorated".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-is-focused".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-is-focused".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the is_focused command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_focused".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-is-fullscreen".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-is-fullscreen".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the is_fullscreen command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_fullscreen".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-is-maximizable".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-is-maximizable".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the is_maximizable command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_maximizable".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-is-maximized".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-is-maximized".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the is_maximized command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_maximized".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-is-minimizable".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-is-minimizable".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the is_minimizable command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_minimizable".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-is-minimized".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-is-minimized".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the is_minimized command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_minimized".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-is-resizable".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-is-resizable".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the is_resizable command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_resizable".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-is-visible".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-is-visible".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the is_visible command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_visible".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-maximize".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-maximize".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the maximize command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["maximize".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-minimize".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-minimize".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the minimize command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["minimize".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-monitor-from-point".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-monitor-from-point".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the monitor_from_point command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["monitor_from_point".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-outer-position".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-outer-position".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the outer_position command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["outer_position".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-outer-size".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-outer-size".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the outer_size command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["outer_size".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-primary-monitor".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-primary-monitor".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the primary_monitor command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["primary_monitor".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-request-user-attention".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-request-user-attention".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the request_user_attention command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["request_user_attention".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-scale-factor".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-scale-factor".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the scale_factor command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["scale_factor".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-always-on-bottom".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-always-on-bottom".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_always_on_bottom command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_always_on_bottom".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-always-on-top".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-always-on-top".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_always_on_top command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_always_on_top".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-closable".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-closable".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_closable command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_closable".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-content-protected".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-content-protected".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_content_protected command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_content_protected".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-cursor-grab".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-cursor-grab".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_cursor_grab command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_cursor_grab".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-cursor-icon".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-cursor-icon".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_cursor_icon command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_cursor_icon".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-cursor-position".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-cursor-position".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_cursor_position command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_cursor_position".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-cursor-visible".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-cursor-visible".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_cursor_visible command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_cursor_visible".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-decorations".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-decorations".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_decorations command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_decorations".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-effects".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-effects".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_effects command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_effects".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-focus".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-focus".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_focus command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_focus".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-fullscreen".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-fullscreen".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_fullscreen command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_fullscreen".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-icon".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-icon".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_icon command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_icon".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-ignore-cursor-events".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-ignore-cursor-events".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_ignore_cursor_events command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new([
                                                                    "set_ignore_cursor_events".into(),
                                                                ]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-max-size".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-max-size".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_max_size command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_max_size".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-maximizable".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-maximizable".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_maximizable command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_maximizable".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-min-size".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-min-size".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_min_size command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_min_size".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-minimizable".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-minimizable".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_minimizable command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_minimizable".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-position".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-position".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_position command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_position".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-progress-bar".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-progress-bar".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_progress_bar command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_progress_bar".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-resizable".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-resizable".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_resizable command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_resizable".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-shadow".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-shadow".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_shadow command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_shadow".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-size".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-size".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_size command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_size".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-size-constraints".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-size-constraints".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_size_constraints command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_size_constraints".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-skip-taskbar".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-skip-taskbar".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_skip_taskbar command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_skip_taskbar".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-title".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-title".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_title command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_title".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-title-bar-style".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-title-bar-style".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_title_bar_style command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["set_title_bar_style".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-set-visible-on-all-workspaces".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-set-visible-on-all-workspaces".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the set_visible_on_all_workspaces command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new([
                                                                    "set_visible_on_all_workspaces".into(),
                                                                ]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-show".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-show".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the show command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["show".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-start-dragging".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-start-dragging".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the start_dragging command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["start_dragging".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-start-resize-dragging".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-start-resize-dragging".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the start_resize_dragging command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["start_resize_dragging".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-theme".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-theme".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the theme command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["theme".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-title".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-title".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the title command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["title".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-toggle-maximize".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-toggle-maximize".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the toggle_maximize command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["toggle_maximize".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-unmaximize".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-unmaximize".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the unmaximize command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["unmaximize".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-unminimize".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-unminimize".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the unminimize command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["unminimize".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map
                                            },
                                            permission_sets: ::std::collections::BTreeMap::new(),
                                            global_scope_schema: ::core::option::Option::None,
                                        },
                                    );
                                    map.insert(
                                        "deep-link".into(),
                                        ::tauri::utils::acl::manifest::Manifest {
                                            default_permission: ::core::option::Option::Some(::tauri::utils::acl::PermissionSet {
                                                identifier: "default".into(),
                                                description: "Allows reading the opened deep link via the get_current command"
                                                    .into(),
                                                permissions: <[_]>::into_vec(
                                                    #[rustc_box]
                                                    ::alloc::boxed::Box::new(["allow-get-current".into()]),
                                                ),
                                            }),
                                            permissions: {
                                                let mut map = ::std::collections::BTreeMap::new();
                                                map.insert(
                                                    "allow-get-current".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-get-current".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the get_current command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["get_current".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-is-registered".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-is-registered".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the is_registered command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_registered".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-register".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-register".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the register command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["register".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-unregister".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-unregister".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the unregister command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["unregister".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-get-current".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-get-current".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the get_current command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["get_current".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-is-registered".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-is-registered".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the is_registered command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["is_registered".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-register".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-register".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the register command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["register".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-unregister".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-unregister".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the unregister command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["unregister".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map
                                            },
                                            permission_sets: ::std::collections::BTreeMap::new(),
                                            global_scope_schema: ::core::option::Option::None,
                                        },
                                    );
                                    map.insert(
                                        "dialog".into(),
                                        ::tauri::utils::acl::manifest::Manifest {
                                            default_permission: ::core::option::Option::Some(::tauri::utils::acl::PermissionSet {
                                                identifier: "default".into(),
                                                description: "This permission set configures the types of dialogs\navailable from the dialog plugin.\n\n#### Granted Permissions\n\nAll dialog types are enabled.\n\n\n"
                                                    .into(),
                                                permissions: <[_]>::into_vec(
                                                    #[rustc_box]
                                                    ::alloc::boxed::Box::new([
                                                        "allow-ask".into(),
                                                        "allow-confirm".into(),
                                                        "allow-message".into(),
                                                        "allow-save".into(),
                                                        "allow-open".into(),
                                                    ]),
                                                ),
                                            }),
                                            permissions: {
                                                let mut map = ::std::collections::BTreeMap::new();
                                                map.insert(
                                                    "allow-ask".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-ask".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the ask command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["ask".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-confirm".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-confirm".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the confirm command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["confirm".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-message".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-message".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the message command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["message".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-open".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-open".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the open command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["open".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-save".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-save".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the save command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["save".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-ask".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-ask".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the ask command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["ask".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-confirm".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-confirm".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the confirm command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["confirm".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-message".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-message".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the message command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["message".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-open".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-open".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the open command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["open".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-save".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-save".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the save command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["save".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map
                                            },
                                            permission_sets: ::std::collections::BTreeMap::new(),
                                            global_scope_schema: ::core::option::Option::None,
                                        },
                                    );
                                    map.insert(
                                        "updater".into(),
                                        ::tauri::utils::acl::manifest::Manifest {
                                            default_permission: ::core::option::Option::Some(::tauri::utils::acl::PermissionSet {
                                                identifier: "default".into(),
                                                description: "This permission set configures which kind of\nupdater functions are exposed to the frontend.\n\n#### Granted Permissions\n\nThe full workflow from checking for updates to installing them\nis enabled.\n\n"
                                                    .into(),
                                                permissions: <[_]>::into_vec(
                                                    #[rustc_box]
                                                    ::alloc::boxed::Box::new([
                                                        "allow-check".into(),
                                                        "allow-download".into(),
                                                        "allow-install".into(),
                                                        "allow-download-and-install".into(),
                                                    ]),
                                                ),
                                            }),
                                            permissions: {
                                                let mut map = ::std::collections::BTreeMap::new();
                                                map.insert(
                                                    "allow-check".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-check".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the check command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["check".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-download".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-download".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the download command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["download".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-download-and-install".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-download-and-install".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the download_and_install command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["download_and_install".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "allow-install".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "allow-install".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Enables the install command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["install".into()]),
                                                            ),
                                                            deny: ::alloc::vec::Vec::new(),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-check".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-check".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the check command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["check".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-download".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-download".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the download command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["download".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-download-and-install".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-download-and-install".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the download_and_install command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["download_and_install".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map.insert(
                                                    "deny-install".into(),
                                                    ::tauri::utils::acl::Permission {
                                                        version: ::core::option::Option::None,
                                                        identifier: "deny-install".into(),
                                                        description: ::core::option::Option::Some(
                                                            "Denies the install command without any pre-configured scope."
                                                                .into(),
                                                        ),
                                                        commands: ::tauri::utils::acl::Commands {
                                                            allow: ::alloc::vec::Vec::new(),
                                                            deny: <[_]>::into_vec(
                                                                #[rustc_box]
                                                                ::alloc::boxed::Box::new(["install".into()]),
                                                            ),
                                                        },
                                                        scope: ::tauri::utils::acl::Scopes {
                                                            allow: ::core::option::Option::None,
                                                            deny: ::core::option::Option::None,
                                                        },
                                                        platforms: ::core::option::Option::None,
                                                    },
                                                );
                                                map
                                            },
                                            permission_sets: ::std::collections::BTreeMap::new(),
                                            global_scope_schema: ::core::option::Option::None,
                                        },
                                    );
                                    map
                                },
                                ::tauri::utils::acl::resolved::Resolved {
                                    allowed_commands: {
                                        let mut map = ::std::collections::BTreeMap::new();
                                        map.insert(
                                            "plugin:app|name".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:app|tauri_version".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:app|version".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:event|emit".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:event|emit_to".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:event|listen".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:event|unlisten".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:menu|append".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:menu|create_default".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:menu|get".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:menu|insert".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:menu|is_checked".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:menu|is_enabled".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:menu|items".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:menu|new".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:menu|popup".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:menu|prepend".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:menu|remove".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:menu|remove_at".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:menu|set_accelerator".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:menu|set_as_app_menu".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:menu|set_as_help_menu_for_nsapp".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:menu|set_as_window_menu".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:menu|set_as_windows_menu_for_nsapp".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:menu|set_checked".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:menu|set_enabled".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:menu|set_icon".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:menu|set_text".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:menu|text".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:path|basename".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:path|dirname".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:path|extname".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:path|is_absolute".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:path|join".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:path|normalize".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:path|resolve".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:path|resolve_directory".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:resources|close".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:tray|get_by_id".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:tray|new".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:tray|remove_by_id".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:tray|set_icon".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:tray|set_icon_as_template".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:tray|set_menu".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:tray|set_show_menu_on_left_click".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:tray|set_temp_dir_path".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:tray|set_title".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:tray|set_tooltip".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:tray|set_visible".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:updater|check".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "desktop-capability".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: ::alloc::vec::Vec::new(),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "desktop-capability".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: ::alloc::vec::Vec::new(),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "desktop-capability".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: ::alloc::vec::Vec::new(),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:updater|download".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "desktop-capability".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: ::alloc::vec::Vec::new(),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "desktop-capability".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: ::alloc::vec::Vec::new(),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "desktop-capability".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: ::alloc::vec::Vec::new(),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:updater|download_and_install".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "desktop-capability".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: ::alloc::vec::Vec::new(),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "desktop-capability".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: ::alloc::vec::Vec::new(),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "desktop-capability".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: ::alloc::vec::Vec::new(),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:updater|install".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "desktop-capability".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: ::alloc::vec::Vec::new(),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "desktop-capability".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: ::alloc::vec::Vec::new(),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "desktop-capability".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: ::alloc::vec::Vec::new(),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:window|available_monitors".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:window|current_monitor".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:window|cursor_position".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:window|get_all_windows".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:window|inner_position".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:window|inner_size".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:window|internal_toggle_maximize".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:window|is_closable".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:window|is_decorated".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:window|is_focused".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:window|is_fullscreen".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:window|is_maximizable".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:window|is_maximized".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:window|is_minimizable".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:window|is_minimized".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:window|is_resizable".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:window|is_visible".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:window|monitor_from_point".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:window|outer_position".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:window|outer_size".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:window|primary_monitor".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:window|scale_factor".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:window|start_dragging".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "allow-start-dragging".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:window|theme".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map.insert(
                                            "plugin:window|title".into(),
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::tauri::utils::acl::resolved::ResolvedCommand {
                                                        context: ::tauri::utils::acl::ExecutionContext::Local,
                                                        referenced_by: ::tauri::utils::acl::resolved::ResolvedCommandReference {
                                                            capability: "migrated".into(),
                                                            permission: "default".into(),
                                                        },
                                                        windows: <[_]>::into_vec(
                                                            #[rustc_box]
                                                            ::alloc::boxed::Box::new(["main".parse().unwrap()]),
                                                        ),
                                                        webviews: ::alloc::vec::Vec::new(),
                                                        scope_id: ::core::option::Option::None,
                                                    },
                                                ]),
                                            ),
                                        );
                                        map
                                    },
                                    denied_commands: ::std::collections::BTreeMap::new(),
                                    command_scope: ::std::collections::BTreeMap::new(),
                                    global_scope: ::std::collections::BTreeMap::new(),
                                },
                            ),
                            ::std::option::Option::Some(
                                &[
                                    "if(\"__TAURI__\"in window){var __TAURI_PLUGIN_DEEP_LINK__=function(e){\"use strict\";function n(e,n=!1){return window.__TAURI_INTERNALS__.transformCallback(e,n)}async function r(e,n={},r){return window.__TAURI_INTERNALS__.invoke(e,n,r)}var t;async function i(e,t,i){const a={kind:\"Any\"};return r(\"plugin:event|listen\",{event:e,target:a,handler:n(t)}).then((n=>async()=>async function(e,n){await r(\"plugin:event|unlisten\",{event:e,eventId:n})}(e,n)))}async function a(){return await r(\"plugin:deep-link|get_current\")}return\"function\"==typeof SuppressedError&&SuppressedError,function(e){e.WINDOW_RESIZED=\"tauri://resize\",e.WINDOW_MOVED=\"tauri://move\",e.WINDOW_CLOSE_REQUESTED=\"tauri://close-requested\",e.WINDOW_DESTROYED=\"tauri://destroyed\",e.WINDOW_FOCUS=\"tauri://focus\",e.WINDOW_BLUR=\"tauri://blur\",e.WINDOW_SCALE_FACTOR_CHANGED=\"tauri://scale-change\",e.WINDOW_THEME_CHANGED=\"tauri://theme-changed\",e.WINDOW_CREATED=\"tauri://window-created\",e.WEBVIEW_CREATED=\"tauri://webview-created\",e.DRAG_ENTER=\"tauri://drag-enter\",e.DRAG_OVER=\"tauri://drag-over\",e.DRAG_DROP=\"tauri://drag-drop\",e.DRAG_LEAVE=\"tauri://drag-leave\"}(t||(t={})),e.getCurrent=a,e.isRegistered=async function(e){return await r(\"plugin:deep-link|is_registered\",{protocol:e})},e.onOpenUrl=async function(e){const n=await a();return n&&e(n),await i(\"deep-link://new-url\",(n=>{e(n.payload)}))},e.register=async function(e){return await r(\"plugin:deep-link|register\",{protocol:e})},e.unregister=async function(e){return await r(\"plugin:deep-link|unregister\",{protocol:e})},e}({});Object.defineProperty(window.__TAURI__,\"deepLink\",{value:__TAURI_PLUGIN_DEEP_LINK__})}\n",
                                    "if(\"__TAURI__\"in window){var __TAURI_PLUGIN_DIALOG__=function(t){\"use strict\";async function n(t,n={},e){return window.__TAURI_INTERNALS__.invoke(t,n,e)}return\"function\"==typeof SuppressedError&&SuppressedError,t.ask=async function(t,e){const i=\"string\"==typeof e?{title:e}:e;return await n(\"plugin:dialog|ask\",{message:t.toString(),title:i?.title?.toString(),kind:i?.kind,okButtonLabel:i?.okLabel?.toString()??\"Yes\",cancelButtonLabel:i?.cancelLabel?.toString()??\"No\"})},t.confirm=async function(t,e){const i=\"string\"==typeof e?{title:e}:e;return await n(\"plugin:dialog|confirm\",{message:t.toString(),title:i?.title?.toString(),kind:i?.kind,okButtonLabel:i?.okLabel?.toString()??\"Ok\",cancelButtonLabel:i?.cancelLabel?.toString()??\"Cancel\"})},t.message=async function(t,e){const i=\"string\"==typeof e?{title:e}:e;await n(\"plugin:dialog|message\",{message:t.toString(),title:i?.title?.toString(),kind:i?.kind,okButtonLabel:i?.okLabel?.toString()})},t.open=async function(t={}){return\"object\"==typeof t&&Object.freeze(t),await n(\"plugin:dialog|open\",{options:t})},t.save=async function(t={}){return\"object\"==typeof t&&Object.freeze(t),await n(\"plugin:dialog|save\",{options:t})},t}({});Object.defineProperty(window.__TAURI__,\"dialog\",{value:__TAURI_PLUGIN_DIALOG__})}\n",
                                    "if(\"__TAURI__\"in window){var __TAURI_PLUGIN_UPDATER__=function(e){\"use strict\";function t(e,t,s,n){if(\"a\"===s&&!n)throw new TypeError(\"Private accessor was defined without a getter\");if(\"function\"==typeof t?e!==t||!n:!t.has(e))throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");return\"m\"===s?n:\"a\"===s?n.call(e):n?n.value:t.get(e)}function s(e,t,s,n,i){if(\"function\"==typeof t?e!==t||!i:!t.has(e))throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");return t.set(e,s),s}var n,i,r,a;\"function\"==typeof SuppressedError&&SuppressedError;class o{constructor(){this.__TAURI_CHANNEL_MARKER__=!0,n.set(this,(()=>{})),i.set(this,0),r.set(this,{}),this.id=function(e,t=!1){return window.__TAURI_INTERNALS__.transformCallback(e,t)}((({message:e,id:a})=>{if(a===t(this,i,\"f\")){s(this,i,a+1),t(this,n,\"f\").call(this,e);const o=Object.keys(t(this,r,\"f\"));if(o.length>0){let e=a+1;for(const s of o.sort()){if(parseInt(s)!==e)break;{const i=t(this,r,\"f\")[s];delete t(this,r,\"f\")[s],t(this,n,\"f\").call(this,i),e+=1}}s(this,i,e)}}else t(this,r,\"f\")[a.toString()]=e}))}set onmessage(e){s(this,n,e)}get onmessage(){return t(this,n,\"f\")}toJSON(){return`__CHANNEL__:${this.id}`}}async function d(e,t={},s){return window.__TAURI_INTERNALS__.invoke(e,t,s)}n=new WeakMap,i=new WeakMap,r=new WeakMap;class l{get rid(){return t(this,a,\"f\")}constructor(e){a.set(this,void 0),s(this,a,e)}async close(){return d(\"plugin:resources|close\",{rid:this.rid})}}a=new WeakMap;class c extends l{constructor(e){super(e.rid),this.available=e.available,this.currentVersion=e.currentVersion,this.version=e.version,this.date=e.date,this.body=e.body}async download(e){const t=new o;e&&(t.onmessage=e);const s=await d(\"plugin:updater|download\",{onEvent:t,rid:this.rid});this.downloadedBytes=new l(s)}async install(){if(!this.downloadedBytes)throw new Error(\"Update.install called before Update.download\");await d(\"plugin:updater|install\",{updateRid:this.rid,bytesRid:this.downloadedBytes.rid}),this.downloadedBytes=void 0}async downloadAndInstall(e){const t=new o;e&&(t.onmessage=e),await d(\"plugin:updater|download_and_install\",{onEvent:t,rid:this.rid})}async close(){await(this.downloadedBytes?.close()),await super.close()}}return e.Update=c,e.check=async function(e){return e?.headers&&(e.headers=Array.from(new Headers(e.headers).entries())),await d(\"plugin:updater|check\",{...e}).then((e=>e.available?new c(e):null))},e}({});Object.defineProperty(window.__TAURI__,\"updater\",{value:__TAURI_PLUGIN_UPDATER__})}\n",
                                ],
                            ),
                        );
                        {
                            context
                                .with_config_parent(
                                    "/home/ovenoboyo/projects/moosync/tauri/Moosync/src-tauri",
                                );
                        }
                        context
                    })
                    .expect("error while running tauri application");
            }
        }
    }
}
